(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/mcs8Client.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/awaitqueue/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AwaitQueue {\n    constructor({ ClosedErrorClass = Error, StoppedErrorClass = Error } = {\n        ClosedErrorClass: Error,\n        StoppedErrorClass: Error\n    }) {\n        // Closed flag.\n        this.closed = false;\n        // Queue of pending tasks.\n        this.pendingTasks = [];\n        // Error class used when rejecting a task due to AwaitQueue being closed.\n        this.ClosedErrorClass = Error;\n        // Error class used when rejecting a task due to AwaitQueue being stopped.\n        this.StoppedErrorClass = Error;\n        this.ClosedErrorClass = ClosedErrorClass;\n        this.StoppedErrorClass = StoppedErrorClass;\n    }\n    /**\n     * The number of ongoing enqueued tasks.\n     */\n    get size() {\n        return this.pendingTasks.length;\n    }\n    /**\n     * Closes the AwaitQueue. Pending tasks will be rejected with ClosedErrorClass\n     * error.\n     */\n    close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        for (const pendingTask of this.pendingTasks) {\n            pendingTask.stopped = true;\n            pendingTask.reject(new this.ClosedErrorClass('AwaitQueue closed'));\n        }\n        // Enpty the pending tasks array.\n        this.pendingTasks.length = 0;\n    }\n    /**\n     * Accepts a task as argument (and an optional task name) and enqueues it after\n     * pending tasks. Once processed, the push() method resolves (or rejects) with\n     * the result returned by the given task.\n     *\n     * The given task must return a Promise or directly a value.\n     */\n    push(task, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.closed)\n                throw new this.ClosedErrorClass('AwaitQueue closed');\n            if (typeof task !== 'function')\n                throw new TypeError('given task is not a function');\n            if (!task.name && name) {\n                try {\n                    Object.defineProperty(task, 'name', { value: name });\n                }\n                catch (error) { }\n            }\n            return new Promise((resolve, reject) => {\n                const pendingTask = {\n                    task,\n                    name,\n                    resolve,\n                    reject,\n                    stopped: false,\n                    enqueuedAt: new Date(),\n                    executedAt: undefined\n                };\n                // Append task to the queue.\n                this.pendingTasks.push(pendingTask);\n                // And run it if this is the only task in the queue.\n                if (this.pendingTasks.length === 1)\n                    this.next();\n            });\n        });\n    }\n    /**\n     * Make ongoing pending tasks reject with the given StoppedErrorClass error.\n     * The AwaitQueue instance is still usable for future tasks added via push()\n     * method.\n     */\n    stop() {\n        if (this.closed)\n            return;\n        for (const pendingTask of this.pendingTasks) {\n            pendingTask.stopped = true;\n            pendingTask.reject(new this.StoppedErrorClass('AwaitQueue stopped'));\n        }\n        // Enpty the pending tasks array.\n        this.pendingTasks.length = 0;\n    }\n    dump() {\n        const now = new Date();\n        return this.pendingTasks.map((pendingTask) => {\n            return {\n                task: pendingTask.task,\n                name: pendingTask.name,\n                enqueuedTime: pendingTask.executedAt\n                    ? pendingTask.executedAt.getTime() - pendingTask.enqueuedAt.getTime()\n                    : now.getTime() - pendingTask.enqueuedAt.getTime(),\n                executingTime: pendingTask.executedAt\n                    ? now.getTime() - pendingTask.executedAt.getTime()\n                    : 0\n            };\n        });\n    }\n    next() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Take the first pending task.\n            const pendingTask = this.pendingTasks[0];\n            if (!pendingTask)\n                return;\n            // Execute it.\n            yield this.executeTask(pendingTask);\n            // Remove the first pending task (the completed one) from the queue.\n            this.pendingTasks.shift();\n            // And continue.\n            this.next();\n        });\n    }\n    executeTask(pendingTask) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If the task is stopped, ignore it.\n            if (pendingTask.stopped)\n                return;\n            pendingTask.executedAt = new Date();\n            try {\n                const result = yield pendingTask.task();\n                // If the task is stopped, ignore it.\n                if (pendingTask.stopped)\n                    return;\n                // Resolve the task with the returned result (if any).\n                pendingTask.resolve(result);\n            }\n            catch (error) {\n                // If the task is stopped, ignore it.\n                if (pendingTask.stopped)\n                    return;\n                // Reject the task with its own error.\n                pendingTask.reject(error);\n            }\n        });\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n\n\n//# sourceURL=webpack:///./node_modules/awaitqueue/lib/index.js?");

/***/ }),

/***/ "./node_modules/blueimp-md5/js/md5.js":
/*!********************************************!*\
  !*** ./node_modules/blueimp-md5/js/md5.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/* global define */\n\n/* eslint-disable strict */\n\n;(function ($) {\n  'use strict'\n\n  /**\n   * Add integers, wrapping at 2^32.\n   * This uses 16-bit operations internally to work around bugs in interpreters.\n   *\n   * @param {number} x First integer\n   * @param {number} y Second integer\n   * @returns {number} Sum\n   */\n  function safeAdd(x, y) {\n    var lsw = (x & 0xffff) + (y & 0xffff)\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n    return (msw << 16) | (lsw & 0xffff)\n  }\n\n  /**\n   * Bitwise rotate a 32-bit number to the left.\n   *\n   * @param {number} num 32-bit number\n   * @param {number} cnt Rotation count\n   * @returns {number} Rotated number\n   */\n  function bitRotateLeft(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt))\n  }\n\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} q q\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ff(a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5gg(a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t)\n  }\n\n  /**\n   * Calculate the MD5 of an array of little-endian words, and a bit length.\n   *\n   * @param {Array} x Array of little-endian words\n   * @param {number} len Bit length\n   * @returns {Array<number>} MD5 Array\n   */\n  function binlMD5(x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << len % 32\n    x[(((len + 64) >>> 9) << 4) + 14] = len\n\n    var i\n    var olda\n    var oldb\n    var oldc\n    var oldd\n    var a = 1732584193\n    var b = -271733879\n    var c = -1732584194\n    var d = 271733878\n\n    for (i = 0; i < x.length; i += 16) {\n      olda = a\n      oldb = b\n      oldc = c\n      oldd = d\n\n      a = md5ff(a, b, c, d, x[i], 7, -680876936)\n      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\n      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\n      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\n      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\n      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\n      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\n      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\n      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\n      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\n      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\n      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\n      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\n      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\n      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\n      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\n      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\n      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\n      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\n      b = md5gg(b, c, d, a, x[i], 20, -373897302)\n      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\n      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\n      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\n      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\n      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\n      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\n      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\n      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\n      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\n      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\n      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\n      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\n      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\n      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\n      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\n      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\n      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\n      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\n      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\n      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\n      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\n      d = md5hh(d, a, b, c, x[i], 11, -358537222)\n      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\n      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\n      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\n      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\n      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\n      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\n\n      a = md5ii(a, b, c, d, x[i], 6, -198630844)\n      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\n      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\n      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\n      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\n      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\n      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\n      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\n      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\n      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\n      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\n      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\n      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\n      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\n      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\n      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\n\n      a = safeAdd(a, olda)\n      b = safeAdd(b, oldb)\n      c = safeAdd(c, oldc)\n      d = safeAdd(d, oldd)\n    }\n    return [a, b, c, d]\n  }\n\n  /**\n   * Convert an array of little-endian words to a string\n   *\n   * @param {Array<number>} input MD5 Array\n   * @returns {string} MD5 string\n   */\n  function binl2rstr(input) {\n    var i\n    var output = ''\n    var length32 = input.length * 32\n    for (i = 0; i < length32; i += 8) {\n      output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff)\n    }\n    return output\n  }\n\n  /**\n   * Convert a raw string to an array of little-endian words\n   * Characters >255 have their high-byte silently ignored.\n   *\n   * @param {string} input Raw input string\n   * @returns {Array<number>} Array of little-endian words\n   */\n  function rstr2binl(input) {\n    var i\n    var output = []\n    output[(input.length >> 2) - 1] = undefined\n    for (i = 0; i < output.length; i += 1) {\n      output[i] = 0\n    }\n    var length8 = input.length * 8\n    for (i = 0; i < length8; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32\n    }\n    return output\n  }\n\n  /**\n   * Calculate the MD5 of a raw string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrMD5(s) {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n  }\n\n  /**\n   * Calculates the HMAC-MD5 of a key and some data (raw strings)\n   *\n   * @param {string} key HMAC key\n   * @param {string} data Raw input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrHMACMD5(key, data) {\n    var i\n    var bkey = rstr2binl(key)\n    var ipad = []\n    var opad = []\n    var hash\n    ipad[15] = opad[15] = undefined\n    if (bkey.length > 16) {\n      bkey = binlMD5(bkey, key.length * 8)\n    }\n    for (i = 0; i < 16; i += 1) {\n      ipad[i] = bkey[i] ^ 0x36363636\n      opad[i] = bkey[i] ^ 0x5c5c5c5c\n    }\n    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n  }\n\n  /**\n   * Convert a raw string to a hex string\n   *\n   * @param {string} input Raw input string\n   * @returns {string} Hex encoded string\n   */\n  function rstr2hex(input) {\n    var hexTab = '0123456789abcdef'\n    var output = ''\n    var x\n    var i\n    for (i = 0; i < input.length; i += 1) {\n      x = input.charCodeAt(i)\n      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)\n    }\n    return output\n  }\n\n  /**\n   * Encode a string as UTF-8\n   *\n   * @param {string} input Input string\n   * @returns {string} UTF8 string\n   */\n  function str2rstrUTF8(input) {\n    return unescape(encodeURIComponent(input))\n  }\n\n  /**\n   * Encodes input string as raw MD5 string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawMD5(s) {\n    return rstrMD5(str2rstrUTF8(s))\n  }\n  /**\n   * Encodes input string as Hex encoded string\n   *\n   * @param {string} s Input string\n   * @returns {string} Hex encoded string\n   */\n  function hexMD5(s) {\n    return rstr2hex(rawMD5(s))\n  }\n  /**\n   * Calculates the raw HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawHMACMD5(k, d) {\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n  }\n  /**\n   * Calculates the Hex encoded HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function hexHMACMD5(k, d) {\n    return rstr2hex(rawHMACMD5(k, d))\n  }\n\n  /**\n   * Calculates MD5 value for a given string.\n   * If a key is provided, calculates the HMAC-MD5 value.\n   * Returns a Hex encoded string unless the raw argument is given.\n   *\n   * @param {string} string Input string\n   * @param {string} [key] HMAC key\n   * @param {boolean} [raw] Raw output switch\n   * @returns {string} MD5 output\n   */\n  function md5(string, key, raw) {\n    if (!key) {\n      if (!raw) {\n        return hexMD5(string)\n      }\n      return rawMD5(string)\n    }\n    if (!raw) {\n      return hexHMACMD5(key, string)\n    }\n    return rawHMACMD5(key, string)\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return md5\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(this)\n\n\n//# sourceURL=webpack:///./node_modules/blueimp-md5/js/md5.js?");

/***/ }),

/***/ "./node_modules/bowser/es5.js":
/*!************************************!*\
  !*** ./node_modules/bowser/es5.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(e,t){ true?module.exports=t():undefined}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=90)}({17:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||\"\"},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||\"\"},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case\"NT\":return\"NT\";case\"XP\":return\"XP\";case\"NT 5.0\":return\"2000\";case\"NT 5.1\":return\"XP\";case\"NT 5.2\":return\"2003\";case\"NT 6.0\":return\"Vista\";case\"NT 6.1\":return\"7\";case\"NT 6.2\":return\"8\";case\"NT 6.3\":return\"8.1\";case\"NT 10.0\":return\"10\";default:return}},e.getMacOSVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return\"Leopard\";case 6:return\"Snow Leopard\";case 7:return\"Lion\";case 8:return\"Mountain Lion\";case 9:return\"Mavericks\";case 10:return\"Yosemite\";case 11:return\"El Capitan\";case 12:return\"Sierra\";case 13:return\"High Sierra\";case 14:return\"Mojave\";case 15:return\"Catalina\";default:return}},e.getAndroidVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?\"Cupcake\":1===t[0]&&t[1]>=6?\"Donut\":2===t[0]&&t[1]<2?\"Eclair\":2===t[0]&&2===t[1]?\"Froyo\":2===t[0]&&t[1]>2?\"Gingerbread\":3===t[0]?\"Honeycomb\":4===t[0]&&t[1]<1?\"Ice Cream Sandwich\":4===t[0]&&t[1]<4?\"Jelly Bean\":4===t[0]&&t[1]>=4?\"KitKat\":5===t[0]?\"Lollipop\":6===t[0]?\"Marshmallow\":7===t[0]?\"Nougat\":8===t[0]?\"Oreo\":9===t[0]?\"Pie\":void 0},e.getVersionPrecision=function(e){return e.split(\".\").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(\".0\");return e.map(n.split(\".\"),(function(e){return new Array(20-e.length).join(\"0\")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];\"object\"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||\"\"},e}();t.default=i,e.exports=t.default},18:function(e,t,r){\"use strict\";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={\"Amazon Silk\":\"amazon_silk\",\"Android Browser\":\"android\",Bada:\"bada\",BlackBerry:\"blackberry\",Chrome:\"chrome\",Chromium:\"chromium\",Electron:\"electron\",Epiphany:\"epiphany\",Firefox:\"firefox\",Focus:\"focus\",Generic:\"generic\",\"Google Search\":\"google_search\",Googlebot:\"googlebot\",\"Internet Explorer\":\"ie\",\"K-Meleon\":\"k_meleon\",Maxthon:\"maxthon\",\"Microsoft Edge\":\"edge\",\"MZ Browser\":\"mz\",\"NAVER Whale Browser\":\"naver\",Opera:\"opera\",\"Opera Coast\":\"opera_coast\",PhantomJS:\"phantomjs\",Puffin:\"puffin\",QupZilla:\"qupzilla\",QQ:\"qq\",QQLite:\"qqlite\",Safari:\"safari\",Sailfish:\"sailfish\",\"Samsung Internet for Android\":\"samsung_internet\",SeaMonkey:\"seamonkey\",Sleipnir:\"sleipnir\",Swing:\"swing\",Tizen:\"tizen\",\"UC Browser\":\"uc\",Vivaldi:\"vivaldi\",\"WebOS Browser\":\"webos\",WeChat:\"wechat\",\"Yandex Browser\":\"yandex\",Roku:\"roku\"};t.BROWSER_MAP={amazon_silk:\"Amazon Silk\",android:\"Android Browser\",bada:\"Bada\",blackberry:\"BlackBerry\",chrome:\"Chrome\",chromium:\"Chromium\",electron:\"Electron\",epiphany:\"Epiphany\",firefox:\"Firefox\",focus:\"Focus\",generic:\"Generic\",googlebot:\"Googlebot\",google_search:\"Google Search\",ie:\"Internet Explorer\",k_meleon:\"K-Meleon\",maxthon:\"Maxthon\",edge:\"Microsoft Edge\",mz:\"MZ Browser\",naver:\"NAVER Whale Browser\",opera:\"Opera\",opera_coast:\"Opera Coast\",phantomjs:\"PhantomJS\",puffin:\"Puffin\",qupzilla:\"QupZilla\",qq:\"QQ Browser\",qqlite:\"QQ Browser Lite\",safari:\"Safari\",sailfish:\"Sailfish\",samsung_internet:\"Samsung Internet for Android\",seamonkey:\"SeaMonkey\",sleipnir:\"Sleipnir\",swing:\"Swing\",tizen:\"Tizen\",uc:\"UC Browser\",vivaldi:\"Vivaldi\",webos:\"WebOS Browser\",wechat:\"WeChat\",yandex:\"Yandex Browser\"};t.PLATFORMS_MAP={tablet:\"tablet\",mobile:\"mobile\",desktop:\"desktop\",tv:\"tv\"};t.OS_MAP={WindowsPhone:\"Windows Phone\",Windows:\"Windows\",MacOS:\"macOS\",iOS:\"iOS\",Android:\"Android\",WebOS:\"WebOS\",BlackBerry:\"BlackBerry\",Bada:\"Bada\",Tizen:\"Tizen\",Linux:\"Linux\",ChromeOS:\"Chrome OS\",PlayStation4:\"PlayStation 4\",Roku:\"Roku\"};t.ENGINE_MAP={EdgeHTML:\"EdgeHTML\",Blink:\"Blink\",Trident:\"Trident\",Presto:\"Presto\",Gecko:\"Gecko\",WebKit:\"WebKit\"}},90:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),\"string\"!=typeof e)throw new Error(\"UserAgent should be a string\");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:\"BROWSER_MAP\",get:function(){return s.BROWSER_MAP}},{key:\"ENGINE_MAP\",get:function(){return s.ENGINE_MAP}},{key:\"OS_MAP\",get:function(){return s.OS_MAP}},{key:\"PLATFORMS_MAP\",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||\"\"===e)throw new Error(\"UserAgent parameter can't be empty\");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||\"\":this.getBrowser().name||\"\"},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||\"\":t||\"\"},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||\"\":t||\"\"},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||\"\":this.getEngine().name||\"\"},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];\"string\"==typeof a?(i[t]=a,s+=1):\"object\"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if(\"string\"==typeof i)return\">\"===e[0]||\"<\"===e[0]?(r=e.substr(1),\"=\"===e[1]?(n=!0,r=e.substr(2)):t=[],\">\"===e[0]?t.push(1):t.push(-1)):\"=\"===e[0]?r=e.substr(1):\"~\"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\\/(\\d+(\\.?_?\\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:\"Googlebot\"},r=i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\\/|opios/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:\"Samsung Internet for Android\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:\"NAVER Whale Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:\"MZ Browser\"},r=i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:\"Focus\"},r=i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:\"Swing\"},r=i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:\"Opera Coast\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\\/\\d+(?:.?_?\\d+)+/i],describe:function(e){var t={name:\"Opera Touch\"},r=i.default.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:\"Yandex Browser\"},r=i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:\"UC Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:\"Maxthon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:\"Epiphany\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:\"Puffin\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:\"Sleipnir\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:\"K-Meleon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:\"WeChat\"},r=i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?\"QQ Browser Lite\":\"QQ Browser\"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:\"Internet Explorer\"},r=i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\\sedg\\//i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:\"Vivaldi\"},r=i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:\"SeaMonkey\"},r=i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:\"Sailfish\"},r=i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:\"Amazon Silk\"},r=i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:\"PhantomJS\"},r=i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:\"SlimerJS\"},r=i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t={name:\"BlackBerry\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:\"WebOS Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:\"Bada\"},r=i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:\"Tizen\"},r=i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:\"QupZilla\"},r=i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:\"Firefox\"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:\"Electron\"},r=i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:\"Miui\"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:\"Chromium\"},r=i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:\"Chrome\"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:\"Google Search\"},r=i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:\"Android Browser\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:\"PlayStation 4\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:\"Safari\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search(\"\\\\(\")?/^(.*)\\/(.*)[ \\t]\\((.*)/:/^(.*)\\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i,e).replace(/[_\\s]/g,\".\"),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i,e).replace(/[_\\s]/g,\".\");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i,e)||i.default.getFirstMatch(/\\bbb(\\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:\"bot\",vendor:\"Google\"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&\"Nova\",r={type:s.PLATFORMS_MAP.mobile,vendor:\"Huawei\"};return t&&(r.model=t),r}},{test:[/nexus\\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Nexus\"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\",model:\"Kindle Fire HD 7\"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:\"Apple\",model:t}}},{test:[/nexus\\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Nexus\"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"blackberry\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"BlackBerry\"}}},{test:function(e){return\"bada\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"windows phone\"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Microsoft\"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(\".\")[0]);return\"android\"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return\"android\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"macos\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:\"Apple\"}}},{test:function(e){return\"windows\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"linux\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"playstation 4\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return\"roku\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return\"microsoft edge\"===e.getBrowserName(!0)},describe:function(e){if(/\\sedg\\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\\/537\\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));\n\n//# sourceURL=webpack:///./node_modules/bowser/es5.js?");

/***/ }),

/***/ "./node_modules/crypto-js/aes.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/aes.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Lookup tables\n\t    var SBOX = [];\n\t    var INV_SBOX = [];\n\t    var SUB_MIX_0 = [];\n\t    var SUB_MIX_1 = [];\n\t    var SUB_MIX_2 = [];\n\t    var SUB_MIX_3 = [];\n\t    var INV_SUB_MIX_0 = [];\n\t    var INV_SUB_MIX_1 = [];\n\t    var INV_SUB_MIX_2 = [];\n\t    var INV_SUB_MIX_3 = [];\n\n\t    // Compute lookup tables\n\t    (function () {\n\t        // Compute double table\n\t        var d = [];\n\t        for (var i = 0; i < 256; i++) {\n\t            if (i < 128) {\n\t                d[i] = i << 1;\n\t            } else {\n\t                d[i] = (i << 1) ^ 0x11b;\n\t            }\n\t        }\n\n\t        // Walk GF(2^8)\n\t        var x = 0;\n\t        var xi = 0;\n\t        for (var i = 0; i < 256; i++) {\n\t            // Compute sbox\n\t            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n\t            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n\t            SBOX[x] = sx;\n\t            INV_SBOX[sx] = x;\n\n\t            // Compute multiplication\n\t            var x2 = d[x];\n\t            var x4 = d[x2];\n\t            var x8 = d[x4];\n\n\t            // Compute sub bytes, mix columns tables\n\t            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n\t            SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n\t            SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n\t            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n\t            SUB_MIX_3[x] = t;\n\n\t            // Compute inv sub bytes, inv mix columns tables\n\t            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n\t            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n\t            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n\t            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n\t            INV_SUB_MIX_3[sx] = t;\n\n\t            // Compute next counter\n\t            if (!x) {\n\t                x = xi = 1;\n\t            } else {\n\t                x = x2 ^ d[d[d[x8 ^ x2]]];\n\t                xi ^= d[d[xi]];\n\t            }\n\t        }\n\t    }());\n\n\t    // Precomputed Rcon lookup\n\t    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n\t    /**\n\t     * AES block cipher algorithm.\n\t     */\n\t    var AES = C_algo.AES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            var t;\n\n\t            // Skip reset of nRounds has been set before and key did not change\n\t            if (this._nRounds && this._keyPriorReset === this._key) {\n\t                return;\n\t            }\n\n\t            // Shortcuts\n\t            var key = this._keyPriorReset = this._key;\n\t            var keyWords = key.words;\n\t            var keySize = key.sigBytes / 4;\n\n\t            // Compute number of rounds\n\t            var nRounds = this._nRounds = keySize + 6;\n\n\t            // Compute number of key schedule rows\n\t            var ksRows = (nRounds + 1) * 4;\n\n\t            // Compute key schedule\n\t            var keySchedule = this._keySchedule = [];\n\t            for (var ksRow = 0; ksRow < ksRows; ksRow++) {\n\t                if (ksRow < keySize) {\n\t                    keySchedule[ksRow] = keyWords[ksRow];\n\t                } else {\n\t                    t = keySchedule[ksRow - 1];\n\n\t                    if (!(ksRow % keySize)) {\n\t                        // Rot word\n\t                        t = (t << 8) | (t >>> 24);\n\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n\t                        // Mix Rcon\n\t                        t ^= RCON[(ksRow / keySize) | 0] << 24;\n\t                    } else if (keySize > 6 && ksRow % keySize == 4) {\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\t                    }\n\n\t                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n\t                }\n\t            }\n\n\t            // Compute inv key schedule\n\t            var invKeySchedule = this._invKeySchedule = [];\n\t            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n\t                var ksRow = ksRows - invKsRow;\n\n\t                if (invKsRow % 4) {\n\t                    var t = keySchedule[ksRow];\n\t                } else {\n\t                    var t = keySchedule[ksRow - 4];\n\t                }\n\n\t                if (invKsRow < 4 || ksRow <= 4) {\n\t                    invKeySchedule[invKsRow] = t;\n\t                } else {\n\t                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n\t                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n\t                }\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            // Swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\n\t            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n\t            // Inv swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\t        },\n\n\t        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n\t            // Shortcut\n\t            var nRounds = this._nRounds;\n\n\t            // Get input, add round key\n\t            var s0 = M[offset]     ^ keySchedule[0];\n\t            var s1 = M[offset + 1] ^ keySchedule[1];\n\t            var s2 = M[offset + 2] ^ keySchedule[2];\n\t            var s3 = M[offset + 3] ^ keySchedule[3];\n\n\t            // Key schedule row counter\n\t            var ksRow = 4;\n\n\t            // Rounds\n\t            for (var round = 1; round < nRounds; round++) {\n\t                // Shift rows, sub bytes, mix columns, add round key\n\t                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];\n\t                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];\n\t                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];\n\t                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];\n\n\t                // Update state\n\t                s0 = t0;\n\t                s1 = t1;\n\t                s2 = t2;\n\t                s3 = t3;\n\t            }\n\n\t            // Shift rows, sub bytes, add round key\n\t            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n\n\t            // Set output\n\t            M[offset]     = t0;\n\t            M[offset + 1] = t1;\n\t            M[offset + 2] = t2;\n\t            M[offset + 3] = t3;\n\t        },\n\n\t        keySize: 256/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.AES = BlockCipher._createHelper(AES);\n\t}());\n\n\n\treturn CryptoJS.AES;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/aes.js?");

/***/ }),

/***/ "./node_modules/crypto-js/cipher-core.js":
/*!***********************************************!*\
  !*** ./node_modules/crypto-js/cipher-core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher core components.\n\t */\n\tCryptoJS.lib.Cipher || (function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var Base64 = C_enc.Base64;\n\t    var C_algo = C.algo;\n\t    var EvpKDF = C_algo.EvpKDF;\n\n\t    /**\n\t     * Abstract base cipher template.\n\t     *\n\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n\t     */\n\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {WordArray} iv The IV to use for this operation.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Creates this cipher in encryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createEncryptor: function (key, cfg) {\n\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Creates this cipher in decryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createDecryptor: function (key, cfg) {\n\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created cipher.\n\t         *\n\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n\t         */\n\t        init: function (xformMode, key, cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Store transform mode and key\n\t            this._xformMode = xformMode;\n\t            this._key = key;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this cipher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     cipher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-cipher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Adds data to be encrypted or decrypted.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.process('data');\n\t         *     var encrypted = cipher.process(wordArray);\n\t         */\n\t        process: function (dataUpdate) {\n\t            // Append\n\t            this._append(dataUpdate);\n\n\t            // Process available blocks\n\t            return this._process();\n\t        },\n\n\t        /**\n\t         * Finalizes the encryption or decryption process.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after final processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.finalize();\n\t         *     var encrypted = cipher.finalize('data');\n\t         *     var encrypted = cipher.finalize(wordArray);\n\t         */\n\t        finalize: function (dataUpdate) {\n\t            // Final data update\n\t            if (dataUpdate) {\n\t                this._append(dataUpdate);\n\t            }\n\n\t            // Perform concrete-cipher logic\n\t            var finalProcessedData = this._doFinalize();\n\n\t            return finalProcessedData;\n\t        },\n\n\t        keySize: 128/32,\n\n\t        ivSize: 128/32,\n\n\t        _ENC_XFORM_MODE: 1,\n\n\t        _DEC_XFORM_MODE: 2,\n\n\t        /**\n\t         * Creates shortcut functions to a cipher's object interface.\n\t         *\n\t         * @param {Cipher} cipher The cipher to create a helper for.\n\t         *\n\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n\t         */\n\t        _createHelper: (function () {\n\t            function selectCipherStrategy(key) {\n\t                if (typeof key == 'string') {\n\t                    return PasswordBasedCipher;\n\t                } else {\n\t                    return SerializableCipher;\n\t                }\n\t            }\n\n\t            return function (cipher) {\n\t                return {\n\t                    encrypt: function (message, key, cfg) {\n\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t                    },\n\n\t                    decrypt: function (ciphertext, key, cfg) {\n\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t                    }\n\t                };\n\t            };\n\t        }())\n\t    });\n\n\t    /**\n\t     * Abstract base stream cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n\t     */\n\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t        _doFinalize: function () {\n\t            // Process partial blocks\n\t            var finalProcessedBlocks = this._process(!!'flush');\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 1\n\t    });\n\n\t    /**\n\t     * Mode namespace.\n\t     */\n\t    var C_mode = C.mode = {};\n\n\t    /**\n\t     * Abstract base block cipher mode template.\n\t     */\n\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t        /**\n\t         * Creates this mode for encryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n\t         */\n\t        createEncryptor: function (cipher, iv) {\n\t            return this.Encryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Creates this mode for decryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n\t         */\n\t        createDecryptor: function (cipher, iv) {\n\t            return this.Decryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created mode.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n\t         */\n\t        init: function (cipher, iv) {\n\t            this._cipher = cipher;\n\t            this._iv = iv;\n\t        }\n\t    });\n\n\t    /**\n\t     * Cipher Block Chaining mode.\n\t     */\n\t    var CBC = C_mode.CBC = (function () {\n\t        /**\n\t         * Abstract base CBC mode.\n\t         */\n\t        var CBC = BlockCipherMode.extend();\n\n\t        /**\n\t         * CBC encryptor.\n\t         */\n\t        CBC.Encryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // XOR and encrypt\n\t                xorBlock.call(this, words, offset, blockSize);\n\t                cipher.encryptBlock(words, offset);\n\n\t                // Remember this block to use with next block\n\t                this._prevBlock = words.slice(offset, offset + blockSize);\n\t            }\n\t        });\n\n\t        /**\n\t         * CBC decryptor.\n\t         */\n\t        CBC.Decryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // Remember this block to use with next block\n\t                var thisBlock = words.slice(offset, offset + blockSize);\n\n\t                // Decrypt and XOR\n\t                cipher.decryptBlock(words, offset);\n\t                xorBlock.call(this, words, offset, blockSize);\n\n\t                // This block becomes the previous block\n\t                this._prevBlock = thisBlock;\n\t            }\n\t        });\n\n\t        function xorBlock(words, offset, blockSize) {\n\t            var block;\n\n\t            // Shortcut\n\t            var iv = this._iv;\n\n\t            // Choose mixing block\n\t            if (iv) {\n\t                block = iv;\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            } else {\n\t                block = this._prevBlock;\n\t            }\n\n\t            // XOR blocks\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= block[i];\n\t            }\n\t        }\n\n\t        return CBC;\n\t    }());\n\n\t    /**\n\t     * Padding namespace.\n\t     */\n\t    var C_pad = C.pad = {};\n\n\t    /**\n\t     * PKCS #5/7 padding strategy.\n\t     */\n\t    var Pkcs7 = C_pad.Pkcs7 = {\n\t        /**\n\t         * Pads data using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to pad.\n\t         * @param {number} blockSize The multiple that the data should be padded to.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n\t         */\n\t        pad: function (data, blockSize) {\n\t            // Shortcut\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count padding bytes\n\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t            // Create padding word\n\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n\t            // Create padding\n\t            var paddingWords = [];\n\t            for (var i = 0; i < nPaddingBytes; i += 4) {\n\t                paddingWords.push(paddingWord);\n\t            }\n\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t            // Add padding\n\t            data.concat(padding);\n\t        },\n\n\t        /**\n\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to unpad.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n\t         */\n\t        unpad: function (data) {\n\t            // Get number of padding bytes from last byte\n\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t            // Remove padding\n\t            data.sigBytes -= nPaddingBytes;\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract base block cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n\t     */\n\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Mode} mode The block mode to use. Default: CBC\n\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n\t         */\n\t        cfg: Cipher.cfg.extend({\n\t            mode: CBC,\n\t            padding: Pkcs7\n\t        }),\n\n\t        reset: function () {\n\t            var modeCreator;\n\n\t            // Reset cipher\n\t            Cipher.reset.call(this);\n\n\t            // Shortcuts\n\t            var cfg = this.cfg;\n\t            var iv = cfg.iv;\n\t            var mode = cfg.mode;\n\n\t            // Reset block mode\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                modeCreator = mode.createEncryptor;\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                modeCreator = mode.createDecryptor;\n\t                // Keep at least one block in the buffer for unpadding\n\t                this._minBufferSize = 1;\n\t            }\n\n\t            if (this._mode && this._mode.__creator == modeCreator) {\n\t                this._mode.init(this, iv && iv.words);\n\t            } else {\n\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\n\t                this._mode.__creator = modeCreator;\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (words, offset) {\n\t            this._mode.processBlock(words, offset);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var finalProcessedBlocks;\n\n\t            // Shortcut\n\t            var padding = this.cfg.padding;\n\n\t            // Finalize\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                // Pad data\n\t                padding.pad(this._data, this.blockSize);\n\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\n\t                // Unpad data\n\t                padding.unpad(finalProcessedBlocks);\n\t            }\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 128/32\n\t    });\n\n\t    /**\n\t     * A collection of cipher parameters.\n\t     *\n\t     * @property {WordArray} ciphertext The raw ciphertext.\n\t     * @property {WordArray} key The key to this ciphertext.\n\t     * @property {WordArray} iv The IV used in the ciphering operation.\n\t     * @property {WordArray} salt The salt used with a key derivation function.\n\t     * @property {Cipher} algorithm The cipher algorithm.\n\t     * @property {Mode} mode The block mode used in the ciphering operation.\n\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\n\t     * @property {number} blockSize The block size of the cipher.\n\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n\t     */\n\t    var CipherParams = C_lib.CipherParams = Base.extend({\n\t        /**\n\t         * Initializes a newly created cipher params object.\n\t         *\n\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\n\t         *         ciphertext: ciphertextWordArray,\n\t         *         key: keyWordArray,\n\t         *         iv: ivWordArray,\n\t         *         salt: saltWordArray,\n\t         *         algorithm: CryptoJS.algo.AES,\n\t         *         mode: CryptoJS.mode.CBC,\n\t         *         padding: CryptoJS.pad.PKCS7,\n\t         *         blockSize: 4,\n\t         *         formatter: CryptoJS.format.OpenSSL\n\t         *     });\n\t         */\n\t        init: function (cipherParams) {\n\t            this.mixIn(cipherParams);\n\t        },\n\n\t        /**\n\t         * Converts this cipher params object to a string.\n\t         *\n\t         * @param {Format} formatter (Optional) The formatting strategy to use.\n\t         *\n\t         * @return {string} The stringified cipher params.\n\t         *\n\t         * @throws Error If neither the formatter nor the default formatter is set.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = cipherParams + '';\n\t         *     var string = cipherParams.toString();\n\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n\t         */\n\t        toString: function (formatter) {\n\t            return (formatter || this.formatter).stringify(this);\n\t        }\n\t    });\n\n\t    /**\n\t     * Format namespace.\n\t     */\n\t    var C_format = C.format = {};\n\n\t    /**\n\t     * OpenSSL formatting strategy.\n\t     */\n\t    var OpenSSLFormatter = C_format.OpenSSL = {\n\t        /**\n\t         * Converts a cipher params object to an OpenSSL-compatible string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The OpenSSL-compatible string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            var wordArray;\n\n\t            // Shortcuts\n\t            var ciphertext = cipherParams.ciphertext;\n\t            var salt = cipherParams.salt;\n\n\t            // Format\n\t            if (salt) {\n\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t            } else {\n\t                wordArray = ciphertext;\n\t            }\n\n\t            return wordArray.toString(Base64);\n\t        },\n\n\t        /**\n\t         * Converts an OpenSSL-compatible string to a cipher params object.\n\t         *\n\t         * @param {string} openSSLStr The OpenSSL-compatible string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n\t         */\n\t        parse: function (openSSLStr) {\n\t            var salt;\n\n\t            // Parse base64\n\t            var ciphertext = Base64.parse(openSSLStr);\n\n\t            // Shortcut\n\t            var ciphertextWords = ciphertext.words;\n\n\t            // Test for salt\n\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t                // Extract salt\n\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t                // Remove salt from ciphertext\n\t                ciphertextWords.splice(0, 4);\n\t                ciphertext.sigBytes -= 16;\n\t            }\n\n\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n\t         */\n\t        cfg: Base.extend({\n\t            format: OpenSSLFormatter\n\t        }),\n\n\t        /**\n\t         * Encrypts a message.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Encrypt\n\t            var encryptor = cipher.createEncryptor(key, cfg);\n\t            var ciphertext = encryptor.finalize(message);\n\n\t            // Shortcut\n\t            var cipherCfg = encryptor.cfg;\n\n\t            // Create and return serializable cipher params\n\t            return CipherParams.create({\n\t                ciphertext: ciphertext,\n\t                key: key,\n\t                iv: cipherCfg.iv,\n\t                algorithm: cipher,\n\t                mode: cipherCfg.mode,\n\t                padding: cipherCfg.padding,\n\t                blockSize: cipher.blockSize,\n\t                formatter: cfg.format\n\t            });\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Decrypt\n\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t            return plaintext;\n\t        },\n\n\t        /**\n\t         * Converts serialized ciphertext to CipherParams,\n\t         * else assumed CipherParams already and returns ciphertext unchanged.\n\t         *\n\t         * @param {CipherParams|string} ciphertext The ciphertext.\n\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n\t         *\n\t         * @return {CipherParams} The unserialized ciphertext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n\t         */\n\t        _parse: function (ciphertext, format) {\n\t            if (typeof ciphertext == 'string') {\n\t                return format.parse(ciphertext, this);\n\t            } else {\n\t                return ciphertext;\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Key derivation function namespace.\n\t     */\n\t    var C_kdf = C.kdf = {};\n\n\t    /**\n\t     * OpenSSL key derivation function.\n\t     */\n\t    var OpenSSLKdf = C_kdf.OpenSSL = {\n\t        /**\n\t         * Derives a key and IV from a password.\n\t         *\n\t         * @param {string} password The password to derive from.\n\t         * @param {number} keySize The size in words of the key to generate.\n\t         * @param {number} ivSize The size in words of the IV to generate.\n\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n\t         *\n\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n\t         */\n\t        execute: function (password, keySize, ivSize, salt) {\n\t            // Generate random salt\n\t            if (!salt) {\n\t                salt = WordArray.random(64/8);\n\t            }\n\n\t            // Derive key and IV\n\t            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\n\t            // Separate key and IV\n\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t            key.sigBytes = keySize * 4;\n\n\t            // Return params\n\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A serializable cipher wrapper that derives the key from a password,\n\t     * and returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n\t         */\n\t        cfg: SerializableCipher.cfg.extend({\n\t            kdf: OpenSSLKdf\n\t        }),\n\n\t        /**\n\t         * Encrypts a message using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Encrypt\n\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t            // Mix in derived params\n\t            ciphertext.mixIn(derivedParams);\n\n\t            return ciphertext;\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Decrypt\n\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t            return plaintext;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/cipher-core.js?");

/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse {}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native crypto in web worker (Browser)\n\t    if (typeof self !== 'undefined' && self.crypto) {\n\t        crypto = self.crypto;\n\t    }\n\n\t    // Native crypto from worker\n\t    if (typeof globalThis !== 'undefined' && globalThis.crypto) {\n\t        crypto = globalThis.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n\t        crypto = global.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && \"function\" === 'function') {\n\t        try {\n\t            crypto = __webpack_require__(/*! crypto */ 0);\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }());\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var j = 0; j < thatSigBytes; j += 4) {\n\t                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/crypto-js/core.js?");

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/enc-base64.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64 encoding strategy.\n\t     */\n\t    var Base64 = C_enc.Base64 = {\n\t        /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */\n\t        parse: function (base64Str) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                    reverseMap = this._reverseMap = [];\n\t                    for (var j = 0; j < map.length; j++) {\n\t                        reverseMap[map.charCodeAt(j)] = j;\n\t                    }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t      var words = [];\n\t      var nBytes = 0;\n\t      for (var i = 0; i < base64StrLength; i++) {\n\t          if (i % 4) {\n\t              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t              var bitsCombined = bits1 | bits2;\n\t              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t              nBytes++;\n\t          }\n\t      }\n\t      return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/enc-base64.js?");

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64url.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/enc-base64url.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64url encoding strategy.\n\t     */\n\t    var Base64url = C_enc.Base64url = {\n\t        /**\n\t         * Converts a word array to a Base64url string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @param {boolean} urlSafe Whether to use url safe\n\t         *\n\t         * @return {string} The Base64url string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray, urlSafe=true) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = urlSafe ? this._safe_map : this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64url string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64url string.\n\t         *\n\t         * @param {boolean} urlSafe Whether to use url safe\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);\n\t         */\n\t        parse: function (base64Str, urlSafe=true) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = urlSafe ? this._safe_map : this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                reverseMap = this._reverseMap = [];\n\t                for (var j = 0; j < map.length; j++) {\n\t                    reverseMap[map.charCodeAt(j)] = j;\n\t                }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n\t        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t        var words = [];\n\t        var nBytes = 0;\n\t        for (var i = 0; i < base64StrLength; i++) {\n\t            if (i % 4) {\n\t                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t                var bitsCombined = bits1 | bits2;\n\t                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t                nBytes++;\n\t            }\n\t        }\n\t        return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\treturn CryptoJS.enc.Base64url;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/enc-base64url.js?");

/***/ }),

/***/ "./node_modules/crypto-js/enc-utf16.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/enc-utf16.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * UTF-16 BE encoding strategy.\n\t     */\n\t    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 BE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 BE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 BE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 BE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-16 LE encoding strategy.\n\t     */\n\t    C_enc.Utf16LE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 LE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 LE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 LE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 LE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    function swapEndian(word) {\n\t        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Utf16;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/enc-utf16.js?");

/***/ }),

/***/ "./node_modules/crypto-js/evpkdf.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/evpkdf.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha1 */ \"./node_modules/crypto-js/sha1.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var MD5 = C_algo.MD5;\n\n\t    /**\n\t     * This key derivation function is meant to conform with EVP_BytesToKey.\n\t     * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n\t     */\n\t    var EvpKDF = C_algo.EvpKDF = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: MD5,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create();\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Derives a key from a password.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            var block;\n\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init hasher\n\t            var hasher = cfg.hasher.create();\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                if (block) {\n\t                    hasher.update(block);\n\t                }\n\t                block = hasher.update(password).finalize(salt);\n\t                hasher.reset();\n\n\t                // Iterations\n\t                for (var i = 1; i < iterations; i++) {\n\t                    block = hasher.finalize(block);\n\t                    hasher.reset();\n\t                }\n\n\t                derivedKey.concat(block);\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Derives a key from a password.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.EvpKDF(password, salt);\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.EvpKDF = function (password, salt, cfg) {\n\t        return EvpKDF.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.EvpKDF;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/evpkdf.js?");

/***/ }),

/***/ "./node_modules/crypto-js/format-hex.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/format-hex.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var CipherParams = C_lib.CipherParams;\n\t    var C_enc = C.enc;\n\t    var Hex = C_enc.Hex;\n\t    var C_format = C.format;\n\n\t    var HexFormatter = C_format.Hex = {\n\t        /**\n\t         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The hexadecimally encoded string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            return cipherParams.ciphertext.toString(Hex);\n\t        },\n\n\t        /**\n\t         * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n\t         *\n\t         * @param {string} input The hexadecimally encoded string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n\t         */\n\t        parse: function (input) {\n\t            var ciphertext = Hex.parse(input);\n\t            return CipherParams.create({ ciphertext: ciphertext });\n\t        }\n\t    };\n\t}());\n\n\n\treturn CryptoJS.format.Hex;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/format-hex.js?");

/***/ }),

/***/ "./node_modules/crypto-js/hmac.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/hmac.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * HMAC algorithm.\n\t     */\n\t    var HMAC = C_algo.HMAC = Base.extend({\n\t        /**\n\t         * Initializes a newly created HMAC.\n\t         *\n\t         * @param {Hasher} hasher The hash algorithm to use.\n\t         * @param {WordArray|string} key The secret key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n\t         */\n\t        init: function (hasher, key) {\n\t            // Init hasher\n\t            hasher = this._hasher = new hasher.init();\n\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof key == 'string') {\n\t                key = Utf8.parse(key);\n\t            }\n\n\t            // Shortcuts\n\t            var hasherBlockSize = hasher.blockSize;\n\t            var hasherBlockSizeBytes = hasherBlockSize * 4;\n\n\t            // Allow arbitrary length keys\n\t            if (key.sigBytes > hasherBlockSizeBytes) {\n\t                key = hasher.finalize(key);\n\t            }\n\n\t            // Clamp excess bits\n\t            key.clamp();\n\n\t            // Clone key for inner and outer pads\n\t            var oKey = this._oKey = key.clone();\n\t            var iKey = this._iKey = key.clone();\n\n\t            // Shortcuts\n\t            var oKeyWords = oKey.words;\n\t            var iKeyWords = iKey.words;\n\n\t            // XOR keys with pad constants\n\t            for (var i = 0; i < hasherBlockSize; i++) {\n\t                oKeyWords[i] ^= 0x5c5c5c5c;\n\t                iKeyWords[i] ^= 0x36363636;\n\t            }\n\t            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this HMAC to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Reset\n\t            hasher.reset();\n\t            hasher.update(this._iKey);\n\t        },\n\n\t        /**\n\t         * Updates this HMAC with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {HMAC} This HMAC instance.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.update('message');\n\t         *     hmacHasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            this._hasher.update(messageUpdate);\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the HMAC computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The HMAC.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmac = hmacHasher.finalize();\n\t         *     var hmac = hmacHasher.finalize('message');\n\t         *     var hmac = hmacHasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Compute HMAC\n\t            var innerHash = hasher.finalize(messageUpdate);\n\t            hasher.reset();\n\t            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n\t            return hmac;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/hmac.js?");

/***/ }),

/***/ "./node_modules/crypto-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/crypto-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"), __webpack_require__(/*! ./lib-typedarrays */ \"./node_modules/crypto-js/lib-typedarrays.js\"), __webpack_require__(/*! ./enc-utf16 */ \"./node_modules/crypto-js/enc-utf16.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./enc-base64url */ \"./node_modules/crypto-js/enc-base64url.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./sha1 */ \"./node_modules/crypto-js/sha1.js\"), __webpack_require__(/*! ./sha256 */ \"./node_modules/crypto-js/sha256.js\"), __webpack_require__(/*! ./sha224 */ \"./node_modules/crypto-js/sha224.js\"), __webpack_require__(/*! ./sha512 */ \"./node_modules/crypto-js/sha512.js\"), __webpack_require__(/*! ./sha384 */ \"./node_modules/crypto-js/sha384.js\"), __webpack_require__(/*! ./sha3 */ \"./node_modules/crypto-js/sha3.js\"), __webpack_require__(/*! ./ripemd160 */ \"./node_modules/crypto-js/ripemd160.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"), __webpack_require__(/*! ./pbkdf2 */ \"./node_modules/crypto-js/pbkdf2.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"), __webpack_require__(/*! ./mode-cfb */ \"./node_modules/crypto-js/mode-cfb.js\"), __webpack_require__(/*! ./mode-ctr */ \"./node_modules/crypto-js/mode-ctr.js\"), __webpack_require__(/*! ./mode-ctr-gladman */ \"./node_modules/crypto-js/mode-ctr-gladman.js\"), __webpack_require__(/*! ./mode-ofb */ \"./node_modules/crypto-js/mode-ofb.js\"), __webpack_require__(/*! ./mode-ecb */ \"./node_modules/crypto-js/mode-ecb.js\"), __webpack_require__(/*! ./pad-ansix923 */ \"./node_modules/crypto-js/pad-ansix923.js\"), __webpack_require__(/*! ./pad-iso10126 */ \"./node_modules/crypto-js/pad-iso10126.js\"), __webpack_require__(/*! ./pad-iso97971 */ \"./node_modules/crypto-js/pad-iso97971.js\"), __webpack_require__(/*! ./pad-zeropadding */ \"./node_modules/crypto-js/pad-zeropadding.js\"), __webpack_require__(/*! ./pad-nopadding */ \"./node_modules/crypto-js/pad-nopadding.js\"), __webpack_require__(/*! ./format-hex */ \"./node_modules/crypto-js/format-hex.js\"), __webpack_require__(/*! ./aes */ \"./node_modules/crypto-js/aes.js\"), __webpack_require__(/*! ./tripledes */ \"./node_modules/crypto-js/tripledes.js\"), __webpack_require__(/*! ./rc4 */ \"./node_modules/crypto-js/rc4.js\"), __webpack_require__(/*! ./rabbit */ \"./node_modules/crypto-js/rabbit.js\"), __webpack_require__(/*! ./rabbit-legacy */ \"./node_modules/crypto-js/rabbit-legacy.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/index.js?");

/***/ }),

/***/ "./node_modules/crypto-js/lib-typedarrays.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Check if typed arrays are supported\n\t    if (typeof ArrayBuffer != 'function') {\n\t        return;\n\t    }\n\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\n\t    // Reference original init\n\t    var superInit = WordArray.init;\n\n\t    // Augment WordArray.init to handle typed arrays\n\t    var subInit = WordArray.init = function (typedArray) {\n\t        // Convert buffers to uint8\n\t        if (typedArray instanceof ArrayBuffer) {\n\t            typedArray = new Uint8Array(typedArray);\n\t        }\n\n\t        // Convert other array views to uint8\n\t        if (\n\t            typedArray instanceof Int8Array ||\n\t            (typeof Uint8ClampedArray !== \"undefined\" && typedArray instanceof Uint8ClampedArray) ||\n\t            typedArray instanceof Int16Array ||\n\t            typedArray instanceof Uint16Array ||\n\t            typedArray instanceof Int32Array ||\n\t            typedArray instanceof Uint32Array ||\n\t            typedArray instanceof Float32Array ||\n\t            typedArray instanceof Float64Array\n\t        ) {\n\t            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t        }\n\n\t        // Handle Uint8Array\n\t        if (typedArray instanceof Uint8Array) {\n\t            // Shortcut\n\t            var typedArrayByteLength = typedArray.byteLength;\n\n\t            // Extract bytes\n\t            var words = [];\n\t            for (var i = 0; i < typedArrayByteLength; i++) {\n\t                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n\t            }\n\n\t            // Initialize this word array\n\t            superInit.call(this, words, typedArrayByteLength);\n\t        } else {\n\t            // Else call normal init\n\t            superInit.apply(this, arguments);\n\t        }\n\t    };\n\n\t    subInit.prototype = WordArray;\n\t}());\n\n\n\treturn CryptoJS.lib.WordArray;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/lib-typedarrays.js?");

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var T = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        for (var i = 0; i < 64; i++) {\n\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t        }\n\t    }());\n\n\t    /**\n\t     * MD5 hash algorithm.\n\t     */\n\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var M_offset_0  = M[offset + 0];\n\t            var M_offset_1  = M[offset + 1];\n\t            var M_offset_2  = M[offset + 2];\n\t            var M_offset_3  = M[offset + 3];\n\t            var M_offset_4  = M[offset + 4];\n\t            var M_offset_5  = M[offset + 5];\n\t            var M_offset_6  = M[offset + 6];\n\t            var M_offset_7  = M[offset + 7];\n\t            var M_offset_8  = M[offset + 8];\n\t            var M_offset_9  = M[offset + 9];\n\t            var M_offset_10 = M[offset + 10];\n\t            var M_offset_11 = M[offset + 11];\n\t            var M_offset_12 = M[offset + 12];\n\t            var M_offset_13 = M[offset + 13];\n\t            var M_offset_14 = M[offset + 14];\n\t            var M_offset_15 = M[offset + 15];\n\n\t            // Working varialbes\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\n\t            // Computation\n\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t            var nBitsTotalL = nBitsTotal;\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t            );\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t            );\n\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    function FF(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function GG(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function HH(a, b, c, d, x, s, t) {\n\t        var n = a + (b ^ c ^ d) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function II(a, b, c, d, x, s, t) {\n\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.MD5('message');\n\t     *     var hash = CryptoJS.MD5(wordArray);\n\t     */\n\t    C.MD5 = Hasher._createHelper(MD5);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t     */\n\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t}(Math));\n\n\n\treturn CryptoJS.MD5;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/md5.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-cfb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-cfb.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher Feedback block mode.\n\t */\n\tCryptoJS.mode.CFB = (function () {\n\t    var CFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    CFB.Encryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // Remember this block to use with next block\n\t            this._prevBlock = words.slice(offset, offset + blockSize);\n\t        }\n\t    });\n\n\t    CFB.Decryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            // Remember this block to use with next block\n\t            var thisBlock = words.slice(offset, offset + blockSize);\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // This block becomes the previous block\n\t            this._prevBlock = thisBlock;\n\t        }\n\t    });\n\n\t    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n\t        var keystream;\n\n\t        // Shortcut\n\t        var iv = this._iv;\n\n\t        // Generate keystream\n\t        if (iv) {\n\t            keystream = iv.slice(0);\n\n\t            // Remove IV for subsequent blocks\n\t            this._iv = undefined;\n\t        } else {\n\t            keystream = this._prevBlock;\n\t        }\n\t        cipher.encryptBlock(keystream, 0);\n\n\t        // Encrypt\n\t        for (var i = 0; i < blockSize; i++) {\n\t            words[offset + i] ^= keystream[i];\n\t        }\n\t    }\n\n\t    return CFB;\n\t}());\n\n\n\treturn CryptoJS.mode.CFB;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/mode-cfb.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr-gladman.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr-gladman.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n\t * derived from CryptoJS.mode.CTR\n\t * Jan Hruby jhruby.web@gmail.com\n\t */\n\tCryptoJS.mode.CTRGladman = (function () {\n\t    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tfunction incWord(word)\n\t\t{\n\t\t\tif (((word >> 24) & 0xff) === 0xff) { //overflow\n\t\t\tvar b1 = (word >> 16)&0xff;\n\t\t\tvar b2 = (word >> 8)&0xff;\n\t\t\tvar b3 = word & 0xff;\n\n\t\t\tif (b1 === 0xff) // overflow b1\n\t\t\t{\n\t\t\tb1 = 0;\n\t\t\tif (b2 === 0xff)\n\t\t\t{\n\t\t\t\tb2 = 0;\n\t\t\t\tif (b3 === 0xff)\n\t\t\t\t{\n\t\t\t\t\tb3 = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++b3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++b2;\n\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t++b1;\n\t\t\t}\n\n\t\t\tword = 0;\n\t\t\tword += (b1 << 16);\n\t\t\tword += (b2 << 8);\n\t\t\tword += b3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tword += (0x01 << 24);\n\t\t\t}\n\t\t\treturn word;\n\t\t}\n\n\t\tfunction incCounter(counter)\n\t\t{\n\t\t\tif ((counter[0] = incWord(counter[0])) === 0)\n\t\t\t{\n\t\t\t\t// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n\t\t\t\tcounter[1] = incWord(counter[1]);\n\t\t\t}\n\t\t\treturn counter;\n\t\t}\n\n\t    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\n\t\t\t\tincCounter(counter);\n\n\t\t\t\tvar keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTRGladman.Decryptor = Encryptor;\n\n\t    return CTRGladman;\n\t}());\n\n\n\n\n\treturn CryptoJS.mode.CTRGladman;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/mode-ctr-gladman.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Counter block mode.\n\t */\n\tCryptoJS.mode.CTR = (function () {\n\t    var CTR = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = CTR.Encryptor = CTR.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            var keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Increment counter\n\t            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTR.Decryptor = Encryptor;\n\n\t    return CTR;\n\t}());\n\n\n\treturn CryptoJS.mode.CTR;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/mode-ctr.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ecb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ecb.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Electronic Codebook block mode.\n\t */\n\tCryptoJS.mode.ECB = (function () {\n\t    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    ECB.Encryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.encryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    ECB.Decryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.decryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    return ECB;\n\t}());\n\n\n\treturn CryptoJS.mode.ECB;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/mode-ecb.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ofb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ofb.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Output Feedback block mode.\n\t */\n\tCryptoJS.mode.OFB = (function () {\n\t    var OFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = OFB.Encryptor = OFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var keystream = this._keystream;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                keystream = this._keystream = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    OFB.Decryptor = Encryptor;\n\n\t    return OFB;\n\t}());\n\n\n\treturn CryptoJS.mode.OFB;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/mode-ofb.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-ansix923.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-ansix923.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ANSI X.923 padding strategy.\n\t */\n\tCryptoJS.pad.AnsiX923 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcuts\n\t        var dataSigBytes = data.sigBytes;\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;\n\n\t        // Compute last byte position\n\t        var lastBytePos = dataSigBytes + nPaddingBytes - 1;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);\n\t        data.sigBytes += nPaddingBytes;\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Ansix923;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/pad-ansix923.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso10126.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso10126.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO 10126 padding strategy.\n\t */\n\tCryptoJS.pad.Iso10126 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t        // Pad\n\t        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).\n\t             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso10126;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/pad-iso10126.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso97971.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso97971.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO/IEC 9797-1 Padding Method 2.\n\t */\n\tCryptoJS.pad.Iso97971 = {\n\t    pad: function (data, blockSize) {\n\t        // Add 0x80 byte\n\t        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));\n\n\t        // Zero pad the rest\n\t        CryptoJS.pad.ZeroPadding.pad(data, blockSize);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Remove zero padding\n\t        CryptoJS.pad.ZeroPadding.unpad(data);\n\n\t        // Remove one more byte -- the 0x80 byte\n\t        data.sigBytes--;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso97971;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/pad-iso97971.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-nopadding.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/pad-nopadding.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * A noop padding strategy.\n\t */\n\tCryptoJS.pad.NoPadding = {\n\t    pad: function () {\n\t    },\n\n\t    unpad: function () {\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.NoPadding;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/pad-nopadding.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-zeropadding.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/pad-zeropadding.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Zero padding strategy.\n\t */\n\tCryptoJS.pad.ZeroPadding = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Shortcut\n\t        var dataWords = data.words;\n\n\t        // Unpad\n\t        var i = data.sigBytes - 1;\n\t        for (var i = data.sigBytes - 1; i >= 0; i--) {\n\t            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {\n\t                data.sigBytes = i + 1;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.ZeroPadding;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/pad-zeropadding.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pbkdf2.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/pbkdf2.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha1 */ \"./node_modules/crypto-js/sha1.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA1 = C_algo.SHA1;\n\t    var HMAC = C_algo.HMAC;\n\n\t    /**\n\t     * Password-Based Key Derivation Function 2 algorithm.\n\t     */\n\t    var PBKDF2 = C_algo.PBKDF2 = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hasher to use. Default: SHA1\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: SHA1,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create();\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Computes the Password-Based Key Derivation Function 2.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init HMAC\n\t            var hmac = HMAC.create(cfg.hasher, password);\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\t            var blockIndex = WordArray.create([0x00000001]);\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var blockIndexWords = blockIndex.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                var block = hmac.update(salt).finalize(blockIndex);\n\t                hmac.reset();\n\n\t                // Shortcuts\n\t                var blockWords = block.words;\n\t                var blockWordsLength = blockWords.length;\n\n\t                // Iterations\n\t                var intermediate = block;\n\t                for (var i = 1; i < iterations; i++) {\n\t                    intermediate = hmac.finalize(intermediate);\n\t                    hmac.reset();\n\n\t                    // Shortcut\n\t                    var intermediateWords = intermediate.words;\n\n\t                    // XOR intermediate with block\n\t                    for (var j = 0; j < blockWordsLength; j++) {\n\t                        blockWords[j] ^= intermediateWords[j];\n\t                    }\n\t                }\n\n\t                derivedKey.concat(block);\n\t                blockIndexWords[0]++;\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Computes the Password-Based Key Derivation Function 2.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.PBKDF2(password, salt);\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.PBKDF2 = function (password, salt, cfg) {\n\t        return PBKDF2.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.PBKDF2;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/pbkdf2.js?");

/***/ }),

/***/ "./node_modules/crypto-js/rabbit-legacy.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/rabbit-legacy.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm.\n\t     *\n\t     * This is a legacy version that neglected to convert the key to little-endian.\n\t     * This error doesn't affect the cipher's security,\n\t     * but it does affect its compatibility with other implementations.\n\t     */\n\t    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);\n\t}());\n\n\n\treturn CryptoJS.RabbitLegacy;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/rabbit-legacy.js?");

/***/ }),

/***/ "./node_modules/crypto-js/rabbit.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/rabbit.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm\n\t     */\n\t    var Rabbit = C_algo.Rabbit = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.Rabbit = StreamCipher._createHelper(Rabbit);\n\t}());\n\n\n\treturn CryptoJS.Rabbit;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/rabbit.js?");

/***/ }),

/***/ "./node_modules/crypto-js/rc4.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/rc4.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * RC4 stream cipher algorithm.\n\t     */\n\t    var RC4 = C_algo.RC4 = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            var keySigBytes = key.sigBytes;\n\n\t            // Init sbox\n\t            var S = this._S = [];\n\t            for (var i = 0; i < 256; i++) {\n\t                S[i] = i;\n\t            }\n\n\t            // Key setup\n\t            for (var i = 0, j = 0; i < 256; i++) {\n\t                var keyByteIndex = i % keySigBytes;\n\t                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\n\n\t                j = (j + S[i] + keyByte) % 256;\n\n\t                // Swap\n\t                var t = S[i];\n\t                S[i] = S[j];\n\t                S[j] = t;\n\t            }\n\n\t            // Counters\n\t            this._i = this._j = 0;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            M[offset] ^= generateKeystreamWord.call(this);\n\t        },\n\n\t        keySize: 256/32,\n\n\t        ivSize: 0\n\t    });\n\n\t    function generateKeystreamWord() {\n\t        // Shortcuts\n\t        var S = this._S;\n\t        var i = this._i;\n\t        var j = this._j;\n\n\t        // Generate keystream word\n\t        var keystreamWord = 0;\n\t        for (var n = 0; n < 4; n++) {\n\t            i = (i + 1) % 256;\n\t            j = (j + S[i]) % 256;\n\n\t            // Swap\n\t            var t = S[i];\n\t            S[i] = S[j];\n\t            S[j] = t;\n\n\t            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\n\t        }\n\n\t        // Update counters\n\t        this._i = i;\n\t        this._j = j;\n\n\t        return keystreamWord;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4 = StreamCipher._createHelper(RC4);\n\n\t    /**\n\t     * Modified RC4 stream cipher algorithm.\n\t     */\n\t    var RC4Drop = C_algo.RC4Drop = RC4.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} drop The number of keystream words to drop. Default 192\n\t         */\n\t        cfg: RC4.cfg.extend({\n\t            drop: 192\n\t        }),\n\n\t        _doReset: function () {\n\t            RC4._doReset.call(this);\n\n\t            // Drop\n\t            for (var i = this.cfg.drop; i > 0; i--) {\n\t                generateKeystreamWord.call(this);\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4Drop = StreamCipher._createHelper(RC4Drop);\n\t}());\n\n\n\treturn CryptoJS.RC4;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/rc4.js?");

/***/ }),

/***/ "./node_modules/crypto-js/ripemd160.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/ripemd160.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t(c) 2012 by Cdric Mesnil. All rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\t    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\t    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t*/\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var _zl = WordArray.create([\n\t        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,\n\t        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,\n\t        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,\n\t        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);\n\t    var _zr = WordArray.create([\n\t        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,\n\t        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,\n\t        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,\n\t        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,\n\t        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);\n\t    var _sl = WordArray.create([\n\t         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,\n\t        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,\n\t        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,\n\t          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,\n\t        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);\n\t    var _sr = WordArray.create([\n\t        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,\n\t        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,\n\t        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,\n\t        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,\n\t        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);\n\n\t    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\n\t    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\n\t    /**\n\t     * RIPEMD160 hash algorithm.\n\t     */\n\t    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                // Swap\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\t            // Shortcut\n\t            var H  = this._hash.words;\n\t            var hl = _hl.words;\n\t            var hr = _hr.words;\n\t            var zl = _zl.words;\n\t            var zr = _zr.words;\n\t            var sl = _sl.words;\n\t            var sr = _sr.words;\n\n\t            // Working variables\n\t            var al, bl, cl, dl, el;\n\t            var ar, br, cr, dr, er;\n\n\t            ar = al = H[0];\n\t            br = bl = H[1];\n\t            cr = cl = H[2];\n\t            dr = dl = H[3];\n\t            er = el = H[4];\n\t            // Computation\n\t            var t;\n\t            for (var i = 0; i < 80; i += 1) {\n\t                t = (al +  M[offset+zl[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f1(bl,cl,dl) + hl[0];\n\t                } else if (i<32) {\n\t\t            t +=  f2(bl,cl,dl) + hl[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(bl,cl,dl) + hl[2];\n\t                } else if (i<64) {\n\t\t            t +=  f4(bl,cl,dl) + hl[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f5(bl,cl,dl) + hl[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sl[i]);\n\t                t = (t+el)|0;\n\t                al = el;\n\t                el = dl;\n\t                dl = rotl(cl, 10);\n\t                cl = bl;\n\t                bl = t;\n\n\t                t = (ar + M[offset+zr[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f5(br,cr,dr) + hr[0];\n\t                } else if (i<32) {\n\t\t            t +=  f4(br,cr,dr) + hr[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(br,cr,dr) + hr[2];\n\t                } else if (i<64) {\n\t\t            t +=  f2(br,cr,dr) + hr[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f1(br,cr,dr) + hr[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sr[i]) ;\n\t                t = (t+er)|0;\n\t                ar = er;\n\t                er = dr;\n\t                dr = rotl(cr, 10);\n\t                cr = br;\n\t                br = t;\n\t            }\n\t            // Intermediate hash value\n\t            t    = (H[1] + cl + dr)|0;\n\t            H[1] = (H[2] + dl + er)|0;\n\t            H[2] = (H[3] + el + ar)|0;\n\t            H[3] = (H[4] + al + br)|0;\n\t            H[4] = (H[0] + bl + cr)|0;\n\t            H[0] =  t;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)\n\t            );\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 5; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                // Swap\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\n\t    function f1(x, y, z) {\n\t        return ((x) ^ (y) ^ (z));\n\n\t    }\n\n\t    function f2(x, y, z) {\n\t        return (((x)&(y)) | ((~x)&(z)));\n\t    }\n\n\t    function f3(x, y, z) {\n\t        return (((x) | (~(y))) ^ (z));\n\t    }\n\n\t    function f4(x, y, z) {\n\t        return (((x) & (z)) | ((y)&(~(z))));\n\t    }\n\n\t    function f5(x, y, z) {\n\t        return ((x) ^ ((y) |(~(z))));\n\n\t    }\n\n\t    function rotl(x,n) {\n\t        return (x<<n) | (x>>>(32-n));\n\t    }\n\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.RIPEMD160('message');\n\t     *     var hash = CryptoJS.RIPEMD160(wordArray);\n\t     */\n\t    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n\t     */\n\t    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);\n\t}(Math));\n\n\n\treturn CryptoJS.RIPEMD160;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/ripemd160.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha1.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha1.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-1 hash algorithm.\n\t     */\n\t    var SHA1 = C_algo.SHA1 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476,\n\t                0xc3d2e1f0\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\n\t            // Computation\n\t            for (var i = 0; i < 80; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n\t                    W[i] = (n << 1) | (n >>> 31);\n\t                }\n\n\t                var t = ((a << 5) | (a >>> 27)) + e + W[i];\n\t                if (i < 20) {\n\t                    t += ((b & c) | (~b & d)) + 0x5a827999;\n\t                } else if (i < 40) {\n\t                    t += (b ^ c ^ d) + 0x6ed9eba1;\n\t                } else if (i < 60) {\n\t                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n\t                } else /* if (i < 80) */ {\n\t                    t += (b ^ c ^ d) - 0x359d3e2a;\n\t                }\n\n\t                e = d;\n\t                d = c;\n\t                c = (b << 30) | (b >>> 2);\n\t                b = a;\n\t                a = t;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA1('message');\n\t     *     var hash = CryptoJS.SHA1(wordArray);\n\t     */\n\t    C.SHA1 = Hasher._createHelper(SHA1);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA1(message, key);\n\t     */\n\t    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n\t}());\n\n\n\treturn CryptoJS.SHA1;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/sha1.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha224.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha224.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha256 */ \"./node_modules/crypto-js/sha256.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA256 = C_algo.SHA256;\n\n\t    /**\n\t     * SHA-224 hash algorithm.\n\t     */\n\t    var SHA224 = C_algo.SHA224 = SHA256.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA256._doFinalize.call(this);\n\n\t            hash.sigBytes -= 4;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA224('message');\n\t     *     var hash = CryptoJS.SHA224(wordArray);\n\t     */\n\t    C.SHA224 = SHA256._createHelper(SHA224);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA224(message, key);\n\t     */\n\t    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);\n\t}());\n\n\n\treturn CryptoJS.SHA224;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/sha224.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha256.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha256.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/sha256.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha3.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha3.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var C_algo = C.algo;\n\n\t    // Constants tables\n\t    var RHO_OFFSETS = [];\n\t    var PI_INDEXES  = [];\n\t    var ROUND_CONSTANTS = [];\n\n\t    // Compute Constants\n\t    (function () {\n\t        // Compute rho offset constants\n\t        var x = 1, y = 0;\n\t        for (var t = 0; t < 24; t++) {\n\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t            var newX = y % 5;\n\t            var newY = (2 * x + 3 * y) % 5;\n\t            x = newX;\n\t            y = newY;\n\t        }\n\n\t        // Compute pi index constants\n\t        for (var x = 0; x < 5; x++) {\n\t            for (var y = 0; y < 5; y++) {\n\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t            }\n\t        }\n\n\t        // Compute round constants\n\t        var LFSR = 0x01;\n\t        for (var i = 0; i < 24; i++) {\n\t            var roundConstantMsw = 0;\n\t            var roundConstantLsw = 0;\n\n\t            for (var j = 0; j < 7; j++) {\n\t                if (LFSR & 0x01) {\n\t                    var bitPosition = (1 << j) - 1;\n\t                    if (bitPosition < 32) {\n\t                        roundConstantLsw ^= 1 << bitPosition;\n\t                    } else /* if (bitPosition >= 32) */ {\n\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t                    }\n\t                }\n\n\t                // Compute next LFSR\n\t                if (LFSR & 0x80) {\n\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t                } else {\n\t                    LFSR <<= 1;\n\t                }\n\t            }\n\n\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t        }\n\t    }());\n\n\t    // Reusable objects for temporary values\n\t    var T = [];\n\t    (function () {\n\t        for (var i = 0; i < 25; i++) {\n\t            T[i] = X64Word.create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-3 hash algorithm.\n\t     */\n\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} outputLength\n\t         *   The desired number of bits in the output hash.\n\t         *   Only values permitted are: 224, 256, 384, 512.\n\t         *   Default: 512\n\t         */\n\t        cfg: Hasher.cfg.extend({\n\t            outputLength: 512\n\t        }),\n\n\t        _doReset: function () {\n\t            var state = this._state = []\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = new X64Word.init();\n\t            }\n\n\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t            // Absorb\n\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t                // Shortcuts\n\t                var M2i  = M[offset + 2 * i];\n\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t                // Swap endian\n\t                M2i = (\n\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t                );\n\t                M2i1 = (\n\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Absorb message into state\n\t                var lane = state[i];\n\t                lane.high ^= M2i1;\n\t                lane.low  ^= M2i;\n\t            }\n\n\t            // Rounds\n\t            for (var round = 0; round < 24; round++) {\n\t                // Theta\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Mix column lanes\n\t                    var tMsw = 0, tLsw = 0;\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        tMsw ^= lane.high;\n\t                        tLsw ^= lane.low;\n\t                    }\n\n\t                    // Temporary values\n\t                    var Tx = T[x];\n\t                    Tx.high = tMsw;\n\t                    Tx.low  = tLsw;\n\t                }\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Shortcuts\n\t                    var Tx4 = T[(x + 4) % 5];\n\t                    var Tx1 = T[(x + 1) % 5];\n\t                    var Tx1Msw = Tx1.high;\n\t                    var Tx1Lsw = Tx1.low;\n\n\t                    // Mix surrounding columns\n\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        lane.high ^= tMsw;\n\t                        lane.low  ^= tLsw;\n\t                    }\n\t                }\n\n\t                // Rho Pi\n\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t                    var tMsw;\n\t                    var tLsw;\n\n\t                    // Shortcuts\n\t                    var lane = state[laneIndex];\n\t                    var laneMsw = lane.high;\n\t                    var laneLsw = lane.low;\n\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t                    // Rotate lanes\n\t                    if (rhoOffset < 32) {\n\t                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t                    } else /* if (rhoOffset >= 32) */ {\n\t                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t                    }\n\n\t                    // Transpose lanes\n\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t                    TPiLane.high = tMsw;\n\t                    TPiLane.low  = tLsw;\n\t                }\n\n\t                // Rho pi at x = y = 0\n\t                var T0 = T[0];\n\t                var state0 = state[0];\n\t                T0.high = state0.high;\n\t                T0.low  = state0.low;\n\n\t                // Chi\n\t                for (var x = 0; x < 5; x++) {\n\t                    for (var y = 0; y < 5; y++) {\n\t                        // Shortcuts\n\t                        var laneIndex = x + 5 * y;\n\t                        var lane = state[laneIndex];\n\t                        var TLane = T[laneIndex];\n\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t                        // Mix rows\n\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t                    }\n\t                }\n\n\t                // Iota\n\t                var lane = state[0];\n\t                var roundConstant = ROUND_CONSTANTS[round];\n\t                lane.high ^= roundConstant.high;\n\t                lane.low  ^= roundConstant.low;\n\t            }\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\t            var blockSizeBits = this.blockSize * 32;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t            // Squeeze\n\t            var hashWords = [];\n\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t                // Shortcuts\n\t                var lane = state[i];\n\t                var laneMsw = lane.high;\n\t                var laneLsw = lane.low;\n\n\t                // Swap endian\n\t                laneMsw = (\n\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t                );\n\t                laneLsw = (\n\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Squeeze state to retrieve hash\n\t                hashWords.push(laneLsw);\n\t                hashWords.push(laneMsw);\n\t            }\n\n\t            // Return final computed hash\n\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\n\t            var state = clone._state = this._state.slice(0);\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = state[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA3('message');\n\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t     */\n\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t     */\n\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA3;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/sha3.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha384.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha384.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"), __webpack_require__(/*! ./sha512 */ \"./node_modules/crypto-js/sha512.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA512 = C_algo.SHA512;\n\n\t    /**\n\t     * SHA-384 hash algorithm.\n\t     */\n\t    var SHA384 = C_algo.SHA384 = SHA512.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),\n\t                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),\n\t                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),\n\t                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA512._doFinalize.call(this);\n\n\t            hash.sigBytes -= 16;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA384('message');\n\t     *     var hash = CryptoJS.SHA384(wordArray);\n\t     */\n\t    C.SHA384 = SHA512._createHelper(SHA384);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA384(message, key);\n\t     */\n\t    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);\n\t}());\n\n\n\treturn CryptoJS.SHA384;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/sha384.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha512.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha512.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\n\t    function X64Word_create() {\n\t        return X64Word.create.apply(X64Word, arguments);\n\t    }\n\n\t    // Constants\n\t    var K = [\n\t        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),\n\t        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),\n\t        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),\n\t        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),\n\t        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),\n\t        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),\n\t        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),\n\t        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),\n\t        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),\n\t        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),\n\t        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),\n\t        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),\n\t        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),\n\t        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),\n\t        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),\n\t        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),\n\t        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),\n\t        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),\n\t        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),\n\t        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),\n\t        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),\n\t        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),\n\t        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),\n\t        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),\n\t        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),\n\t        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),\n\t        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),\n\t        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),\n\t        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),\n\t        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),\n\t        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),\n\t        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),\n\t        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),\n\t        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),\n\t        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),\n\t        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),\n\t        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),\n\t        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),\n\t        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),\n\t        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)\n\t    ];\n\n\t    // Reusable objects\n\t    var W = [];\n\t    (function () {\n\t        for (var i = 0; i < 80; i++) {\n\t            W[i] = X64Word_create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-512 hash algorithm.\n\t     */\n\t    var SHA512 = C_algo.SHA512 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),\n\t                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),\n\t                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),\n\t                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var H0 = H[0];\n\t            var H1 = H[1];\n\t            var H2 = H[2];\n\t            var H3 = H[3];\n\t            var H4 = H[4];\n\t            var H5 = H[5];\n\t            var H6 = H[6];\n\t            var H7 = H[7];\n\n\t            var H0h = H0.high;\n\t            var H0l = H0.low;\n\t            var H1h = H1.high;\n\t            var H1l = H1.low;\n\t            var H2h = H2.high;\n\t            var H2l = H2.low;\n\t            var H3h = H3.high;\n\t            var H3l = H3.low;\n\t            var H4h = H4.high;\n\t            var H4l = H4.low;\n\t            var H5h = H5.high;\n\t            var H5l = H5.low;\n\t            var H6h = H6.high;\n\t            var H6l = H6.low;\n\t            var H7h = H7.high;\n\t            var H7l = H7.low;\n\n\t            // Working variables\n\t            var ah = H0h;\n\t            var al = H0l;\n\t            var bh = H1h;\n\t            var bl = H1l;\n\t            var ch = H2h;\n\t            var cl = H2l;\n\t            var dh = H3h;\n\t            var dl = H3l;\n\t            var eh = H4h;\n\t            var el = H4l;\n\t            var fh = H5h;\n\t            var fl = H5l;\n\t            var gh = H6h;\n\t            var gl = H6l;\n\t            var hh = H7h;\n\t            var hl = H7l;\n\n\t            // Rounds\n\t            for (var i = 0; i < 80; i++) {\n\t                var Wil;\n\t                var Wih;\n\n\t                // Shortcut\n\t                var Wi = W[i];\n\n\t                // Extend message\n\t                if (i < 16) {\n\t                    Wih = Wi.high = M[offset + i * 2]     | 0;\n\t                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;\n\t                } else {\n\t                    // Gamma0\n\t                    var gamma0x  = W[i - 15];\n\t                    var gamma0xh = gamma0x.high;\n\t                    var gamma0xl = gamma0x.low;\n\t                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);\n\t                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\n\n\t                    // Gamma1\n\t                    var gamma1x  = W[i - 2];\n\t                    var gamma1xh = gamma1x.high;\n\t                    var gamma1xl = gamma1x.low;\n\t                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);\n\t                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\n\n\t                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n\t                    var Wi7  = W[i - 7];\n\t                    var Wi7h = Wi7.high;\n\t                    var Wi7l = Wi7.low;\n\n\t                    var Wi16  = W[i - 16];\n\t                    var Wi16h = Wi16.high;\n\t                    var Wi16l = Wi16.low;\n\n\t                    Wil = gamma0l + Wi7l;\n\t                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n\t                    Wil = Wil + gamma1l;\n\t                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n\t                    Wil = Wil + Wi16l;\n\t                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\n\n\t                    Wi.high = Wih;\n\t                    Wi.low  = Wil;\n\t                }\n\n\t                var chh  = (eh & fh) ^ (~eh & gh);\n\t                var chl  = (el & fl) ^ (~el & gl);\n\t                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n\t                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n\t                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n\t                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\t                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));\n\t                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));\n\n\t                // t1 = h + sigma1 + ch + K[i] + W[i]\n\t                var Ki  = K[i];\n\t                var Kih = Ki.high;\n\t                var Kil = Ki.low;\n\n\t                var t1l = hl + sigma1l;\n\t                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + chl;\n\t                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Kil;\n\t                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Wil;\n\t                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\n\n\t                // t2 = sigma0 + maj\n\t                var t2l = sigma0l + majl;\n\t                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n\t                // Update working variables\n\t                hh = gh;\n\t                hl = gl;\n\t                gh = fh;\n\t                gl = fl;\n\t                fh = eh;\n\t                fl = el;\n\t                el = (dl + t1l) | 0;\n\t                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n\t                dh = ch;\n\t                dl = cl;\n\t                ch = bh;\n\t                cl = bl;\n\t                bh = ah;\n\t                bl = al;\n\t                al = (t1l + t2l) | 0;\n\t                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H0l = H0.low  = (H0l + al);\n\t            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\n\t            H1l = H1.low  = (H1l + bl);\n\t            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\n\t            H2l = H2.low  = (H2l + cl);\n\t            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\n\t            H3l = H3.low  = (H3l + dl);\n\t            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\n\t            H4l = H4.low  = (H4l + el);\n\t            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\n\t            H5l = H5.low  = (H5l + fl);\n\t            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\n\t            H6l = H6.low  = (H6l + gl);\n\t            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\n\t            H7l = H7.low  = (H7l + hl);\n\t            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Convert hash to 32-bit word array before returning\n\t            var hash = this._hash.toX32();\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        },\n\n\t        blockSize: 1024/32\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA512('message');\n\t     *     var hash = CryptoJS.SHA512(wordArray);\n\t     */\n\t    C.SHA512 = Hasher._createHelper(SHA512);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA512(message, key);\n\t     */\n\t    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);\n\t}());\n\n\n\treturn CryptoJS.SHA512;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/sha512.js?");

/***/ }),

/***/ "./node_modules/crypto-js/tripledes.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/tripledes.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Permuted Choice 1 constants\n\t    var PC1 = [\n\t        57, 49, 41, 33, 25, 17, 9,  1,\n\t        58, 50, 42, 34, 26, 18, 10, 2,\n\t        59, 51, 43, 35, 27, 19, 11, 3,\n\t        60, 52, 44, 36, 63, 55, 47, 39,\n\t        31, 23, 15, 7,  62, 54, 46, 38,\n\t        30, 22, 14, 6,  61, 53, 45, 37,\n\t        29, 21, 13, 5,  28, 20, 12, 4\n\t    ];\n\n\t    // Permuted Choice 2 constants\n\t    var PC2 = [\n\t        14, 17, 11, 24, 1,  5,\n\t        3,  28, 15, 6,  21, 10,\n\t        23, 19, 12, 4,  26, 8,\n\t        16, 7,  27, 20, 13, 2,\n\t        41, 52, 31, 37, 47, 55,\n\t        30, 40, 51, 45, 33, 48,\n\t        44, 49, 39, 56, 34, 53,\n\t        46, 42, 50, 36, 29, 32\n\t    ];\n\n\t    // Cumulative bit shift constants\n\t    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\n\n\t    // SBOXes and round permutation constants\n\t    var SBOX_P = [\n\t        {\n\t            0x0: 0x808200,\n\t            0x10000000: 0x8000,\n\t            0x20000000: 0x808002,\n\t            0x30000000: 0x2,\n\t            0x40000000: 0x200,\n\t            0x50000000: 0x808202,\n\t            0x60000000: 0x800202,\n\t            0x70000000: 0x800000,\n\t            0x80000000: 0x202,\n\t            0x90000000: 0x800200,\n\t            0xa0000000: 0x8200,\n\t            0xb0000000: 0x808000,\n\t            0xc0000000: 0x8002,\n\t            0xd0000000: 0x800002,\n\t            0xe0000000: 0x0,\n\t            0xf0000000: 0x8202,\n\t            0x8000000: 0x0,\n\t            0x18000000: 0x808202,\n\t            0x28000000: 0x8202,\n\t            0x38000000: 0x8000,\n\t            0x48000000: 0x808200,\n\t            0x58000000: 0x200,\n\t            0x68000000: 0x808002,\n\t            0x78000000: 0x2,\n\t            0x88000000: 0x800200,\n\t            0x98000000: 0x8200,\n\t            0xa8000000: 0x808000,\n\t            0xb8000000: 0x800202,\n\t            0xc8000000: 0x800002,\n\t            0xd8000000: 0x8002,\n\t            0xe8000000: 0x202,\n\t            0xf8000000: 0x800000,\n\t            0x1: 0x8000,\n\t            0x10000001: 0x2,\n\t            0x20000001: 0x808200,\n\t            0x30000001: 0x800000,\n\t            0x40000001: 0x808002,\n\t            0x50000001: 0x8200,\n\t            0x60000001: 0x200,\n\t            0x70000001: 0x800202,\n\t            0x80000001: 0x808202,\n\t            0x90000001: 0x808000,\n\t            0xa0000001: 0x800002,\n\t            0xb0000001: 0x8202,\n\t            0xc0000001: 0x202,\n\t            0xd0000001: 0x800200,\n\t            0xe0000001: 0x8002,\n\t            0xf0000001: 0x0,\n\t            0x8000001: 0x808202,\n\t            0x18000001: 0x808000,\n\t            0x28000001: 0x800000,\n\t            0x38000001: 0x200,\n\t            0x48000001: 0x8000,\n\t            0x58000001: 0x800002,\n\t            0x68000001: 0x2,\n\t            0x78000001: 0x8202,\n\t            0x88000001: 0x8002,\n\t            0x98000001: 0x800202,\n\t            0xa8000001: 0x202,\n\t            0xb8000001: 0x808200,\n\t            0xc8000001: 0x800200,\n\t            0xd8000001: 0x0,\n\t            0xe8000001: 0x8200,\n\t            0xf8000001: 0x808002\n\t        },\n\t        {\n\t            0x0: 0x40084010,\n\t            0x1000000: 0x4000,\n\t            0x2000000: 0x80000,\n\t            0x3000000: 0x40080010,\n\t            0x4000000: 0x40000010,\n\t            0x5000000: 0x40084000,\n\t            0x6000000: 0x40004000,\n\t            0x7000000: 0x10,\n\t            0x8000000: 0x84000,\n\t            0x9000000: 0x40004010,\n\t            0xa000000: 0x40000000,\n\t            0xb000000: 0x84010,\n\t            0xc000000: 0x80010,\n\t            0xd000000: 0x0,\n\t            0xe000000: 0x4010,\n\t            0xf000000: 0x40080000,\n\t            0x800000: 0x40004000,\n\t            0x1800000: 0x84010,\n\t            0x2800000: 0x10,\n\t            0x3800000: 0x40004010,\n\t            0x4800000: 0x40084010,\n\t            0x5800000: 0x40000000,\n\t            0x6800000: 0x80000,\n\t            0x7800000: 0x40080010,\n\t            0x8800000: 0x80010,\n\t            0x9800000: 0x0,\n\t            0xa800000: 0x4000,\n\t            0xb800000: 0x40080000,\n\t            0xc800000: 0x40000010,\n\t            0xd800000: 0x84000,\n\t            0xe800000: 0x40084000,\n\t            0xf800000: 0x4010,\n\t            0x10000000: 0x0,\n\t            0x11000000: 0x40080010,\n\t            0x12000000: 0x40004010,\n\t            0x13000000: 0x40084000,\n\t            0x14000000: 0x40080000,\n\t            0x15000000: 0x10,\n\t            0x16000000: 0x84010,\n\t            0x17000000: 0x4000,\n\t            0x18000000: 0x4010,\n\t            0x19000000: 0x80000,\n\t            0x1a000000: 0x80010,\n\t            0x1b000000: 0x40000010,\n\t            0x1c000000: 0x84000,\n\t            0x1d000000: 0x40004000,\n\t            0x1e000000: 0x40000000,\n\t            0x1f000000: 0x40084010,\n\t            0x10800000: 0x84010,\n\t            0x11800000: 0x80000,\n\t            0x12800000: 0x40080000,\n\t            0x13800000: 0x4000,\n\t            0x14800000: 0x40004000,\n\t            0x15800000: 0x40084010,\n\t            0x16800000: 0x10,\n\t            0x17800000: 0x40000000,\n\t            0x18800000: 0x40084000,\n\t            0x19800000: 0x40000010,\n\t            0x1a800000: 0x40004010,\n\t            0x1b800000: 0x80010,\n\t            0x1c800000: 0x0,\n\t            0x1d800000: 0x4010,\n\t            0x1e800000: 0x40080010,\n\t            0x1f800000: 0x84000\n\t        },\n\t        {\n\t            0x0: 0x104,\n\t            0x100000: 0x0,\n\t            0x200000: 0x4000100,\n\t            0x300000: 0x10104,\n\t            0x400000: 0x10004,\n\t            0x500000: 0x4000004,\n\t            0x600000: 0x4010104,\n\t            0x700000: 0x4010000,\n\t            0x800000: 0x4000000,\n\t            0x900000: 0x4010100,\n\t            0xa00000: 0x10100,\n\t            0xb00000: 0x4010004,\n\t            0xc00000: 0x4000104,\n\t            0xd00000: 0x10000,\n\t            0xe00000: 0x4,\n\t            0xf00000: 0x100,\n\t            0x80000: 0x4010100,\n\t            0x180000: 0x4010004,\n\t            0x280000: 0x0,\n\t            0x380000: 0x4000100,\n\t            0x480000: 0x4000004,\n\t            0x580000: 0x10000,\n\t            0x680000: 0x10004,\n\t            0x780000: 0x104,\n\t            0x880000: 0x4,\n\t            0x980000: 0x100,\n\t            0xa80000: 0x4010000,\n\t            0xb80000: 0x10104,\n\t            0xc80000: 0x10100,\n\t            0xd80000: 0x4000104,\n\t            0xe80000: 0x4010104,\n\t            0xf80000: 0x4000000,\n\t            0x1000000: 0x4010100,\n\t            0x1100000: 0x10004,\n\t            0x1200000: 0x10000,\n\t            0x1300000: 0x4000100,\n\t            0x1400000: 0x100,\n\t            0x1500000: 0x4010104,\n\t            0x1600000: 0x4000004,\n\t            0x1700000: 0x0,\n\t            0x1800000: 0x4000104,\n\t            0x1900000: 0x4000000,\n\t            0x1a00000: 0x4,\n\t            0x1b00000: 0x10100,\n\t            0x1c00000: 0x4010000,\n\t            0x1d00000: 0x104,\n\t            0x1e00000: 0x10104,\n\t            0x1f00000: 0x4010004,\n\t            0x1080000: 0x4000000,\n\t            0x1180000: 0x104,\n\t            0x1280000: 0x4010100,\n\t            0x1380000: 0x0,\n\t            0x1480000: 0x10004,\n\t            0x1580000: 0x4000100,\n\t            0x1680000: 0x100,\n\t            0x1780000: 0x4010004,\n\t            0x1880000: 0x10000,\n\t            0x1980000: 0x4010104,\n\t            0x1a80000: 0x10104,\n\t            0x1b80000: 0x4000004,\n\t            0x1c80000: 0x4000104,\n\t            0x1d80000: 0x4010000,\n\t            0x1e80000: 0x4,\n\t            0x1f80000: 0x10100\n\t        },\n\t        {\n\t            0x0: 0x80401000,\n\t            0x10000: 0x80001040,\n\t            0x20000: 0x401040,\n\t            0x30000: 0x80400000,\n\t            0x40000: 0x0,\n\t            0x50000: 0x401000,\n\t            0x60000: 0x80000040,\n\t            0x70000: 0x400040,\n\t            0x80000: 0x80000000,\n\t            0x90000: 0x400000,\n\t            0xa0000: 0x40,\n\t            0xb0000: 0x80001000,\n\t            0xc0000: 0x80400040,\n\t            0xd0000: 0x1040,\n\t            0xe0000: 0x1000,\n\t            0xf0000: 0x80401040,\n\t            0x8000: 0x80001040,\n\t            0x18000: 0x40,\n\t            0x28000: 0x80400040,\n\t            0x38000: 0x80001000,\n\t            0x48000: 0x401000,\n\t            0x58000: 0x80401040,\n\t            0x68000: 0x0,\n\t            0x78000: 0x80400000,\n\t            0x88000: 0x1000,\n\t            0x98000: 0x80401000,\n\t            0xa8000: 0x400000,\n\t            0xb8000: 0x1040,\n\t            0xc8000: 0x80000000,\n\t            0xd8000: 0x400040,\n\t            0xe8000: 0x401040,\n\t            0xf8000: 0x80000040,\n\t            0x100000: 0x400040,\n\t            0x110000: 0x401000,\n\t            0x120000: 0x80000040,\n\t            0x130000: 0x0,\n\t            0x140000: 0x1040,\n\t            0x150000: 0x80400040,\n\t            0x160000: 0x80401000,\n\t            0x170000: 0x80001040,\n\t            0x180000: 0x80401040,\n\t            0x190000: 0x80000000,\n\t            0x1a0000: 0x80400000,\n\t            0x1b0000: 0x401040,\n\t            0x1c0000: 0x80001000,\n\t            0x1d0000: 0x400000,\n\t            0x1e0000: 0x40,\n\t            0x1f0000: 0x1000,\n\t            0x108000: 0x80400000,\n\t            0x118000: 0x80401040,\n\t            0x128000: 0x0,\n\t            0x138000: 0x401000,\n\t            0x148000: 0x400040,\n\t            0x158000: 0x80000000,\n\t            0x168000: 0x80001040,\n\t            0x178000: 0x40,\n\t            0x188000: 0x80000040,\n\t            0x198000: 0x1000,\n\t            0x1a8000: 0x80001000,\n\t            0x1b8000: 0x80400040,\n\t            0x1c8000: 0x1040,\n\t            0x1d8000: 0x80401000,\n\t            0x1e8000: 0x400000,\n\t            0x1f8000: 0x401040\n\t        },\n\t        {\n\t            0x0: 0x80,\n\t            0x1000: 0x1040000,\n\t            0x2000: 0x40000,\n\t            0x3000: 0x20000000,\n\t            0x4000: 0x20040080,\n\t            0x5000: 0x1000080,\n\t            0x6000: 0x21000080,\n\t            0x7000: 0x40080,\n\t            0x8000: 0x1000000,\n\t            0x9000: 0x20040000,\n\t            0xa000: 0x20000080,\n\t            0xb000: 0x21040080,\n\t            0xc000: 0x21040000,\n\t            0xd000: 0x0,\n\t            0xe000: 0x1040080,\n\t            0xf000: 0x21000000,\n\t            0x800: 0x1040080,\n\t            0x1800: 0x21000080,\n\t            0x2800: 0x80,\n\t            0x3800: 0x1040000,\n\t            0x4800: 0x40000,\n\t            0x5800: 0x20040080,\n\t            0x6800: 0x21040000,\n\t            0x7800: 0x20000000,\n\t            0x8800: 0x20040000,\n\t            0x9800: 0x0,\n\t            0xa800: 0x21040080,\n\t            0xb800: 0x1000080,\n\t            0xc800: 0x20000080,\n\t            0xd800: 0x21000000,\n\t            0xe800: 0x1000000,\n\t            0xf800: 0x40080,\n\t            0x10000: 0x40000,\n\t            0x11000: 0x80,\n\t            0x12000: 0x20000000,\n\t            0x13000: 0x21000080,\n\t            0x14000: 0x1000080,\n\t            0x15000: 0x21040000,\n\t            0x16000: 0x20040080,\n\t            0x17000: 0x1000000,\n\t            0x18000: 0x21040080,\n\t            0x19000: 0x21000000,\n\t            0x1a000: 0x1040000,\n\t            0x1b000: 0x20040000,\n\t            0x1c000: 0x40080,\n\t            0x1d000: 0x20000080,\n\t            0x1e000: 0x0,\n\t            0x1f000: 0x1040080,\n\t            0x10800: 0x21000080,\n\t            0x11800: 0x1000000,\n\t            0x12800: 0x1040000,\n\t            0x13800: 0x20040080,\n\t            0x14800: 0x20000000,\n\t            0x15800: 0x1040080,\n\t            0x16800: 0x80,\n\t            0x17800: 0x21040000,\n\t            0x18800: 0x40080,\n\t            0x19800: 0x21040080,\n\t            0x1a800: 0x0,\n\t            0x1b800: 0x21000000,\n\t            0x1c800: 0x1000080,\n\t            0x1d800: 0x40000,\n\t            0x1e800: 0x20040000,\n\t            0x1f800: 0x20000080\n\t        },\n\t        {\n\t            0x0: 0x10000008,\n\t            0x100: 0x2000,\n\t            0x200: 0x10200000,\n\t            0x300: 0x10202008,\n\t            0x400: 0x10002000,\n\t            0x500: 0x200000,\n\t            0x600: 0x200008,\n\t            0x700: 0x10000000,\n\t            0x800: 0x0,\n\t            0x900: 0x10002008,\n\t            0xa00: 0x202000,\n\t            0xb00: 0x8,\n\t            0xc00: 0x10200008,\n\t            0xd00: 0x202008,\n\t            0xe00: 0x2008,\n\t            0xf00: 0x10202000,\n\t            0x80: 0x10200000,\n\t            0x180: 0x10202008,\n\t            0x280: 0x8,\n\t            0x380: 0x200000,\n\t            0x480: 0x202008,\n\t            0x580: 0x10000008,\n\t            0x680: 0x10002000,\n\t            0x780: 0x2008,\n\t            0x880: 0x200008,\n\t            0x980: 0x2000,\n\t            0xa80: 0x10002008,\n\t            0xb80: 0x10200008,\n\t            0xc80: 0x0,\n\t            0xd80: 0x10202000,\n\t            0xe80: 0x202000,\n\t            0xf80: 0x10000000,\n\t            0x1000: 0x10002000,\n\t            0x1100: 0x10200008,\n\t            0x1200: 0x10202008,\n\t            0x1300: 0x2008,\n\t            0x1400: 0x200000,\n\t            0x1500: 0x10000000,\n\t            0x1600: 0x10000008,\n\t            0x1700: 0x202000,\n\t            0x1800: 0x202008,\n\t            0x1900: 0x0,\n\t            0x1a00: 0x8,\n\t            0x1b00: 0x10200000,\n\t            0x1c00: 0x2000,\n\t            0x1d00: 0x10002008,\n\t            0x1e00: 0x10202000,\n\t            0x1f00: 0x200008,\n\t            0x1080: 0x8,\n\t            0x1180: 0x202000,\n\t            0x1280: 0x200000,\n\t            0x1380: 0x10000008,\n\t            0x1480: 0x10002000,\n\t            0x1580: 0x2008,\n\t            0x1680: 0x10202008,\n\t            0x1780: 0x10200000,\n\t            0x1880: 0x10202000,\n\t            0x1980: 0x10200008,\n\t            0x1a80: 0x2000,\n\t            0x1b80: 0x202008,\n\t            0x1c80: 0x200008,\n\t            0x1d80: 0x0,\n\t            0x1e80: 0x10000000,\n\t            0x1f80: 0x10002008\n\t        },\n\t        {\n\t            0x0: 0x100000,\n\t            0x10: 0x2000401,\n\t            0x20: 0x400,\n\t            0x30: 0x100401,\n\t            0x40: 0x2100401,\n\t            0x50: 0x0,\n\t            0x60: 0x1,\n\t            0x70: 0x2100001,\n\t            0x80: 0x2000400,\n\t            0x90: 0x100001,\n\t            0xa0: 0x2000001,\n\t            0xb0: 0x2100400,\n\t            0xc0: 0x2100000,\n\t            0xd0: 0x401,\n\t            0xe0: 0x100400,\n\t            0xf0: 0x2000000,\n\t            0x8: 0x2100001,\n\t            0x18: 0x0,\n\t            0x28: 0x2000401,\n\t            0x38: 0x2100400,\n\t            0x48: 0x100000,\n\t            0x58: 0x2000001,\n\t            0x68: 0x2000000,\n\t            0x78: 0x401,\n\t            0x88: 0x100401,\n\t            0x98: 0x2000400,\n\t            0xa8: 0x2100000,\n\t            0xb8: 0x100001,\n\t            0xc8: 0x400,\n\t            0xd8: 0x2100401,\n\t            0xe8: 0x1,\n\t            0xf8: 0x100400,\n\t            0x100: 0x2000000,\n\t            0x110: 0x100000,\n\t            0x120: 0x2000401,\n\t            0x130: 0x2100001,\n\t            0x140: 0x100001,\n\t            0x150: 0x2000400,\n\t            0x160: 0x2100400,\n\t            0x170: 0x100401,\n\t            0x180: 0x401,\n\t            0x190: 0x2100401,\n\t            0x1a0: 0x100400,\n\t            0x1b0: 0x1,\n\t            0x1c0: 0x0,\n\t            0x1d0: 0x2100000,\n\t            0x1e0: 0x2000001,\n\t            0x1f0: 0x400,\n\t            0x108: 0x100400,\n\t            0x118: 0x2000401,\n\t            0x128: 0x2100001,\n\t            0x138: 0x1,\n\t            0x148: 0x2000000,\n\t            0x158: 0x100000,\n\t            0x168: 0x401,\n\t            0x178: 0x2100400,\n\t            0x188: 0x2000001,\n\t            0x198: 0x2100000,\n\t            0x1a8: 0x0,\n\t            0x1b8: 0x2100401,\n\t            0x1c8: 0x100401,\n\t            0x1d8: 0x400,\n\t            0x1e8: 0x2000400,\n\t            0x1f8: 0x100001\n\t        },\n\t        {\n\t            0x0: 0x8000820,\n\t            0x1: 0x20000,\n\t            0x2: 0x8000000,\n\t            0x3: 0x20,\n\t            0x4: 0x20020,\n\t            0x5: 0x8020820,\n\t            0x6: 0x8020800,\n\t            0x7: 0x800,\n\t            0x8: 0x8020000,\n\t            0x9: 0x8000800,\n\t            0xa: 0x20800,\n\t            0xb: 0x8020020,\n\t            0xc: 0x820,\n\t            0xd: 0x0,\n\t            0xe: 0x8000020,\n\t            0xf: 0x20820,\n\t            0x80000000: 0x800,\n\t            0x80000001: 0x8020820,\n\t            0x80000002: 0x8000820,\n\t            0x80000003: 0x8000000,\n\t            0x80000004: 0x8020000,\n\t            0x80000005: 0x20800,\n\t            0x80000006: 0x20820,\n\t            0x80000007: 0x20,\n\t            0x80000008: 0x8000020,\n\t            0x80000009: 0x820,\n\t            0x8000000a: 0x20020,\n\t            0x8000000b: 0x8020800,\n\t            0x8000000c: 0x0,\n\t            0x8000000d: 0x8020020,\n\t            0x8000000e: 0x8000800,\n\t            0x8000000f: 0x20000,\n\t            0x10: 0x20820,\n\t            0x11: 0x8020800,\n\t            0x12: 0x20,\n\t            0x13: 0x800,\n\t            0x14: 0x8000800,\n\t            0x15: 0x8000020,\n\t            0x16: 0x8020020,\n\t            0x17: 0x20000,\n\t            0x18: 0x0,\n\t            0x19: 0x20020,\n\t            0x1a: 0x8020000,\n\t            0x1b: 0x8000820,\n\t            0x1c: 0x8020820,\n\t            0x1d: 0x20800,\n\t            0x1e: 0x820,\n\t            0x1f: 0x8000000,\n\t            0x80000010: 0x20000,\n\t            0x80000011: 0x800,\n\t            0x80000012: 0x8020020,\n\t            0x80000013: 0x20820,\n\t            0x80000014: 0x20,\n\t            0x80000015: 0x8020000,\n\t            0x80000016: 0x8000000,\n\t            0x80000017: 0x8000820,\n\t            0x80000018: 0x8020820,\n\t            0x80000019: 0x8000020,\n\t            0x8000001a: 0x8000800,\n\t            0x8000001b: 0x0,\n\t            0x8000001c: 0x20800,\n\t            0x8000001d: 0x820,\n\t            0x8000001e: 0x20020,\n\t            0x8000001f: 0x8020800\n\t        }\n\t    ];\n\n\t    // Masks that select the SBOX input\n\t    var SBOX_MASK = [\n\t        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,\n\t        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f\n\t    ];\n\n\t    /**\n\t     * DES block cipher algorithm.\n\t     */\n\t    var DES = C_algo.DES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\n\t            // Select 56 bits according to PC1\n\t            var keyBits = [];\n\t            for (var i = 0; i < 56; i++) {\n\t                var keyBitPos = PC1[i] - 1;\n\t                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;\n\t            }\n\n\t            // Assemble 16 subkeys\n\t            var subKeys = this._subKeys = [];\n\t            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {\n\t                // Create subkey\n\t                var subKey = subKeys[nSubKey] = [];\n\n\t                // Shortcut\n\t                var bitShift = BIT_SHIFTS[nSubKey];\n\n\t                // Select 48 bits according to PC2\n\t                for (var i = 0; i < 24; i++) {\n\t                    // Select from the left 28 key bits\n\t                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);\n\n\t                    // Select from the right 28 key bits\n\t                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);\n\t                }\n\n\t                // Since each subkey is applied to an expanded 32-bit input,\n\t                // the subkey can be broken into 8 values scaled to 32-bits,\n\t                // which allows the key to be used without expansion\n\t                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);\n\t                for (var i = 1; i < 7; i++) {\n\t                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);\n\t                }\n\t                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);\n\t            }\n\n\t            // Compute inverse subkeys\n\t            var invSubKeys = this._invSubKeys = [];\n\t            for (var i = 0; i < 16; i++) {\n\t                invSubKeys[i] = subKeys[15 - i];\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._subKeys);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._invSubKeys);\n\t        },\n\n\t        _doCryptBlock: function (M, offset, subKeys) {\n\t            // Get input\n\t            this._lBlock = M[offset];\n\t            this._rBlock = M[offset + 1];\n\n\t            // Initial permutation\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeLR.call(this, 1,  0x55555555);\n\n\t            // Rounds\n\t            for (var round = 0; round < 16; round++) {\n\t                // Shortcuts\n\t                var subKey = subKeys[round];\n\t                var lBlock = this._lBlock;\n\t                var rBlock = this._rBlock;\n\n\t                // Feistel function\n\t                var f = 0;\n\t                for (var i = 0; i < 8; i++) {\n\t                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n\t                }\n\t                this._lBlock = rBlock;\n\t                this._rBlock = lBlock ^ f;\n\t            }\n\n\t            // Undo swap from last round\n\t            var t = this._lBlock;\n\t            this._lBlock = this._rBlock;\n\t            this._rBlock = t;\n\n\t            // Final permutation\n\t            exchangeLR.call(this, 1,  0x55555555);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\n\t            // Set output\n\t            M[offset] = this._lBlock;\n\t            M[offset + 1] = this._rBlock;\n\t        },\n\n\t        keySize: 64/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    // Swap bits across the left and right words\n\t    function exchangeLR(offset, mask) {\n\t        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;\n\t        this._rBlock ^= t;\n\t        this._lBlock ^= t << offset;\n\t    }\n\n\t    function exchangeRL(offset, mask) {\n\t        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;\n\t        this._lBlock ^= t;\n\t        this._rBlock ^= t << offset;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.DES = BlockCipher._createHelper(DES);\n\n\t    /**\n\t     * Triple-DES block cipher algorithm.\n\t     */\n\t    var TripleDES = C_algo.TripleDES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            // Make sure the key length is valid (64, 128 or >= 192 bit)\n\t            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {\n\t                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');\n\t            }\n\n\t            // Extend the key according to the keying options defined in 3DES standard\n\t            var key1 = keyWords.slice(0, 2);\n\t            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);\n\t            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);\n\n\t            // Create DES instances\n\t            this._des1 = DES.createEncryptor(WordArray.create(key1));\n\t            this._des2 = DES.createEncryptor(WordArray.create(key2));\n\t            this._des3 = DES.createEncryptor(WordArray.create(key3));\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._des1.encryptBlock(M, offset);\n\t            this._des2.decryptBlock(M, offset);\n\t            this._des3.encryptBlock(M, offset);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._des3.decryptBlock(M, offset);\n\t            this._des2.encryptBlock(M, offset);\n\t            this._des1.decryptBlock(M, offset);\n\t        },\n\n\t        keySize: 192/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.TripleDES = BlockCipher._createHelper(TripleDES);\n\t}());\n\n\n\treturn CryptoJS.TripleDES;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/tripledes.js?");

/***/ }),

/***/ "./node_modules/crypto-js/x64-core.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/x64-core.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var X32WordArray = C_lib.WordArray;\n\n\t    /**\n\t     * x64 namespace.\n\t     */\n\t    var C_x64 = C.x64 = {};\n\n\t    /**\n\t     * A 64-bit word.\n\t     */\n\t    var X64Word = C_x64.Word = Base.extend({\n\t        /**\n\t         * Initializes a newly created 64-bit word.\n\t         *\n\t         * @param {number} high The high 32 bits.\n\t         * @param {number} low The low 32 bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n\t         */\n\t        init: function (high, low) {\n\t            this.high = high;\n\t            this.low = low;\n\t        }\n\n\t        /**\n\t         * Bitwise NOTs this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after negating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var negated = x64Word.not();\n\t         */\n\t        // not: function () {\n\t            // var high = ~this.high;\n\t            // var low = ~this.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ANDs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to AND with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ANDing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var anded = x64Word.and(anotherX64Word);\n\t         */\n\t        // and: function (word) {\n\t            // var high = this.high & word.high;\n\t            // var low = this.low & word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to OR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var ored = x64Word.or(anotherX64Word);\n\t         */\n\t        // or: function (word) {\n\t            // var high = this.high | word.high;\n\t            // var low = this.low | word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise XORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to XOR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after XORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var xored = x64Word.xor(anotherX64Word);\n\t         */\n\t        // xor: function (word) {\n\t            // var high = this.high ^ word.high;\n\t            // var low = this.low ^ word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftL(25);\n\t         */\n\t        // shiftL: function (n) {\n\t            // if (n < 32) {\n\t                // var high = (this.high << n) | (this.low >>> (32 - n));\n\t                // var low = this.low << n;\n\t            // } else {\n\t                // var high = this.low << (n - 32);\n\t                // var low = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftR(7);\n\t         */\n\t        // shiftR: function (n) {\n\t            // if (n < 32) {\n\t                // var low = (this.low >>> n) | (this.high << (32 - n));\n\t                // var high = this.high >>> n;\n\t            // } else {\n\t                // var low = this.high >>> (n - 32);\n\t                // var high = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotL(25);\n\t         */\n\t        // rotL: function (n) {\n\t            // return this.shiftL(n).or(this.shiftR(64 - n));\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotR(7);\n\t         */\n\t        // rotR: function (n) {\n\t            // return this.shiftR(n).or(this.shiftL(64 - n));\n\t        // },\n\n\t        /**\n\t         * Adds this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to add with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after adding.\n\t         *\n\t         * @example\n\t         *\n\t         *     var added = x64Word.add(anotherX64Word);\n\t         */\n\t        // add: function (word) {\n\t            // var low = (this.low + word.low) | 0;\n\t            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;\n\t            // var high = (this.high + word.high + carry) | 0;\n\n\t            // return X64Word.create(high, low);\n\t        // }\n\t    });\n\n\t    /**\n\t     * An array of 64-bit words.\n\t     *\n\t     * @property {Array} words The array of CryptoJS.x64.Word objects.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var X64WordArray = C_x64.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create();\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ]);\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ], 10);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 8;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this 64-bit word array to a 32-bit word array.\n\t         *\n\t         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x32WordArray = x64WordArray.toX32();\n\t         */\n\t        toX32: function () {\n\t            // Shortcuts\n\t            var x64Words = this.words;\n\t            var x64WordsLength = x64Words.length;\n\n\t            // Convert\n\t            var x32Words = [];\n\t            for (var i = 0; i < x64WordsLength; i++) {\n\t                var x64Word = x64Words[i];\n\t                x32Words.push(x64Word.high);\n\t                x32Words.push(x64Word.low);\n\t            }\n\n\t            return X32WordArray.create(x32Words, this.sigBytes);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {X64WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = x64WordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\n\t            // Clone \"words\" array\n\t            var words = clone.words = this.words.slice(0);\n\n\t            // Clone each X64Word object\n\t            var wordsLength = words.length;\n\t            for (var i = 0; i < wordsLength; i++) {\n\t                words[i] = words[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\t}());\n\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack:///./node_modules/crypto-js/x64-core.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/es5-ext/global.js":
/*!****************************************!*\
  !*** ./node_modules/es5-ext/global.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n\n\n//# sourceURL=webpack:///./node_modules/es5-ext/global.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/h264-profile-level-id/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('h264-profile-level-id');\n\n/* eslint-disable no-console */\ndebug.log = console.info.bind(console);\n/* eslint-enable no-console */\n\nconst ProfileConstrainedBaseline = 1;\nconst ProfileBaseline = 2;\nconst ProfileMain = 3;\nconst ProfileConstrainedHigh = 4;\nconst ProfileHigh = 5;\n\nexports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;\nexports.ProfileBaseline = ProfileBaseline;\nexports.ProfileMain = ProfileMain;\nexports.ProfileConstrainedHigh = ProfileConstrainedHigh;\nexports.ProfileHigh = ProfileHigh;\n\n// All values are equal to ten times the level number, except level 1b which is\n// special.\nconst Level1_b = 0;\nconst Level1 = 10;\nconst Level1_1 = 11;\nconst Level1_2 = 12;\nconst Level1_3 = 13;\nconst Level2 = 20;\nconst Level2_1 = 21;\nconst Level2_2 = 22;\nconst Level3 = 30;\nconst Level3_1 = 31;\nconst Level3_2 = 32;\nconst Level4 = 40;\nconst Level4_1 = 41;\nconst Level4_2 = 42;\nconst Level5 = 50;\nconst Level5_1 = 51;\nconst Level5_2 = 52;\n\nexports.Level1_b = Level1_b;\nexports.Level1 = Level1;\nexports.Level1_1 = Level1_1;\nexports.Level1_2 = Level1_2;\nexports.Level1_3 = Level1_3;\nexports.Level2 = Level2;\nexports.Level2_1 = Level2_1;\nexports.Level2_2 = Level2_2;\nexports.Level3 = Level3;\nexports.Level3_1 = Level3_1;\nexports.Level3_2 = Level3_2;\nexports.Level4 = Level4;\nexports.Level4_1 = Level4_1;\nexports.Level4_2 = Level4_2;\nexports.Level5 = Level5;\nexports.Level5_1 = Level5_1;\nexports.Level5_2 = Level5_2;\n\nclass ProfileLevelId\n{\n\tconstructor(profile, level)\n\t{\n\t\tthis.profile = profile;\n\t\tthis.level = level;\n\t}\n}\n\nexports.ProfileLevelId = ProfileLevelId;\n\n// Default ProfileLevelId.\n//\n// TODO: The default should really be profile Baseline and level 1 according to\n// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not\n// break backwards compatibility with older versions of WebRTC where external\n// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1\n// instead. This workaround will only be done in an interim period to allow\n// external clients to update their code.\n//\n// http://crbug/webrtc/6337.\nconst DefaultProfileLevelId =\n\tnew ProfileLevelId(ProfileConstrainedBaseline, Level3_1);\n\n// For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3\n// flag specifies if level 1b or level 1.1 is used.\nconst ConstraintSet3Flag = 0x10;\n\n// Class for matching bit patterns such as \"x1xx0000\" where 'x' is allowed to be\n// either 0 or 1.\nclass BitPattern\n{\n\tconstructor(str)\n\t{\n\t\tthis._mask = ~byteMaskString('x', str);\n\t\tthis._maskedValue = byteMaskString('1', str);\n\t}\n\n\tisMatch(value)\n\t{\n\t\treturn this._maskedValue === (value & this._mask);\n\t}\n}\n\n// Class for converting between profile_idc/profile_iop to Profile.\nclass ProfilePattern\n{\n\tconstructor(profile_idc, profile_iop, profile)\n\t{\n\t\tthis.profile_idc = profile_idc;\n\t\tthis.profile_iop = profile_iop;\n\t\tthis.profile = profile;\n\t}\n}\n\n// This is from https://tools.ietf.org/html/rfc6184#section-8.1.\nconst ProfilePatterns =\n[\n\tnew ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline),\n\tnew ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline),\n\tnew ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain),\n\tnew ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh),\n\tnew ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)\n];\n\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes.\n * Nothing will be returned if the string is not a recognized H264 profile\n * level id.\n *\n * @param {String} str - profile-level-id value as a string of 3 hex bytes.\n *\n * @returns {ProfileLevelId}\n */\nexports.parseProfileLevelId = function(str)\n{\n\t// The string should consist of 3 bytes in hexadecimal format.\n\tif (typeof str !== 'string' || str.length !== 6)\n\t\treturn null;\n\n\tconst profile_level_id_numeric = parseInt(str, 16);\n\n\tif (profile_level_id_numeric === 0)\n\t\treturn null;\n\n\t// Separate into three bytes.\n\tconst level_idc = profile_level_id_numeric & 0xFF;\n\tconst profile_iop = (profile_level_id_numeric >> 8) & 0xFF;\n\tconst profile_idc = (profile_level_id_numeric >> 16) & 0xFF;\n\n\t// Parse level based on level_idc and constraint set 3 flag.\n\tlet level;\n\n\tswitch (level_idc)\n\t{\n\t\tcase Level1_1:\n\t\t{\n\t\t\tlevel = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;\n\t\t\tbreak;\n\t\t}\n\t\tcase Level1:\n\t\tcase Level1_2:\n\t\tcase Level1_3:\n\t\tcase Level2:\n\t\tcase Level2_1:\n\t\tcase Level2_2:\n\t\tcase Level3:\n\t\tcase Level3_1:\n\t\tcase Level3_2:\n\t\tcase Level4:\n\t\tcase Level4_1:\n\t\tcase Level4_2:\n\t\tcase Level5:\n\t\tcase Level5_1:\n\t\tcase Level5_2:\n\t\t{\n\t\t\tlevel = level_idc;\n\t\t\tbreak;\n\t\t}\n\t\t// Unrecognized level_idc.\n\t\tdefault:\n\t\t{\n\t\t\tdebug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Parse profile_idc/profile_iop into a Profile enum.\n\tfor (const pattern of ProfilePatterns)\n\t{\n\t\tif (\n\t\t\tprofile_idc === pattern.profile_idc &&\n\t\t\tpattern.profile_iop.isMatch(profile_iop)\n\t\t)\n\t\t{\n\t\t\treturn new ProfileLevelId(pattern.profile, level);\n\t\t}\n\t}\n\n\tdebug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');\n\n\treturn null;\n};\n\n/**\n * Returns canonical string representation as three hex bytes of the profile\n * level id, or returns nothing for invalid profile level ids.\n *\n * @param {ProfileLevelId} profile_level_id\n *\n * @returns {String}\n */\nexports.profileLevelIdToString = function(profile_level_id)\n{\n\t// Handle special case level == 1b.\n\tif (profile_level_id.level == Level1_b)\n\t{\n\t\tswitch (profile_level_id.profile)\n\t\t{\n\t\t\tcase ProfileConstrainedBaseline:\n\t\t\t{\n\t\t\t\treturn '42f00b';\n\t\t\t}\n\t\t\tcase ProfileBaseline:\n\t\t\t{\n\t\t\t\treturn '42100b';\n\t\t\t}\n\t\t\tcase ProfileMain:\n\t\t\t{\n\t\t\t\treturn '4d100b';\n\t\t\t}\n\t\t\t// Level 1_b is not allowed for other profiles.\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tdebug(\n\t\t\t\t\t'profileLevelIdToString() | Level 1_b not is allowed for profile:%s',\n\t\t\t\t\tprofile_level_id.profile);\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet profile_idc_iop_string;\n\n\tswitch (profile_level_id.profile)\n\t{\n\t\tcase ProfileConstrainedBaseline:\n\t\t{\n\t\t\tprofile_idc_iop_string = '42e0';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileBaseline:\n\t\t{\n\t\t\tprofile_idc_iop_string = '4200';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileMain:\n\t\t{\n\t\t\tprofile_idc_iop_string = '4d00';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileConstrainedHigh:\n\t\t{\n\t\t\tprofile_idc_iop_string = '640c';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileHigh:\n\t\t{\n\t\t\tprofile_idc_iop_string = '6400';\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tdebug(\n\t\t\t\t'profileLevelIdToString() | unrecognized profile:%s',\n\t\t\t\tprofile_level_id.profile);\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tlet levelStr = (profile_level_id.level).toString(16);\n\n\tif (levelStr.length === 1)\n\t\tlevelStr = `0${levelStr}`;\n\n\treturn `${profile_idc_iop_string}${levelStr}`;\n};\n\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes\n * contained in an SDP key-value map. A default profile level id will be\n * returned if the profile-level-id key is missing. Nothing will be returned if\n * the key is present but the string is invalid.\n *\n * @param {Object} [params={}] - Codec parameters object.\n *\n * @returns {ProfileLevelId}\n */\nexports.parseSdpProfileLevelId = function(params = {})\n{\n\tconst profile_level_id = params['profile-level-id'];\n\n\treturn !profile_level_id\n\t\t? DefaultProfileLevelId\n\t\t: exports.parseProfileLevelId(profile_level_id);\n};\n\n/**\n * Returns true if the parameters have the same H264 profile, i.e. the same\n * H264 profile (Baseline, High, etc).\n *\n * @param {Object} [params1={}] - Codec parameters object.\n * @param {Object} [params2={}] - Codec parameters object.\n *\n * @returns {Boolean}\n */\nexports.isSameProfile = function(params1 = {}, params2 = {})\n{\n\tconst profile_level_id_1 = exports.parseSdpProfileLevelId(params1);\n\tconst profile_level_id_2 = exports.parseSdpProfileLevelId(params2);\n\n\t// Compare H264 profiles, but not levels.\n\treturn Boolean(\n\t\tprofile_level_id_1 &&\n\t\tprofile_level_id_2 &&\n\t\tprofile_level_id_1.profile === profile_level_id_2.profile\n\t);\n};\n\n/**\n * Generate codec parameters that will be used as answer in an SDP negotiation\n * based on local supported parameters and remote offered parameters. Both\n * local_supported_params and remote_offered_params represent sendrecv media\n * descriptions, i.e they are a mix of both encode and decode capabilities. In\n * theory, when the profile in local_supported_params represent a strict superset\n * of the profile in remote_offered_params, we could limit the profile in the\n * answer to the profile in remote_offered_params.\n *\n * However, to simplify the code, each supported H264 profile should be listed\n * explicitly in the list of local supported codecs, even if they are redundant.\n * Then each local codec in the list should be tested one at a time against the\n * remote codec, and only when the profiles are equal should this function be\n * called. Therefore, this function does not need to handle profile intersection,\n * and the profile of local_supported_params and remote_offered_params must be\n * equal before calling this function. The parameters that are used when\n * negotiating are the level part of profile-level-id and level-asymmetry-allowed.\n *\n * @param {Object} [local_supported_params={}]\n * @param {Object} [remote_offered_params={}]\n *\n * @returns {String} Canonical string representation as three hex bytes of the\n *   profile level id, or null if no one of the params have profile-level-id.\n *\n * @throws {TypeError} If Profile mismatch or invalid params.\n */\nexports.generateProfileLevelIdForAnswer = function(\n\tlocal_supported_params = {},\n\tremote_offered_params = {}\n)\n{\n\t// If both local and remote params do not contain profile-level-id, they are\n\t// both using the default profile. In this case, don't return anything.\n\tif (\n\t\t!local_supported_params['profile-level-id'] &&\n\t\t!remote_offered_params['profile-level-id']\n\t)\n\t{\n\t\tdebug(\n\t\t\t'generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');\n\n\t\treturn null;\n\t}\n\n\t// Parse profile-level-ids.\n\tconst local_profile_level_id =\n\t\texports.parseSdpProfileLevelId(local_supported_params);\n\tconst remote_profile_level_id =\n\t\texports.parseSdpProfileLevelId(remote_offered_params);\n\n\t// The local and remote codec must have valid and equal H264 Profiles.\n\tif (!local_profile_level_id)\n\t\tthrow new TypeError('invalid local_profile_level_id');\n\n\tif (!remote_profile_level_id)\n\t\tthrow new TypeError('invalid remote_profile_level_id');\n\n\tif (local_profile_level_id.profile !== remote_profile_level_id.profile)\n\t\tthrow new TypeError('H264 Profile mismatch');\n\n\t// Parse level information.\n\tconst level_asymmetry_allowed = (\n\t\tisLevelAsymmetryAllowed(local_supported_params) &&\n\t\tisLevelAsymmetryAllowed(remote_offered_params)\n\t);\n\n\tconst local_level = local_profile_level_id.level;\n\tconst remote_level = remote_profile_level_id.level;\n\tconst min_level = minLevel(local_level, remote_level);\n\n\t// Determine answer level. When level asymmetry is not allowed, level upgrade\n\t// is not allowed, i.e., the level in the answer must be equal to or lower\n\t// than the level in the offer.\n\tconst answer_level = level_asymmetry_allowed ? local_level : min_level;\n\n\tdebug(\n\t\t'generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]',\n\t\tlocal_profile_level_id.profile, answer_level);\n\n\t// Return the resulting profile-level-id for the answer parameters.\n\treturn exports.profileLevelIdToString(\n\t\tnew ProfileLevelId(local_profile_level_id.profile, answer_level));\n};\n\n// Convert a string of 8 characters into a byte where the positions containing\n// character c will have their bit set. For example, c = 'x', str = \"x1xx0000\"\n// will return 0b10110000.\nfunction byteMaskString(c, str)\n{\n\treturn (\n\t\t((str[0] === c) << 7) | ((str[1] === c) << 6) | ((str[2] === c) << 5) |\n\t\t((str[3] === c) << 4)\t| ((str[4] === c) << 3)\t| ((str[5] === c) << 2)\t|\n\t\t((str[6] === c) << 1)\t| ((str[7] === c) << 0)\n\t);\n}\n\n// Compare H264 levels and handle the level 1b case.\nfunction isLessLevel(a, b)\n{\n\tif (a === Level1_b)\n\t\treturn b !== Level1 && b !== Level1_b;\n\n\tif (b === Level1_b)\n\t\treturn a !== Level1;\n\n\treturn a < b;\n}\n\nfunction minLevel(a, b)\n{\n\treturn isLessLevel(a, b) ? a : b;\n}\n\nfunction isLevelAsymmetryAllowed(params = {})\n{\n\tconst level_asymmetry_allowed = params['level-asymmetry-allowed'];\n\n\treturn (\n\t\tlevel_asymmetry_allowed === 1 ||\n\t\tlevel_asymmetry_allowed === '1'\n\t);\n}\n\n\n//# sourceURL=webpack:///./node_modules/h264-profile-level-id/index.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/retry/index.js":
/*!*************************************!*\
  !*** ./node_modules/retry/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/retry */ \"./node_modules/retry/lib/retry.js\");\n\n//# sourceURL=webpack:///./node_modules/retry/index.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry.js":
/*!*****************************************!*\
  !*** ./node_modules/retry/lib/retry.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var RetryOperation = __webpack_require__(/*! ./retry_operation */ \"./node_modules/retry/lib/retry_operation.js\");\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry_operation.js":
/*!***************************************************!*\
  !*** ./node_modules/retry/lib/retry_operation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry_operation.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{\n    // b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding)\n          ? 'rtpmap:%d %s/%s/%s'\n          : o.rate\n            ? 'rtpmap:%d %s/%s'\n            : 'rtpmap:%d %s';\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null)\n          ? 'rtcp:%d %s IP%d %s'\n          : 'rtcp:%d';\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%s trr-int %d'\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null)\n          ? 'rtcp-fb:%s %s %s'\n          : 'rtcp-fb:%s %s';\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return (\n          'extmap:%d' +\n          (o.direction ? '/%s' : '%v') +\n          (o['encrypt-uri'] ? ' %s' : '%v') +\n          ' %s' +\n          (o.config ? ' %s' : '')\n        );\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: 'extmapAllowMixed',\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null)\n          ? 'crypto:%d %s %s %s'\n          : 'crypto:%d %s %s';\n      }\n    },\n    {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    },\n    {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'ptime:%d'\n    },\n    {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'maxptime:%d'\n    },\n    {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null)\n          ? 'sctpmap:%s %s %s'\n          : 'sctpmap:%s %s';\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        // a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        // recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        // a=simulcast:\n        '^simulcast:' +\n        // send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        // space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        // end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push:'tsRefClocks',\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: ['clksrc', 'clksrcExt'],\n      format: function (o) {\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name:'mediaClk',\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n      format: function (o) {\n        var str = 'mediaclk:';\n        str += (o.id != null ? 'id=%s %s' : '%v%s');\n        str += (o.mediaClockValue != null ? '=%s' : '');\n        str += (o.rateNumerator != null ? ' rate=%s' : '');\n        str += (o.rateDenominator != null ? '/%s' : '');\n        return str;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    },\n    {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    },\n    {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    },\n    {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    },\n    {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/grammar.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! ./parser */ \"./node_modules/sdp-transform/lib/parser.js\");\nvar writer = __webpack_require__(/*! ./writer */ \"./node_modules/sdp-transform/lib/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/index.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.toString().split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/parser.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/writer.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = __webpack_require__(/*! es5-ext/global */ \"./node_modules/es5-ext/global.js\");\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = __webpack_require__(/*! ./version */ \"./node_modules/websocket/lib/version.js\");\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n\n\n//# sourceURL=webpack:///./node_modules/websocket/lib/browser.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ../package.json */ \"./node_modules/websocket/package.json\").version;\n\n\n//# sourceURL=webpack:///./node_modules/websocket/lib/version.js?");

/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/*! exports provided: name, description, keywords, author, contributors, version, repository, homepage, engines, dependencies, devDependencies, config, scripts, main, directories, browser, license, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"websocket\\\",\\\"description\\\":\\\"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\\\",\\\"keywords\\\":[\\\"websocket\\\",\\\"websockets\\\",\\\"socket\\\",\\\"networking\\\",\\\"comet\\\",\\\"push\\\",\\\"RFC-6455\\\",\\\"realtime\\\",\\\"server\\\",\\\"client\\\"],\\\"author\\\":\\\"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\\\",\\\"contributors\\\":[\\\"Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\\\"],\\\"version\\\":\\\"1.0.34\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"https://github.com/theturtle32/WebSocket-Node.git\\\"},\\\"homepage\\\":\\\"https://github.com/theturtle32/WebSocket-Node\\\",\\\"engines\\\":{\\\"node\\\":\\\">=4.0.0\\\"},\\\"dependencies\\\":{\\\"bufferutil\\\":\\\"^4.0.1\\\",\\\"debug\\\":\\\"^2.2.0\\\",\\\"es5-ext\\\":\\\"^0.10.50\\\",\\\"typedarray-to-buffer\\\":\\\"^3.1.5\\\",\\\"utf-8-validate\\\":\\\"^5.0.2\\\",\\\"yaeti\\\":\\\"^0.0.6\\\"},\\\"devDependencies\\\":{\\\"buffer-equal\\\":\\\"^1.0.0\\\",\\\"gulp\\\":\\\"^4.0.2\\\",\\\"gulp-jshint\\\":\\\"^2.0.4\\\",\\\"jshint-stylish\\\":\\\"^2.2.1\\\",\\\"jshint\\\":\\\"^2.0.0\\\",\\\"tape\\\":\\\"^4.9.1\\\"},\\\"config\\\":{\\\"verbose\\\":false},\\\"scripts\\\":{\\\"test\\\":\\\"tape test/unit/*.js\\\",\\\"gulp\\\":\\\"gulp\\\"},\\\"main\\\":\\\"index\\\",\\\"directories\\\":{\\\"lib\\\":\\\"./lib\\\"},\\\"browser\\\":\\\"lib/browser.js\\\",\\\"license\\\":\\\"Apache-2.0\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/websocket/package.json?");

/***/ }),

/***/ "./src/Consumer.ts":
/*!*************************!*\
  !*** ./src/Consumer.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst logger = new Logger_1.Logger('Consumer');\r\nclass Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {\r\n        super();\r\n        this._closed = false;\r\n        logger.debug('constructor()');\r\n        this._id = id;\r\n        this._localId = localId;\r\n        this._producerId = producerId;\r\n        this._rtpReceiver = rtpReceiver;\r\n        this._track = track;\r\n        this._rtpParameters = rtpParameters;\r\n        this._paused = !track.enabled;\r\n        this._appData = appData;\r\n        this._onTrackEnded = this._onTrackEnded.bind(this);\r\n        this._handleTrack();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get localId() {\r\n        return this._localId;\r\n    }\r\n    get producerId() {\r\n        return this._producerId;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get kind() {\r\n        return this._track.kind;\r\n    }\r\n    get rtpReceiver() {\r\n        return this._rtpReceiver;\r\n    }\r\n    get track() {\r\n        return this._track;\r\n    }\r\n    get rtpParameters() {\r\n        return this._rtpParameters;\r\n    }\r\n    get paused() {\r\n        return this._paused;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._destroyTrack();\r\n        this.emit('@close');\r\n    }\r\n    transportClosed() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('transportClosed()');\r\n        this._closed = true;\r\n        this._destroyTrack();\r\n        this.safeEmit('transportclose');\r\n    }\r\n    getStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            return this.safeEmitAsPromise('@getstats');\r\n        });\r\n    }\r\n    pause() {\r\n        logger.debug('pause()');\r\n        if (this._closed) {\r\n            logger.error('pause() | Consumer closed');\r\n            return;\r\n        }\r\n        this._paused = true;\r\n        this._track.enabled = false;\r\n    }\r\n    resume() {\r\n        logger.debug('resume()');\r\n        if (this._closed) {\r\n            logger.error('resume() | Consumer closed');\r\n            return;\r\n        }\r\n        this._paused = false;\r\n        this._track.enabled = true;\r\n    }\r\n    _onTrackEnded() {\r\n        logger.debug('track \"ended\" event');\r\n        this.safeEmit('trackended');\r\n    }\r\n    _handleTrack() {\r\n        this._track.addEventListener('ended', this._onTrackEnded);\r\n    }\r\n    _destroyTrack() {\r\n        try {\r\n            this._track.removeEventListener('ended', this._onTrackEnded);\r\n            this._track.stop();\r\n        }\r\n        catch (error) { }\r\n    }\r\n}\r\nexports.Consumer = Consumer;\r\n\n\n//# sourceURL=webpack:///./src/Consumer.ts?");

/***/ }),

/***/ "./src/DataConsumer.ts":
/*!*****************************!*\
  !*** ./src/DataConsumer.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst logger = new Logger_1.Logger('DataConsumer');\r\nclass DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {\r\n        super();\r\n        this._closed = false;\r\n        logger.debug('constructor()');\r\n        this._id = id;\r\n        this._dataProducerId = dataProducerId;\r\n        this._dataChannel = dataChannel;\r\n        this._sctpStreamParameters = sctpStreamParameters;\r\n        this._appData = appData;\r\n        this._handleDataChannel();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get dataProducerId() {\r\n        return this._dataProducerId;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get sctpStreamParameters() {\r\n        return this._sctpStreamParameters;\r\n    }\r\n    get readyState() {\r\n        return this._dataChannel.readyState;\r\n    }\r\n    get label() {\r\n        return this._dataChannel.label;\r\n    }\r\n    get protocol() {\r\n        return this._dataChannel.protocol;\r\n    }\r\n    get binaryType() {\r\n        return this._dataChannel.binaryType;\r\n    }\r\n    set binaryType(binaryType) {\r\n        this._dataChannel.binaryType = binaryType;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._dataChannel.close();\r\n        this.emit('@close');\r\n    }\r\n    transportClosed() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('transportClosed()');\r\n        this._closed = true;\r\n        this._dataChannel.close();\r\n        this.safeEmit('transportclose');\r\n    }\r\n    _handleDataChannel() {\r\n        this._dataChannel.addEventListener('open', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.debug('DataChannel \"open\" event');\r\n            this.safeEmit('open');\r\n        });\r\n        this._dataChannel.addEventListener('error', (event) => {\r\n            if (this._closed)\r\n                return;\r\n            let { error } = event;\r\n            if (!error)\r\n                error = new Error('unknown DataChannel error');\r\n            if (error.errorDetail === 'sctp-failure') {\r\n                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\r\n            }\r\n            else {\r\n                logger.error('DataChannel \"error\" event: %o', error);\r\n            }\r\n            this.safeEmit('error', error);\r\n        });\r\n        this._dataChannel.addEventListener('close', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.warn('DataChannel \"close\" event');\r\n            this._closed = true;\r\n            this.emit('@close');\r\n            this.safeEmit('close');\r\n        });\r\n        this._dataChannel.addEventListener('message', (event) => {\r\n            if (this._closed)\r\n                return;\r\n            this.safeEmit('message', event.data);\r\n        });\r\n    }\r\n}\r\nexports.DataConsumer = DataConsumer;\r\n\n\n//# sourceURL=webpack:///./src/DataConsumer.ts?");

/***/ }),

/***/ "./src/DataProducer.ts":
/*!*****************************!*\
  !*** ./src/DataProducer.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst logger = new Logger_1.Logger('DataProducer');\r\nclass DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ id, dataChannel, sctpStreamParameters, appData }) {\r\n        super();\r\n        this._closed = false;\r\n        logger.debug('constructor()');\r\n        this._id = id;\r\n        this._dataChannel = dataChannel;\r\n        this._sctpStreamParameters = sctpStreamParameters;\r\n        this._appData = appData;\r\n        this._handleDataChannel();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get sctpStreamParameters() {\r\n        return this._sctpStreamParameters;\r\n    }\r\n    get readyState() {\r\n        return this._dataChannel.readyState;\r\n    }\r\n    get label() {\r\n        return this._dataChannel.label;\r\n    }\r\n    get protocol() {\r\n        return this._dataChannel.protocol;\r\n    }\r\n    get bufferedAmount() {\r\n        return this._dataChannel.bufferedAmount;\r\n    }\r\n    get bufferedAmountLowThreshold() {\r\n        return this._dataChannel.bufferedAmountLowThreshold;\r\n    }\r\n    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {\r\n        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._dataChannel.close();\r\n        this.emit('@close');\r\n    }\r\n    transportClosed() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('transportClosed()');\r\n        this._closed = true;\r\n        this._dataChannel.close();\r\n        this.safeEmit('transportclose');\r\n    }\r\n    send(data) {\r\n        logger.debug('send()');\r\n        if (this._closed)\r\n            throw new errors_1.InvalidStateError('closed');\r\n        this._dataChannel.send(data);\r\n    }\r\n    _handleDataChannel() {\r\n        this._dataChannel.addEventListener('open', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.debug('DataChannel \"open\" event');\r\n            this.safeEmit('open');\r\n        });\r\n        this._dataChannel.addEventListener('error', (event) => {\r\n            if (this._closed)\r\n                return;\r\n            let { error } = event;\r\n            if (!error)\r\n                error = new Error('unknown DataChannel error');\r\n            if (error.errorDetail === 'sctp-failure') {\r\n                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\r\n            }\r\n            else {\r\n                logger.error('DataChannel \"error\" event: %o', error);\r\n            }\r\n            this.safeEmit('error', error);\r\n        });\r\n        this._dataChannel.addEventListener('close', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.warn('DataChannel \"close\" event');\r\n            this._closed = true;\r\n            this.emit('@close');\r\n            this.safeEmit('close');\r\n        });\r\n        this._dataChannel.addEventListener('message', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.warn('DataChannel \"message\" event in a DataProducer, message discarded');\r\n        });\r\n        this._dataChannel.addEventListener('bufferedamountlow', () => {\r\n            if (this._closed)\r\n                return;\r\n            this.safeEmit('bufferedamountlow');\r\n        });\r\n    }\r\n}\r\nexports.DataProducer = DataProducer;\r\n\n\n//# sourceURL=webpack:///./src/DataProducer.ts?");

/***/ }),

/***/ "./src/Device.ts":
/*!***********************!*\
  !*** ./src/Device.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bowser = __importStar(__webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst ortc = __importStar(__webpack_require__(/*! ./ortc */ \"./src/ortc.ts\"));\r\nconst Transport_1 = __webpack_require__(/*! ./Transport */ \"./src/Transport.ts\");\r\nconst Chrome74_1 = __webpack_require__(/*! ./handlers/Chrome74 */ \"./src/handlers/Chrome74.ts\");\r\nconst Chrome70_1 = __webpack_require__(/*! ./handlers/Chrome70 */ \"./src/handlers/Chrome70.ts\");\r\nconst Chrome67_1 = __webpack_require__(/*! ./handlers/Chrome67 */ \"./src/handlers/Chrome67.ts\");\r\nconst Chrome55_1 = __webpack_require__(/*! ./handlers/Chrome55 */ \"./src/handlers/Chrome55.ts\");\r\nconst Firefox60_1 = __webpack_require__(/*! ./handlers/Firefox60 */ \"./src/handlers/Firefox60.ts\");\r\nconst Safari12_1 = __webpack_require__(/*! ./handlers/Safari12 */ \"./src/handlers/Safari12.ts\");\r\nconst Safari11_1 = __webpack_require__(/*! ./handlers/Safari11 */ \"./src/handlers/Safari11.ts\");\r\nconst Edge11_1 = __webpack_require__(/*! ./handlers/Edge11 */ \"./src/handlers/Edge11.ts\");\r\nconst ReactNative_1 = __webpack_require__(/*! ./handlers/ReactNative */ \"./src/handlers/ReactNative.ts\");\r\nconst logger = new Logger_1.Logger('Device');\r\nfunction detectDevice() {\r\n    if (typeof navigator === 'object' && navigator.product === 'ReactNative') {\r\n        if (typeof RTCPeerConnection === 'undefined') {\r\n            logger.warn('this._detectDevice() | unsupported ReactNative without RTCPeerConnection');\r\n            return undefined;\r\n        }\r\n        logger.debug('this._detectDevice() | ReactNative handler chosen');\r\n        return 'ReactNative';\r\n    }\r\n    else if (typeof navigator === 'object' && typeof navigator.userAgent === 'string') {\r\n        const ua = navigator.userAgent;\r\n        const browser = bowser.getParser(ua);\r\n        const engine = browser.getEngine();\r\n        if (browser.satisfies({ chrome: '>=74', chromium: '>=74' })) {\r\n            return 'Chrome74';\r\n        }\r\n        else if (browser.satisfies({ chrome: '>=70', chromium: '>=70' })) {\r\n            return 'Chrome70';\r\n        }\r\n        else if (browser.satisfies({ chrome: '>=67', chromium: '>=67' })) {\r\n            return 'Chrome67';\r\n        }\r\n        else if (browser.satisfies({ chrome: '>=55', chromium: '>=55' })) {\r\n            return 'Chrome55';\r\n        }\r\n        else if (browser.satisfies({ firefox: '>=60' })) {\r\n            return 'Firefox60';\r\n        }\r\n        else if (browser.satisfies({ safari: '>=12.0' }) &&\r\n            typeof RTCRtpTransceiver !== 'undefined' &&\r\n            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {\r\n            return 'Safari12';\r\n        }\r\n        else if (browser.satisfies({ safari: '>=11' })) {\r\n            return 'Safari11';\r\n        }\r\n        else if (browser.satisfies({ 'microsoft edge': '>=11' }) &&\r\n            browser.satisfies({ 'microsoft edge': '<=18' })) {\r\n            return 'Edge11';\r\n        }\r\n        else if (engine.name && engine.name.toLowerCase() === 'blink') {\r\n            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\\w+)/i);\r\n            if (match) {\r\n                const version = Number(match[1]);\r\n                if (version >= 74) {\r\n                    return 'Chrome74';\r\n                }\r\n                else if (version >= 70) {\r\n                    return 'Chrome70';\r\n                }\r\n                else if (version >= 67) {\r\n                    return 'Chrome67';\r\n                }\r\n                else {\r\n                    return 'Chrome55';\r\n                }\r\n            }\r\n            else {\r\n                return 'Chrome74';\r\n            }\r\n        }\r\n        else {\r\n            logger.warn('this._detectDevice() | browser not supported [name:%s, version:%s]', browser.getBrowserName(), browser.getBrowserVersion());\r\n            return undefined;\r\n        }\r\n    }\r\n    else {\r\n        logger.warn('this._detectDevice() | unknown device');\r\n        return undefined;\r\n    }\r\n}\r\nexports.detectDevice = detectDevice;\r\nclass Device {\r\n    constructor({ handlerName, handlerFactory, Handler } = {}) {\r\n        this._loaded = false;\r\n        logger.debug('constructor()');\r\n        if (Handler) {\r\n            logger.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead');\r\n            if (typeof Handler === 'string')\r\n                handlerName = Handler;\r\n            else\r\n                throw new TypeError('non string Handler option no longer supported, use handlerFactory instead');\r\n        }\r\n        if (handlerName && handlerFactory) {\r\n            throw new TypeError('just one of handlerName or handlerInterface can be given');\r\n        }\r\n        if (handlerFactory) {\r\n            this._handlerFactory = handlerFactory;\r\n        }\r\n        else {\r\n            if (handlerName) {\r\n                logger.debug('constructor() | handler given: %s', handlerName);\r\n            }\r\n            else {\r\n                handlerName = detectDevice();\r\n                if (handlerName)\r\n                    logger.debug('constructor() | detected handler: %s', handlerName);\r\n                else\r\n                    throw new errors_1.UnsupportedError('device not supported');\r\n            }\r\n            switch (handlerName) {\r\n                case 'Chrome74':\r\n                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();\r\n                    break;\r\n                case 'Chrome70':\r\n                    this._handlerFactory = Chrome70_1.Chrome70.createFactory();\r\n                    break;\r\n                case 'Chrome67':\r\n                    this._handlerFactory = Chrome67_1.Chrome67.createFactory();\r\n                    break;\r\n                case 'Chrome55':\r\n                    this._handlerFactory = Chrome55_1.Chrome55.createFactory();\r\n                    break;\r\n                case 'Firefox60':\r\n                    this._handlerFactory = Firefox60_1.Firefox60.createFactory();\r\n                    break;\r\n                case 'Safari12':\r\n                    this._handlerFactory = Safari12_1.Safari12.createFactory();\r\n                    break;\r\n                case 'Safari11':\r\n                    this._handlerFactory = Safari11_1.Safari11.createFactory();\r\n                    break;\r\n                case 'Edge11':\r\n                    this._handlerFactory = Edge11_1.Edge11.createFactory();\r\n                    break;\r\n                case 'ReactNative':\r\n                    this._handlerFactory = ReactNative_1.ReactNative.createFactory();\r\n                    break;\r\n                default:\r\n                    throw new TypeError(`unknown handlerName \"${handlerName}\"`);\r\n            }\r\n        }\r\n        const handler = this._handlerFactory();\r\n        this._handlerName = handler.name;\r\n        handler.close();\r\n        this._extendedRtpCapabilities = undefined;\r\n        this._recvRtpCapabilities = undefined;\r\n        this._canProduceByKind =\r\n            {\r\n                audio: false,\r\n                video: false\r\n            };\r\n        this._sctpCapabilities = undefined;\r\n    }\r\n    get handlerName() {\r\n        return this._handlerName;\r\n    }\r\n    get loaded() {\r\n        return this._loaded;\r\n    }\r\n    get rtpCapabilities() {\r\n        if (!this._loaded)\r\n            throw new errors_1.InvalidStateError('not loaded');\r\n        return this._recvRtpCapabilities;\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const handler = this._handlerFactory();\r\n            return yield handler.getNativeRtpCapabilities();\r\n        });\r\n    }\r\n    get sctpCapabilities() {\r\n        if (!this._loaded)\r\n            throw new errors_1.InvalidStateError('not loaded');\r\n        return this._sctpCapabilities;\r\n    }\r\n    load({ routerRtpCapabilities }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);\r\n            let handler;\r\n            try {\r\n                if (this._loaded)\r\n                    throw new errors_1.InvalidStateError('already loaded');\r\n                ortc.validateRtpCapabilities(routerRtpCapabilities);\r\n                handler = this._handlerFactory();\r\n                const nativeRtpCapabilities = yield handler.getNativeRtpCapabilities();\r\n                logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);\r\n                ortc.validateRtpCapabilities(nativeRtpCapabilities);\r\n                this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);\r\n                logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);\r\n                this._canProduceByKind.audio =\r\n                    ortc.canSend('audio', this._extendedRtpCapabilities);\r\n                this._canProduceByKind.video =\r\n                    ortc.canSend('video', this._extendedRtpCapabilities);\r\n                this._recvRtpCapabilities =\r\n                    ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);\r\n                ortc.validateRtpCapabilities(this._recvRtpCapabilities);\r\n                logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);\r\n                this._sctpCapabilities = yield handler.getNativeSctpCapabilities();\r\n                logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);\r\n                ortc.validateSctpCapabilities(this._sctpCapabilities);\r\n                logger.debug('load() succeeded');\r\n                this._loaded = true;\r\n                handler.close();\r\n            }\r\n            catch (error) {\r\n                if (handler)\r\n                    handler.close();\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    canProduce(kind) {\r\n        if (!this._loaded)\r\n            throw new errors_1.InvalidStateError('not loaded');\r\n        else if (kind !== 'audio' && kind !== 'video')\r\n            throw new TypeError(`invalid kind \"${kind}\"`);\r\n        return this._canProduceByKind[kind];\r\n    }\r\n    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\r\n        logger.debug('createSendTransport()');\r\n        return this._createTransport({\r\n            direction: 'send',\r\n            id: id,\r\n            iceParameters: iceParameters,\r\n            iceCandidates: iceCandidates,\r\n            dtlsParameters: dtlsParameters,\r\n            sctpParameters: sctpParameters,\r\n            iceServers: iceServers,\r\n            iceTransportPolicy: iceTransportPolicy,\r\n            additionalSettings: additionalSettings,\r\n            proprietaryConstraints: proprietaryConstraints,\r\n            appData: appData\r\n        });\r\n    }\r\n    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\r\n        logger.debug('createRecvTransport()');\r\n        return this._createTransport({\r\n            direction: 'recv',\r\n            id: id,\r\n            iceParameters: iceParameters,\r\n            iceCandidates: iceCandidates,\r\n            dtlsParameters: dtlsParameters,\r\n            sctpParameters: sctpParameters,\r\n            iceServers: iceServers,\r\n            iceTransportPolicy: iceTransportPolicy,\r\n            additionalSettings: additionalSettings,\r\n            proprietaryConstraints: proprietaryConstraints,\r\n            appData: appData\r\n        });\r\n    }\r\n    _createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\r\n        if (!this._loaded)\r\n            throw new errors_1.InvalidStateError('not loaded');\r\n        else if (typeof id !== 'string')\r\n            throw new TypeError('missing id');\r\n        else if (typeof iceParameters !== 'object')\r\n            throw new TypeError('missing iceParameters');\r\n        else if (!Array.isArray(iceCandidates))\r\n            throw new TypeError('missing iceCandidates');\r\n        else if (typeof dtlsParameters !== 'object')\r\n            throw new TypeError('missing dtlsParameters');\r\n        else if (sctpParameters && typeof sctpParameters !== 'object')\r\n            throw new TypeError('wrong sctpParameters');\r\n        else if (appData && typeof appData !== 'object')\r\n            throw new TypeError('if given, appData must be an object');\r\n        const transport = new Transport_1.Transport({\r\n            direction,\r\n            id,\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            iceServers,\r\n            iceTransportPolicy,\r\n            additionalSettings,\r\n            proprietaryConstraints,\r\n            appData,\r\n            handlerFactory: this._handlerFactory,\r\n            extendedRtpCapabilities: this._extendedRtpCapabilities,\r\n            canProduceByKind: this._canProduceByKind\r\n        });\r\n        return transport;\r\n    }\r\n}\r\nexports.Device = Device;\r\n\n\n//# sourceURL=webpack:///./src/Device.ts?");

/***/ }),

/***/ "./src/EnhancedEventEmitter.ts":
/*!*************************************!*\
  !*** ./src/EnhancedEventEmitter.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst logger = new Logger_1.Logger('EnhancedEventEmitter');\r\nclass EnhancedEventEmitter extends events_1.EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this.setMaxListeners(Infinity);\r\n    }\r\n    safeEmit(event, ...args) {\r\n        const numListeners = this.listenerCount(event);\r\n        try {\r\n            return this.emit(event, ...args);\r\n        }\r\n        catch (error) {\r\n            logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);\r\n            return Boolean(numListeners);\r\n        }\r\n    }\r\n    safeEmitAsPromise(event, ...args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return new Promise((resolve, reject) => (this.safeEmit(event, ...args, resolve, reject)));\r\n        });\r\n    }\r\n}\r\nexports.EnhancedEventEmitter = EnhancedEventEmitter;\r\n\n\n//# sourceURL=webpack:///./src/EnhancedEventEmitter.ts?");

/***/ }),

/***/ "./src/Logger.ts":
/*!***********************!*\
  !*** ./src/Logger.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"));\r\nconst APP_NAME = 'mcs8Media-client';\r\nclass Logger {\r\n    constructor(prefix) {\r\n        if (prefix) {\r\n            this._debug = debug_1.default(`${APP_NAME}:${prefix}`);\r\n            this._warn = debug_1.default(`${APP_NAME}:WARN:${prefix}`);\r\n            this._error = debug_1.default(`${APP_NAME}:ERROR:${prefix}`);\r\n        }\r\n        else {\r\n            this._debug = debug_1.default(APP_NAME);\r\n            this._warn = debug_1.default(`${APP_NAME}:WARN`);\r\n            this._error = debug_1.default(`${APP_NAME}:ERROR`);\r\n        }\r\n        this._debug.log = console.info.bind(console);\r\n        this._warn.log = console.warn.bind(console);\r\n        this._error.log = console.error.bind(console);\r\n    }\r\n    get debug() {\r\n        return this._debug;\r\n    }\r\n    get warn() {\r\n        return this._warn;\r\n    }\r\n    get error() {\r\n        return this._error;\r\n    }\r\n}\r\nexports.Logger = Logger;\r\n\n\n//# sourceURL=webpack:///./src/Logger.ts?");

/***/ }),

/***/ "./src/Producer.ts":
/*!*************************!*\
  !*** ./src/Producer.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst logger = new Logger_1.Logger('Producer');\r\nclass Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {\r\n        super();\r\n        this._closed = false;\r\n        logger.debug('constructor()');\r\n        this._id = id;\r\n        this._localId = localId;\r\n        this._rtpSender = rtpSender;\r\n        this._track = track;\r\n        this._kind = track.kind;\r\n        this._rtpParameters = rtpParameters;\r\n        this._paused = disableTrackOnPause ? !track.enabled : false;\r\n        this._maxSpatialLayer = undefined;\r\n        this._stopTracks = stopTracks;\r\n        this._disableTrackOnPause = disableTrackOnPause;\r\n        this._zeroRtpOnPause = zeroRtpOnPause;\r\n        this._appData = appData;\r\n        this._onTrackEnded = this._onTrackEnded.bind(this);\r\n        this._handleTrack();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get localId() {\r\n        return this._localId;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get kind() {\r\n        return this._kind;\r\n    }\r\n    get rtpSender() {\r\n        return this._rtpSender;\r\n    }\r\n    get track() {\r\n        return this._track;\r\n    }\r\n    get rtpParameters() {\r\n        return this._rtpParameters;\r\n    }\r\n    get paused() {\r\n        return this._paused;\r\n    }\r\n    get maxSpatialLayer() {\r\n        return this._maxSpatialLayer;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._destroyTrack();\r\n        this.emit('@close');\r\n    }\r\n    transportClosed() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('transportClosed()');\r\n        this._closed = true;\r\n        this._destroyTrack();\r\n        this.safeEmit('transportclose');\r\n    }\r\n    getStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            return this.safeEmitAsPromise('@getstats');\r\n        });\r\n    }\r\n    pause() {\r\n        logger.debug('pause()');\r\n        if (this._closed) {\r\n            logger.error('pause() | Producer closed');\r\n            return;\r\n        }\r\n        this._paused = true;\r\n        if (this._track && this._disableTrackOnPause) {\r\n            this._track.enabled = false;\r\n        }\r\n        if (this._zeroRtpOnPause) {\r\n            this.safeEmitAsPromise('@replacetrack', null)\r\n                .catch(() => { });\r\n        }\r\n    }\r\n    resume() {\r\n        logger.debug('resume()');\r\n        if (this._closed) {\r\n            logger.error('resume() | Producer closed');\r\n            return;\r\n        }\r\n        this._paused = false;\r\n        if (this._track && this._disableTrackOnPause) {\r\n            this._track.enabled = true;\r\n        }\r\n        if (this._zeroRtpOnPause) {\r\n            this.safeEmitAsPromise('@replacetrack', this._track)\r\n                .catch(() => { });\r\n        }\r\n    }\r\n    replaceTrack({ track }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('replaceTrack() [track:%o]', track);\r\n            if (this._closed) {\r\n                if (track && this._stopTracks) {\r\n                    try {\r\n                        track.stop();\r\n                    }\r\n                    catch (error) { }\r\n                }\r\n                throw new errors_1.InvalidStateError('closed');\r\n            }\r\n            else if (track && track.readyState === 'ended') {\r\n                throw new errors_1.InvalidStateError('track ended');\r\n            }\r\n            if (track === this._track) {\r\n                logger.debug('replaceTrack() | same track, ignored');\r\n                return;\r\n            }\r\n            if (!this._zeroRtpOnPause || !this._paused) {\r\n                yield this.safeEmitAsPromise('@replacetrack', track);\r\n            }\r\n            this._destroyTrack();\r\n            this._track = track;\r\n            if (this._track && this._disableTrackOnPause) {\r\n                if (!this._paused)\r\n                    this._track.enabled = true;\r\n                else if (this._paused)\r\n                    this._track.enabled = false;\r\n            }\r\n            this._handleTrack();\r\n        });\r\n    }\r\n    setMaxSpatialLayer(spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (this._kind !== 'video')\r\n                throw new errors_1.UnsupportedError('not a video Producer');\r\n            else if (typeof spatialLayer !== 'number')\r\n                throw new TypeError('invalid spatialLayer');\r\n            if (spatialLayer === this._maxSpatialLayer)\r\n                return;\r\n            yield this.safeEmitAsPromise('@setmaxspatiallayer', spatialLayer);\r\n            this._maxSpatialLayer = spatialLayer;\r\n        });\r\n    }\r\n    setRtpEncodingParameters(params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (typeof params !== 'object')\r\n                throw new TypeError('invalid params');\r\n            yield this.safeEmitAsPromise('@setrtpencodingparameters', params);\r\n        });\r\n    }\r\n    _onTrackEnded() {\r\n        logger.debug('track \"ended\" event');\r\n        this.safeEmit('trackended');\r\n    }\r\n    _handleTrack() {\r\n        if (!this._track)\r\n            return;\r\n        this._track.addEventListener('ended', this._onTrackEnded);\r\n    }\r\n    _destroyTrack() {\r\n        if (!this._track)\r\n            return;\r\n        try {\r\n            this._track.removeEventListener('ended', this._onTrackEnded);\r\n            if (this._stopTracks)\r\n                this._track.stop();\r\n        }\r\n        catch (error) { }\r\n    }\r\n}\r\nexports.Producer = Producer;\r\n\n\n//# sourceURL=webpack:///./src/Producer.ts?");

/***/ }),

/***/ "./src/Transport.ts":
/*!**************************!*\
  !*** ./src/Transport.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst awaitqueue_1 = __webpack_require__(/*! awaitqueue */ \"./node_modules/awaitqueue/lib/index.js\");\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ./ortc */ \"./src/ortc.ts\"));\r\nconst Producer_1 = __webpack_require__(/*! ./Producer */ \"./src/Producer.ts\");\r\nconst Consumer_1 = __webpack_require__(/*! ./Consumer */ \"./src/Consumer.ts\");\r\nconst DataProducer_1 = __webpack_require__(/*! ./DataProducer */ \"./src/DataProducer.ts\");\r\nconst DataConsumer_1 = __webpack_require__(/*! ./DataConsumer */ \"./src/DataConsumer.ts\");\r\nconst logger = new Logger_1.Logger('Transport');\r\nclass Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {\r\n        super();\r\n        this._closed = false;\r\n        this._connectionState = 'new';\r\n        this._producers = new Map();\r\n        this._consumers = new Map();\r\n        this._dataProducers = new Map();\r\n        this._dataConsumers = new Map();\r\n        this._probatorConsumerCreated = false;\r\n        this._awaitQueue = new awaitqueue_1.AwaitQueue({ ClosedErrorClass: errors_1.InvalidStateError });\r\n        logger.debug('constructor() [id:%s, direction:%s]', id, direction);\r\n        this._id = id;\r\n        this._direction = direction;\r\n        this._extendedRtpCapabilities = extendedRtpCapabilities;\r\n        this._canProduceByKind = canProduceByKind;\r\n        this._maxSctpMessageSize =\r\n            sctpParameters ? sctpParameters.maxMessageSize : null;\r\n        additionalSettings = utils.clone(additionalSettings);\r\n        delete additionalSettings.iceServers;\r\n        delete additionalSettings.iceTransportPolicy;\r\n        delete additionalSettings.bundlePolicy;\r\n        delete additionalSettings.rtcpMuxPolicy;\r\n        delete additionalSettings.sdpSemantics;\r\n        this._handler = handlerFactory();\r\n        this._handler.run({\r\n            direction,\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            iceServers,\r\n            iceTransportPolicy,\r\n            additionalSettings,\r\n            proprietaryConstraints,\r\n            extendedRtpCapabilities\r\n        });\r\n        this._appData = appData;\r\n        this._handleHandler();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get direction() {\r\n        return this._direction;\r\n    }\r\n    get handler() {\r\n        return this._handler;\r\n    }\r\n    get connectionState() {\r\n        return this._connectionState;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._awaitQueue.close();\r\n        this._handler.close();\r\n        for (const producer of this._producers.values()) {\r\n            producer.transportClosed();\r\n        }\r\n        this._producers.clear();\r\n        for (const consumer of this._consumers.values()) {\r\n            consumer.transportClosed();\r\n        }\r\n        this._consumers.clear();\r\n        for (const dataProducer of this._dataProducers.values()) {\r\n            dataProducer.transportClosed();\r\n        }\r\n        this._dataProducers.clear();\r\n        for (const dataConsumer of this._dataConsumers.values()) {\r\n            dataConsumer.transportClosed();\r\n        }\r\n        this._dataConsumers.clear();\r\n    }\r\n    getStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            return this._handler.getTransportStats();\r\n        });\r\n    }\r\n    restartIce({ iceParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (!iceParameters)\r\n                throw new TypeError('missing iceParameters');\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.restartIce(iceParameters); }));\r\n        });\r\n    }\r\n    updateIceServers({ iceServers } = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (!Array.isArray(iceServers))\r\n                throw new TypeError('missing iceServers');\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.updateIceServers(iceServers); }));\r\n        });\r\n    }\r\n    produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('produce() [track:%o]', track);\r\n            if (!track)\r\n                throw new TypeError('missing track');\r\n            else if (this._direction !== 'send')\r\n                throw new errors_1.UnsupportedError('not a sending Transport');\r\n            else if (!this._canProduceByKind[track.kind])\r\n                throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);\r\n            else if (track.readyState === 'ended')\r\n                throw new errors_1.InvalidStateError('track ended');\r\n            else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\r\n                throw new TypeError('no \"connect\" listener set into this transport');\r\n            else if (this.listenerCount('produce') === 0)\r\n                throw new TypeError('no \"produce\" listener set into this transport');\r\n            else if (appData && typeof appData !== 'object')\r\n                throw new TypeError('if given, appData must be an object');\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                let normalizedEncodings;\r\n                if (encodings && !Array.isArray(encodings)) {\r\n                    throw TypeError('encodings must be an array');\r\n                }\r\n                else if (encodings && encodings.length === 0) {\r\n                    normalizedEncodings = undefined;\r\n                }\r\n                else if (encodings) {\r\n                    normalizedEncodings = encodings\r\n                        .map((encoding) => {\r\n                        const normalizedEncoding = { active: true };\r\n                        if (encoding.active === false)\r\n                            normalizedEncoding.active = false;\r\n                        if (typeof encoding.dtx === 'boolean')\r\n                            normalizedEncoding.dtx = encoding.dtx;\r\n                        if (typeof encoding.scalabilityMode === 'string')\r\n                            normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\r\n                        if (typeof encoding.scaleResolutionDownBy === 'number')\r\n                            normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\r\n                        if (typeof encoding.maxBitrate === 'number')\r\n                            normalizedEncoding.maxBitrate = encoding.maxBitrate;\r\n                        if (typeof encoding.maxFramerate === 'number')\r\n                            normalizedEncoding.maxFramerate = encoding.maxFramerate;\r\n                        if (typeof encoding.adaptivePtime === 'boolean')\r\n                            normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\r\n                        if (typeof encoding.priority === 'string')\r\n                            normalizedEncoding.priority = encoding.priority;\r\n                        if (typeof encoding.networkPriority === 'string')\r\n                            normalizedEncoding.networkPriority = encoding.networkPriority;\r\n                        return normalizedEncoding;\r\n                    });\r\n                }\r\n                const { localId, rtpParameters, rtpSender } = yield this._handler.send({\r\n                    track,\r\n                    encodings: normalizedEncodings,\r\n                    codecOptions,\r\n                    codec\r\n                });\r\n                try {\r\n                    ortc.validateRtpParameters(rtpParameters);\r\n                    const { id } = yield this.safeEmitAsPromise('produce', {\r\n                        kind: track.kind,\r\n                        rtpParameters,\r\n                        appData\r\n                    });\r\n                    const producer = new Producer_1.Producer({\r\n                        id,\r\n                        localId,\r\n                        rtpSender,\r\n                        track,\r\n                        rtpParameters,\r\n                        stopTracks,\r\n                        disableTrackOnPause,\r\n                        zeroRtpOnPause,\r\n                        appData\r\n                    });\r\n                    this._producers.set(producer.id, producer);\r\n                    this._handleProducer(producer);\r\n                    return producer;\r\n                }\r\n                catch (error) {\r\n                    this._handler.stopSending(localId)\r\n                        .catch(() => { });\r\n                    throw error;\r\n                }\r\n            }))\r\n                .catch((error) => {\r\n                if (stopTracks) {\r\n                    try {\r\n                        track.stop();\r\n                    }\r\n                    catch (error2) { }\r\n                }\r\n                throw error;\r\n            });\r\n        });\r\n    }\r\n    consume({ id, producerId, kind, rtpParameters, appData = {} }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('consume()');\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (this._direction !== 'recv')\r\n                throw new errors_1.UnsupportedError('not a receiving Transport');\r\n            else if (typeof id !== 'string')\r\n                throw new TypeError('missing id');\r\n            else if (typeof producerId !== 'string')\r\n                throw new TypeError('missing producerId');\r\n            else if (kind !== 'audio' && kind !== 'video')\r\n                throw new TypeError(`invalid kind '${kind}'`);\r\n            else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\r\n                throw new TypeError('no \"connect\" listener set into this transport');\r\n            else if (appData && typeof appData !== 'object')\r\n                throw new TypeError('if given, appData must be an object');\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                const { localId, rtpReceiver, track } = yield this._handler.receive({ trackId: id, kind, rtpParameters });\r\n                const consumer = new Consumer_1.Consumer({\r\n                    id,\r\n                    localId,\r\n                    producerId,\r\n                    rtpReceiver,\r\n                    track,\r\n                    rtpParameters,\r\n                    appData\r\n                });\r\n                this._consumers.set(consumer.id, consumer);\r\n                this._handleConsumer(consumer);\r\n                if (!this._probatorConsumerCreated && kind === 'video') {\r\n                    try {\r\n                        const probatorRtpParameters = ortc.generateProbatorRtpParameters(consumer.rtpParameters);\r\n                        yield this._handler.receive({\r\n                            trackId: 'probator',\r\n                            kind: 'video',\r\n                            rtpParameters: probatorRtpParameters\r\n                        });\r\n                        logger.debug('consume() | Consumer for RTP probation created');\r\n                        this._probatorConsumerCreated = true;\r\n                    }\r\n                    catch (error) {\r\n                        logger.error('consume() | failed to create Consumer for RTP probation:%o', error);\r\n                    }\r\n                }\r\n                return consumer;\r\n            }));\r\n        });\r\n    }\r\n    produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, priority = 'low', label = '', protocol = '', appData = {} } = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('produceData()');\r\n            if (this._direction !== 'send')\r\n                throw new errors_1.UnsupportedError('not a sending Transport');\r\n            else if (!this._maxSctpMessageSize)\r\n                throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\r\n            else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\r\n                throw new TypeError('no \"connect\" listener set into this transport');\r\n            else if (this.listenerCount('producedata') === 0)\r\n                throw new TypeError('no \"producedata\" listener set into this transport');\r\n            else if (appData && typeof appData !== 'object')\r\n                throw new TypeError('if given, appData must be an object');\r\n            if (maxPacketLifeTime || maxRetransmits)\r\n                ordered = false;\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                const { dataChannel, sctpStreamParameters } = yield this._handler.sendDataChannel({\r\n                    ordered,\r\n                    maxPacketLifeTime,\r\n                    maxRetransmits,\r\n                    priority,\r\n                    label,\r\n                    protocol\r\n                });\r\n                ortc.validateSctpStreamParameters(sctpStreamParameters);\r\n                const { id } = yield this.safeEmitAsPromise('producedata', {\r\n                    sctpStreamParameters,\r\n                    label,\r\n                    protocol,\r\n                    appData\r\n                });\r\n                const dataProducer = new DataProducer_1.DataProducer({ id, dataChannel, sctpStreamParameters, appData });\r\n                this._dataProducers.set(dataProducer.id, dataProducer);\r\n                this._handleDataProducer(dataProducer);\r\n                return dataProducer;\r\n            }));\r\n        });\r\n    }\r\n    consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {} }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('consumeData()');\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (this._direction !== 'recv')\r\n                throw new errors_1.UnsupportedError('not a receiving Transport');\r\n            else if (!this._maxSctpMessageSize)\r\n                throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\r\n            else if (typeof id !== 'string')\r\n                throw new TypeError('missing id');\r\n            else if (typeof dataProducerId !== 'string')\r\n                throw new TypeError('missing dataProducerId');\r\n            else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\r\n                throw new TypeError('no \"connect\" listener set into this transport');\r\n            else if (appData && typeof appData !== 'object')\r\n                throw new TypeError('if given, appData must be an object');\r\n            ortc.validateSctpStreamParameters(sctpStreamParameters);\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                const { dataChannel } = yield this._handler.receiveDataChannel({\r\n                    sctpStreamParameters,\r\n                    label,\r\n                    protocol\r\n                });\r\n                const dataConsumer = new DataConsumer_1.DataConsumer({\r\n                    id,\r\n                    dataProducerId,\r\n                    dataChannel,\r\n                    sctpStreamParameters,\r\n                    appData\r\n                });\r\n                this._dataConsumers.set(dataConsumer.id, dataConsumer);\r\n                this._handleDataConsumer(dataConsumer);\r\n                return dataConsumer;\r\n            }));\r\n        });\r\n    }\r\n    _handleHandler() {\r\n        const handler = this._handler;\r\n        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {\r\n            if (this._closed) {\r\n                errback(new errors_1.InvalidStateError('closed'));\r\n                return;\r\n            }\r\n            this.safeEmit('connect', { dtlsParameters }, callback, errback);\r\n        });\r\n        handler.on('@connectionstatechange', (connectionState) => {\r\n            if (connectionState === this._connectionState)\r\n                return;\r\n            logger.debug('connection state changed to %s', connectionState);\r\n            this._connectionState = connectionState;\r\n            if (!this._closed)\r\n                this.safeEmit('connectionstatechange', connectionState);\r\n        });\r\n    }\r\n    _handleProducer(producer) {\r\n        producer.on('@close', () => {\r\n            this._producers.delete(producer.id);\r\n            if (this._closed)\r\n                return;\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.stopSending(producer.localId); }))\r\n                .catch((error) => logger.warn('producer.close() failed:%o', error));\r\n        });\r\n        producer.on('@replacetrack', (track, callback, errback) => {\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.replaceTrack(producer.localId, track); }))\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                return (this._handler.setMaxSpatialLayer(producer.localId, spatialLayer));\r\n            }))\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n        producer.on('@setrtpencodingparameters', (params, callback, errback) => {\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                return (this._handler.setRtpEncodingParameters(producer.localId, params));\r\n            }))\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n        producer.on('@getstats', (callback, errback) => {\r\n            if (this._closed)\r\n                return errback(new errors_1.InvalidStateError('closed'));\r\n            this._handler.getSenderStats(producer.localId)\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n    }\r\n    _handleConsumer(consumer) {\r\n        consumer.on('@close', () => {\r\n            this._consumers.delete(consumer.id);\r\n            if (this._closed)\r\n                return;\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.stopReceiving(consumer.localId); }))\r\n                .catch(() => { });\r\n        });\r\n        consumer.on('@getstats', (callback, errback) => {\r\n            if (this._closed)\r\n                return errback(new errors_1.InvalidStateError('closed'));\r\n            this._handler.getReceiverStats(consumer.localId)\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n    }\r\n    _handleDataProducer(dataProducer) {\r\n        dataProducer.on('@close', () => {\r\n            this._dataProducers.delete(dataProducer.id);\r\n        });\r\n    }\r\n    _handleDataConsumer(dataConsumer) {\r\n        dataConsumer.on('@close', () => {\r\n            this._dataConsumers.delete(dataConsumer.id);\r\n        });\r\n    }\r\n}\r\nexports.Transport = Transport;\r\n\n\n//# sourceURL=webpack:///./src/Transport.ts?");

/***/ }),

/***/ "./src/errors.ts":
/*!***********************!*\
  !*** ./src/errors.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass UnsupportedError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'UnsupportedError';\r\n        if (Error.hasOwnProperty('captureStackTrace')) {\r\n            Error.captureStackTrace(this, UnsupportedError);\r\n        }\r\n        else {\r\n            this.stack = (new Error(message)).stack;\r\n        }\r\n    }\r\n}\r\nexports.UnsupportedError = UnsupportedError;\r\nclass InvalidStateError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'InvalidStateError';\r\n        if (Error.hasOwnProperty('captureStackTrace')) {\r\n            Error.captureStackTrace(this, InvalidStateError);\r\n        }\r\n        else {\r\n            this.stack = (new Error(message)).stack;\r\n        }\r\n    }\r\n}\r\nexports.InvalidStateError = InvalidStateError;\r\n\n\n//# sourceURL=webpack:///./src/errors.ts?");

/***/ }),

/***/ "./src/handlers/Chrome55.ts":
/*!**********************************!*\
  !*** ./src/handlers/Chrome55.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"./src/handlers/sdp/planBUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Chrome55');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Chrome55 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._sendStream = new MediaStream();\r\n        this._mapSendLocalIdTrack = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._mapRecvLocalIdInfo = new Map();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Chrome55();\r\n    }\r\n    get name() {\r\n        return 'Chrome55';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'plan-b'\r\n            });\r\n            try {\r\n                const offer = yield pc.createOffer({\r\n                    offerToReceiveAudio: true,\r\n                    offerToReceiveVideo: true\r\n                });\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            planB: true\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (codec) {\r\n                logger.warn('send() | codec selection is not available in %s handler', this.name);\r\n            }\r\n            this._sendStream.addTrack(track);\r\n            this._pc.addStream(this._sendStream);\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (track.kind === 'video' && encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\r\n                sdpPlanBUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    track,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media\r\n                .find((m) => m.type === track.kind);\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            this._mapSendLocalIdTrack.set(localId, track);\r\n            return {\r\n                localId: localId,\r\n                rtpParameters: sendingRtpParameters\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const track = this._mapSendLocalIdTrack.get(localId);\r\n            if (!track)\r\n                throw new Error('track not found');\r\n            this._mapSendLocalIdTrack.delete(localId);\r\n            this._sendStream.removeTrack(track);\r\n            this._pc.addStream(this._sendStream);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            try {\r\n                yield this._pc.setLocalDescription(offer);\r\n            }\r\n            catch (error) {\r\n                if (this._sendStream.getTracks().length === 0) {\r\n                    logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n            if (this._pc.signalingState === 'stable')\r\n                return;\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError(' not implemented');\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not supported');\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = trackId;\r\n            const mid = kind;\r\n            const streamId = rtpParameters.rtcp.cname;\r\n            this._remoteSdp.receive({\r\n                mid,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === mid);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const stream = this._pc.getRemoteStreams()\r\n                .find((s) => s.id === streamId);\r\n            const track = stream.getTrackById(localId);\r\n            if (!track)\r\n                throw new Error('remote track not found');\r\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\r\n            return { localId, track };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            this._mapRecvLocalIdInfo.delete(localId);\r\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Chrome55 = Chrome55;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Chrome55.ts?");

/***/ }),

/***/ "./src/handlers/Chrome67.ts":
/*!**********************************!*\
  !*** ./src/handlers/Chrome67.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"./src/handlers/sdp/planBUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Chrome67');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Chrome67 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._sendStream = new MediaStream();\r\n        this._mapSendLocalIdRtpSender = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._mapRecvLocalIdInfo = new Map();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Chrome67();\r\n    }\r\n    get name() {\r\n        return 'Chrome67';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'plan-b'\r\n            });\r\n            try {\r\n                const offer = yield pc.createOffer({\r\n                    offerToReceiveAudio: true,\r\n                    offerToReceiveVideo: true\r\n                });\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            planB: true\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (codec) {\r\n                logger.warn('send() | codec selection is not available in %s handler', this.name);\r\n            }\r\n            this._sendStream.addTrack(track);\r\n            this._pc.addTrack(track, this._sendStream);\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (track.kind === 'video' && encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'video');\r\n                sdpPlanBUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    track,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media\r\n                .find((m) => m.type === track.kind);\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            const rtpSender = this._pc.getSenders()\r\n                .find((s) => s.track === track);\r\n            this._mapSendLocalIdRtpSender.set(localId, rtpSender);\r\n            return {\r\n                localId: localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            this._pc.removeTrack(rtpSender);\r\n            if (rtpSender.track)\r\n                this._sendStream.removeTrack(rtpSender.track);\r\n            this._mapSendLocalIdRtpSender.delete(localId);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            try {\r\n                yield this._pc.setLocalDescription(offer);\r\n            }\r\n            catch (error) {\r\n                if (this._sendStream.getTracks().length === 0) {\r\n                    logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n            if (this._pc.signalingState === 'stable')\r\n                return;\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const oldTrack = rtpSender.track;\r\n            yield rtpSender.replaceTrack(track);\r\n            if (oldTrack)\r\n                this._sendStream.removeTrack(oldTrack);\r\n            if (track)\r\n                this._sendStream.addTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            return rtpSender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = trackId;\r\n            const mid = kind;\r\n            this._remoteSdp.receive({\r\n                mid,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === mid);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const rtpReceiver = this._pc.getReceivers()\r\n                .find((r) => r.track && r.track.id === localId);\r\n            if (!rtpReceiver)\r\n                throw new Error('new RTCRtpReceiver not');\r\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });\r\n            return {\r\n                localId,\r\n                track: rtpReceiver.track,\r\n                rtpReceiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            this._mapRecvLocalIdInfo.delete(localId);\r\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            if (!rtpReceiver)\r\n                throw new Error('associated RTCRtpReceiver not found');\r\n            return rtpReceiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Chrome67 = Chrome67;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Chrome67.ts?");

/***/ }),

/***/ "./src/handlers/Chrome70.ts":
/*!**********************************!*\
  !*** ./src/handlers/Chrome70.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./src/handlers/sdp/unifiedPlanUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"./src/scalabilityModes.ts\");\r\nconst logger = new Logger_1.Logger('Chrome70');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Chrome70 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._mapMidTransceiver = new Map();\r\n        this._sendStream = new MediaStream();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Chrome70();\r\n    }\r\n    get name() {\r\n        return 'Chrome70';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'unified-plan'\r\n            });\r\n            try {\r\n                pc.addTransceiver('audio');\r\n                pc.addTransceiver('video');\r\n                const offer = yield pc.createOffer();\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\r\n            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\r\n            const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling legacy simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n                sdpUnifiedPlanUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            let hackVp9Svc = false;\r\n            const layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);\r\n            if (encodings &&\r\n                encodings.length === 1 &&\r\n                layers.spatialLayers > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\r\n                logger.debug('send() | enabling legacy simulcast for VP9 SVC');\r\n                hackVp9Svc = true;\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n                sdpUnifiedPlanUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    numStreams: layers.spatialLayers\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            if (encodings) {\r\n                logger.debug('send() | applying given encodings');\r\n                const parameters = transceiver.sender.getParameters();\r\n                for (let idx = 0; idx < (parameters.encodings || []).length; ++idx) {\r\n                    const encoding = parameters.encodings[idx];\r\n                    const desiredEncoding = encodings[idx];\r\n                    if (!desiredEncoding)\r\n                        break;\r\n                    parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);\r\n                }\r\n                yield transceiver.sender.setParameters(parameters);\r\n            }\r\n            const localId = transceiver.mid;\r\n            sendingRtpParameters.mid = localId;\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (hackVp9Svc) {\r\n                sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                reuseMid: mediaSectionIdx.reuseMid,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender: transceiver.sender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            transceiver.sender.replaceTrack(null);\r\n            this._pc.removeTrack(transceiver.sender);\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            yield transceiver.sender.replaceTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.sender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\r\n            this._remoteSdp.receive({\r\n                mid: localId,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === localId);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const transceiver = this._pc.getTransceivers()\r\n                .find((t) => t.mid === localId);\r\n            if (!transceiver)\r\n                throw new Error('new RTCRtpTransceiver not found');\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                track: transceiver.receiver.track,\r\n                rtpReceiver: transceiver.receiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.receiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation();\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Chrome70 = Chrome70;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Chrome70.ts?");

/***/ }),

/***/ "./src/handlers/Chrome74.ts":
/*!**********************************!*\
  !*** ./src/handlers/Chrome74.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./src/handlers/sdp/unifiedPlanUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"./src/scalabilityModes.ts\");\r\nconst logger = new Logger_1.Logger('Chrome74');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Chrome74 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._mapMidTransceiver = new Map();\r\n        this._sendStream = new MediaStream();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Chrome74();\r\n    }\r\n    get name() {\r\n        return 'Chrome74';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'unified-plan'\r\n            });\r\n            try {\r\n                pc.addTransceiver('audio');\r\n                pc.addTransceiver('video');\r\n                const offer = yield pc.createOffer();\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (encodings && encodings.length > 1) {\r\n                encodings.forEach((encoding, idx) => {\r\n                    encoding.rid = `r${idx}`;\r\n                });\r\n            }\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\r\n            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\r\n            const transceiver = this._pc.addTransceiver(track, {\r\n                direction: 'sendonly',\r\n                streams: [this._sendStream],\r\n                sendEncodings: encodings\r\n            });\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            let hackVp9Svc = false;\r\n            const layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);\r\n            if (encodings &&\r\n                encodings.length === 1 &&\r\n                layers.spatialLayers > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\r\n                logger.debug('send() | enabling legacy simulcast for VP9 SVC');\r\n                hackVp9Svc = true;\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n                sdpUnifiedPlanUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    numStreams: layers.spatialLayers\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const localId = transceiver.mid;\r\n            sendingRtpParameters.mid = localId;\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            if (!encodings) {\r\n                sendingRtpParameters.encodings =\r\n                    sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n            }\r\n            else if (encodings.length === 1) {\r\n                let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n                Object.assign(newEncodings[0], encodings[0]);\r\n                if (hackVp9Svc)\r\n                    newEncodings = [newEncodings[0]];\r\n                sendingRtpParameters.encodings = newEncodings;\r\n            }\r\n            else {\r\n                sendingRtpParameters.encodings = encodings;\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                reuseMid: mediaSectionIdx.reuseMid,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions,\r\n                extmapAllowMixed: true\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender: transceiver.sender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            transceiver.sender.replaceTrack(null);\r\n            this._pc.removeTrack(transceiver.sender);\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            yield transceiver.sender.replaceTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.sender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\r\n            this._remoteSdp.receive({\r\n                mid: localId,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === localId);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const transceiver = this._pc.getTransceivers()\r\n                .find((t) => t.mid === localId);\r\n            if (!transceiver)\r\n                throw new Error('new RTCRtpTransceiver not found');\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                track: transceiver.receiver.track,\r\n                rtpReceiver: transceiver.receiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.receiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation();\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Chrome74 = Chrome74;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Chrome74.ts?");

/***/ }),

/***/ "./src/handlers/Edge11.ts":
/*!********************************!*\
  !*** ./src/handlers/Edge11.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst edgeUtils = __importStar(__webpack_require__(/*! ./ortc/edgeUtils */ \"./src/handlers/ortc/edgeUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst logger = new Logger_1.Logger('Edge11');\r\nclass Edge11 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._rtpSenders = new Map();\r\n        this._rtpReceivers = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Edge11();\r\n    }\r\n    get name() {\r\n        return 'Edge11';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        try {\r\n            this._iceGatherer.close();\r\n        }\r\n        catch (error) { }\r\n        try {\r\n            this._iceTransport.stop();\r\n        }\r\n        catch (error) { }\r\n        try {\r\n            this._dtlsTransport.stop();\r\n        }\r\n        catch (error) { }\r\n        for (const rtpSender of this._rtpSenders.values()) {\r\n            try {\r\n                rtpSender.stop();\r\n            }\r\n            catch (error) { }\r\n        }\r\n        for (const rtpReceiver of this._rtpReceivers.values()) {\r\n            try {\r\n                rtpReceiver.stop();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            return edgeUtils.getCapabilities();\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: { OS: 0, MIS: 0 }\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._remoteIceParameters = iceParameters;\r\n        this._remoteIceCandidates = iceCandidates;\r\n        this._remoteDtlsParameters = dtlsParameters;\r\n        this._cname = `CNAME-${utils.generateRandomNumber()}`;\r\n        this._setIceGatherer({ iceServers, iceTransportPolicy });\r\n        this._setIceTransport();\r\n        this._setDtlsTransport();\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not supported');\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteIceParameters = iceParameters;\r\n            if (!this._transportReady)\r\n                return;\r\n            logger.debug('restartIce() | calling iceTransport.start()');\r\n            this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');\r\n            for (const candidate of this._remoteIceCandidates) {\r\n                this._iceTransport.addRemoteCandidate(candidate);\r\n            }\r\n            this._iceTransport.addRemoteCandidate({});\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._iceTransport.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server' });\r\n            logger.debug('send() | calling new RTCRtpSender()');\r\n            const rtpSender = new RTCRtpSender(track, this._dtlsTransport);\r\n            const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);\r\n            const useRtx = rtpParameters.codecs\r\n                .some((_codec) => /.+\\/rtx$/i.test(_codec.mimeType));\r\n            if (!encodings)\r\n                encodings = [{}];\r\n            for (const encoding of encodings) {\r\n                encoding.ssrc = utils.generateRandomNumber();\r\n                if (useRtx)\r\n                    encoding.rtx = { ssrc: utils.generateRandomNumber() };\r\n            }\r\n            rtpParameters.encodings = encodings;\r\n            rtpParameters.rtcp =\r\n                {\r\n                    cname: this._cname,\r\n                    reducedSize: true,\r\n                    mux: true\r\n                };\r\n            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\r\n            logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);\r\n            yield rtpSender.send(edgeRtpParameters);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            this._rtpSenders.set(localId, rtpSender);\r\n            return { localId, rtpParameters, rtpSender };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            this._rtpSenders.delete(localId);\r\n            try {\r\n                logger.debug('stopSending() | calling rtpSender.stop()');\r\n                rtpSender.stop();\r\n            }\r\n            catch (error) {\r\n                logger.warn('stopSending() | rtpSender.stop() failed:%o', error);\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            rtpSender.setTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings\r\n                .forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            return rtpSender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel(options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server' });\r\n            logger.debug('receive() | calling new RTCRtpReceiver()');\r\n            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);\r\n            rtpReceiver.addEventListener('error', (event) => {\r\n                logger.error('rtpReceiver \"error\" event [event:%o]', event);\r\n            });\r\n            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\r\n            logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);\r\n            yield rtpReceiver.receive(edgeRtpParameters);\r\n            const localId = trackId;\r\n            this._rtpReceivers.set(localId, rtpReceiver);\r\n            return {\r\n                localId,\r\n                track: rtpReceiver.track,\r\n                rtpReceiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const rtpReceiver = this._rtpReceivers.get(localId);\r\n            if (!rtpReceiver)\r\n                throw new Error('RTCRtpReceiver not found');\r\n            this._rtpReceivers.delete(localId);\r\n            try {\r\n                logger.debug('stopReceiving() | calling rtpReceiver.stop()');\r\n                rtpReceiver.stop();\r\n            }\r\n            catch (error) {\r\n                logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);\r\n            }\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const rtpReceiver = this._rtpReceivers.get(localId);\r\n            if (!rtpReceiver)\r\n                throw new Error('RTCRtpReceiver not found');\r\n            return rtpReceiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel(options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    _setIceGatherer({ iceServers, iceTransportPolicy }) {\r\n        const iceGatherer = new RTCIceGatherer({\r\n            iceServers: iceServers || [],\r\n            gatherPolicy: iceTransportPolicy || 'all'\r\n        });\r\n        iceGatherer.addEventListener('error', (event) => {\r\n            logger.error('iceGatherer \"error\" event [event:%o]', event);\r\n        });\r\n        try {\r\n            iceGatherer.gather();\r\n        }\r\n        catch (error) {\r\n            logger.debug('_setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());\r\n        }\r\n        this._iceGatherer = iceGatherer;\r\n    }\r\n    _setIceTransport() {\r\n        const iceTransport = new RTCIceTransport(this._iceGatherer);\r\n        iceTransport.addEventListener('statechange', () => {\r\n            switch (iceTransport.state) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n        iceTransport.addEventListener('icestatechange', () => {\r\n            switch (iceTransport.state) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n        iceTransport.addEventListener('candidatepairchange', (event) => {\r\n            logger.debug('iceTransport \"candidatepairchange\" event [pair:%o]', event.pair);\r\n        });\r\n        this._iceTransport = iceTransport;\r\n    }\r\n    _setDtlsTransport() {\r\n        const dtlsTransport = new RTCDtlsTransport(this._iceTransport);\r\n        dtlsTransport.addEventListener('statechange', () => {\r\n            logger.debug('dtlsTransport \"statechange\" event [state:%s]', dtlsTransport.state);\r\n        });\r\n        dtlsTransport.addEventListener('dtlsstatechange', () => {\r\n            logger.debug('dtlsTransport \"dtlsstatechange\" event [state:%s]', dtlsTransport.state);\r\n            if (dtlsTransport.state === 'closed')\r\n                this.emit('@connectionstatechange', 'closed');\r\n        });\r\n        dtlsTransport.addEventListener('error', (event) => {\r\n            logger.error('dtlsTransport \"error\" event [event:%o]', event);\r\n        });\r\n        this._dtlsTransport = dtlsTransport;\r\n    }\r\n    _setupTransport({ localDtlsRole }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('_setupTransport()');\r\n            const dtlsParameters = this._dtlsTransport.getLocalParameters();\r\n            dtlsParameters.role = localDtlsRole;\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');\r\n            for (const candidate of this._remoteIceCandidates) {\r\n                this._iceTransport.addRemoteCandidate(candidate);\r\n            }\r\n            this._iceTransport.addRemoteCandidate({});\r\n            this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints\r\n                .filter((fingerprint) => {\r\n                return (fingerprint.algorithm === 'sha-256' ||\r\n                    fingerprint.algorithm === 'sha-384' ||\r\n                    fingerprint.algorithm === 'sha-512');\r\n            });\r\n            this._dtlsTransport.start(this._remoteDtlsParameters);\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n}\r\nexports.Edge11 = Edge11;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Edge11.ts?");

/***/ }),

/***/ "./src/handlers/Firefox60.ts":
/*!***********************************!*\
  !*** ./src/handlers/Firefox60.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./src/handlers/sdp/unifiedPlanUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Firefox60');\r\nconst SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };\r\nclass Firefox60 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._mapMidTransceiver = new Map();\r\n        this._sendStream = new MediaStream();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Firefox60();\r\n    }\r\n    get name() {\r\n        return 'Firefox60';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require'\r\n            });\r\n            const canvas = document.createElement('canvas');\r\n            canvas.getContext('2d');\r\n            const fakeStream = canvas.captureStream();\r\n            const fakeVideoTrack = fakeStream.getVideoTracks()[0];\r\n            try {\r\n                pc.addTransceiver('audio', { direction: 'sendrecv' });\r\n                const videoTransceiver = pc.addTransceiver(fakeVideoTrack, { direction: 'sendrecv' });\r\n                const parameters = videoTransceiver.sender.getParameters();\r\n                const encodings = [\r\n                    { rid: 'r0', maxBitrate: 100000 },\r\n                    { rid: 'r1', maxBitrate: 500000 }\r\n                ];\r\n                parameters.encodings = encodings;\r\n                yield videoTransceiver.sender.setParameters(parameters);\r\n                const offer = yield pc.createOffer();\r\n                try {\r\n                    canvas.remove();\r\n                }\r\n                catch (error) { }\r\n                try {\r\n                    fakeVideoTrack.stop();\r\n                }\r\n                catch (error) { }\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    canvas.remove();\r\n                }\r\n                catch (error2) { }\r\n                try {\r\n                    fakeVideoTrack.stop();\r\n                }\r\n                catch (error2) { }\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not supported');\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            let reverseEncodings;\r\n            if (encodings && encodings.length > 1) {\r\n                encodings.forEach((encoding, idx) => {\r\n                    encoding.rid = `r${idx}`;\r\n                });\r\n                reverseEncodings = utils.clone(encodings).reverse();\r\n            }\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\r\n            const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\r\n            if (reverseEncodings) {\r\n                const parameters = transceiver.sender.getParameters();\r\n                parameters.encodings = reverseEncodings;\r\n                yield transceiver.sender.setParameters(parameters);\r\n            }\r\n            const offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const localId = transceiver.mid;\r\n            sendingRtpParameters.mid = localId;\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            if (!encodings) {\r\n                sendingRtpParameters.encodings =\r\n                    sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n            }\r\n            else if (encodings.length === 1) {\r\n                const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n                Object.assign(newEncodings[0], encodings[0]);\r\n                sendingRtpParameters.encodings = newEncodings;\r\n            }\r\n            else {\r\n                sendingRtpParameters.encodings = encodings;\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions,\r\n                extmapAllowMixed: true\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender: transceiver.sender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated transceiver not found');\r\n            transceiver.sender.replaceTrack(null);\r\n            this._pc.removeTrack(transceiver.sender);\r\n            this._remoteSdp.disableMediaSection(transceiver.mid);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            yield transceiver.sender.replaceTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated transceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            spatialLayer = parameters.encodings.length - 1 - spatialLayer;\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx >= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.sender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\r\n            this._remoteSdp.receive({\r\n                mid: localId,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === localId);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const transceiver = this._pc.getTransceivers()\r\n                .find((t) => t.mid === localId);\r\n            if (!transceiver)\r\n                throw new Error('new RTCRtpTransceiver not found');\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                track: transceiver.receiver.track,\r\n                rtpReceiver: transceiver.receiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.receiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation();\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Firefox60 = Firefox60;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Firefox60.ts?");

/***/ }),

/***/ "./src/handlers/HandlerInterface.ts":
/*!******************************************!*\
  !*** ./src/handlers/HandlerInterface.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nclass HandlerInterface extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\nexports.HandlerInterface = HandlerInterface;\r\n\n\n//# sourceURL=webpack:///./src/handlers/HandlerInterface.ts?");

/***/ }),

/***/ "./src/handlers/ReactNative.ts":
/*!*************************************!*\
  !*** ./src/handlers/ReactNative.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"./src/handlers/sdp/planBUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('ReactNative');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass ReactNative extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._sendStream = new MediaStream();\r\n        this._mapSendLocalIdTrack = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._mapRecvLocalIdInfo = new Map();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new ReactNative();\r\n    }\r\n    get name() {\r\n        return 'ReactNative';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'plan-b'\r\n            });\r\n            try {\r\n                const offer = yield pc.createOffer({\r\n                    offerToReceiveAudio: true,\r\n                    offerToReceiveVideo: true\r\n                });\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            planB: true\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (codec) {\r\n                logger.warn('send() | codec selection is not available in %s handler', this.name);\r\n            }\r\n            this._sendStream.addTrack(track);\r\n            this._pc.addStream(this._sendStream);\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (track.kind === 'video' && encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'video');\r\n                sdpPlanBUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    track,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media\r\n                .find((m) => m.type === track.kind);\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            this._mapSendLocalIdTrack.set(localId, track);\r\n            return {\r\n                localId: localId,\r\n                rtpParameters: sendingRtpParameters\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const track = this._mapSendLocalIdTrack.get(localId);\r\n            if (!track)\r\n                throw new Error('track not found');\r\n            this._mapSendLocalIdTrack.delete(localId);\r\n            this._sendStream.removeTrack(track);\r\n            this._pc.addStream(this._sendStream);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            try {\r\n                yield this._pc.setLocalDescription(offer);\r\n            }\r\n            catch (error) {\r\n                if (this._sendStream.getTracks().length === 0) {\r\n                    logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n            if (this._pc.signalingState === 'stable')\r\n                return;\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = trackId;\r\n            const mid = kind;\r\n            let streamId = rtpParameters.rtcp.cname;\r\n            logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');\r\n            streamId += `-hack-${utils.generateRandomNumber()}`;\r\n            this._remoteSdp.receive({\r\n                mid,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === mid);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const stream = this._pc.getRemoteStreams()\r\n                .find((s) => s.id === streamId);\r\n            const track = stream.getTrackById(localId);\r\n            if (!track)\r\n                throw new Error('remote track not found');\r\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\r\n            return { localId, track };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            this._mapRecvLocalIdInfo.delete(localId);\r\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.ReactNative = ReactNative;\r\n\n\n//# sourceURL=webpack:///./src/handlers/ReactNative.ts?");

/***/ }),

/***/ "./src/handlers/Safari11.ts":
/*!**********************************!*\
  !*** ./src/handlers/Safari11.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"./src/handlers/sdp/planBUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Safari11');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Safari11 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._sendStream = new MediaStream();\r\n        this._mapSendLocalIdRtpSender = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._mapRecvLocalIdInfo = new Map();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Safari11();\r\n    }\r\n    get name() {\r\n        return 'Safari11';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'plan-b'\r\n            });\r\n            try {\r\n                const offer = yield pc.createOffer({\r\n                    offerToReceiveAudio: true,\r\n                    offerToReceiveVideo: true\r\n                });\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            planB: true\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (codec) {\r\n                logger.warn('send() | codec selection is not available in %s handler', this.name);\r\n            }\r\n            this._sendStream.addTrack(track);\r\n            this._pc.addTrack(track, this._sendStream);\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (track.kind === 'video' && encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\r\n                sdpPlanBUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    track,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media\r\n                .find((m) => m.type === track.kind);\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            const rtpSender = this._pc.getSenders()\r\n                .find((s) => s.track === track);\r\n            this._mapSendLocalIdRtpSender.set(localId, rtpSender);\r\n            return {\r\n                localId: localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            if (rtpSender.track)\r\n                this._sendStream.removeTrack(rtpSender.track);\r\n            this._mapSendLocalIdRtpSender.delete(localId);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            try {\r\n                yield this._pc.setLocalDescription(offer);\r\n            }\r\n            catch (error) {\r\n                if (this._sendStream.getTracks().length === 0) {\r\n                    logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n            if (this._pc.signalingState === 'stable')\r\n                return;\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const oldTrack = rtpSender.track;\r\n            yield rtpSender.replaceTrack(track);\r\n            if (oldTrack)\r\n                this._sendStream.removeTrack(oldTrack);\r\n            if (track)\r\n                this._sendStream.addTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            return rtpSender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = trackId;\r\n            const mid = kind;\r\n            this._remoteSdp.receive({\r\n                mid,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === mid);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const rtpReceiver = this._pc.getReceivers()\r\n                .find((r) => r.track && r.track.id === localId);\r\n            if (!rtpReceiver)\r\n                throw new Error('new RTCRtpReceiver not');\r\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });\r\n            return {\r\n                localId,\r\n                track: rtpReceiver.track,\r\n                rtpReceiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            this._mapRecvLocalIdInfo.delete(localId);\r\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            if (!rtpReceiver)\r\n                throw new Error('associated RTCRtpReceiver not found');\r\n            return rtpReceiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Safari11 = Safari11;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Safari11.ts?");

/***/ }),

/***/ "./src/handlers/Safari12.ts":
/*!**********************************!*\
  !*** ./src/handlers/Safari12.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./src/handlers/sdp/unifiedPlanUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Safari12');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Safari12 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._mapMidTransceiver = new Map();\r\n        this._sendStream = new MediaStream();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Safari12();\r\n    }\r\n    get name() {\r\n        return 'Safari12';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require'\r\n            });\r\n            try {\r\n                pc.addTransceiver('audio');\r\n                pc.addTransceiver('video');\r\n                const offer = yield pc.createOffer();\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\r\n            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\r\n            const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling legacy simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n                sdpUnifiedPlanUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const localId = transceiver.mid;\r\n            sendingRtpParameters.mid = localId;\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                reuseMid: mediaSectionIdx.reuseMid,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender: transceiver.sender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            transceiver.sender.replaceTrack(null);\r\n            this._pc.removeTrack(transceiver.sender);\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            yield transceiver.sender.replaceTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.sender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\r\n            this._remoteSdp.receive({\r\n                mid: localId,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === localId);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const transceiver = this._pc.getTransceivers()\r\n                .find((t) => t.mid === localId);\r\n            if (!transceiver)\r\n                throw new Error('new RTCRtpTransceiver not found');\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                track: transceiver.receiver.track,\r\n                rtpReceiver: transceiver.receiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.receiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation();\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Safari12 = Safari12;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Safari12.ts?");

/***/ }),

/***/ "./src/handlers/ortc/edgeUtils.ts":
/*!****************************************!*\
  !*** ./src/handlers/ortc/edgeUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = __importStar(__webpack_require__(/*! ../../utils */ \"./src/utils.ts\"));\r\nfunction getCapabilities() {\r\n    const nativeCaps = RTCRtpReceiver.getCapabilities();\r\n    const caps = utils.clone(nativeCaps);\r\n    for (const codec of caps.codecs) {\r\n        codec.channels = codec.numChannels;\r\n        delete codec.numChannels;\r\n        codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;\r\n        if (codec.parameters) {\r\n            const parameters = codec.parameters;\r\n            if (parameters.apt)\r\n                parameters.apt = Number(parameters.apt);\r\n            if (parameters['packetization-mode'])\r\n                parameters['packetization-mode'] = Number(parameters['packetization-mode']);\r\n        }\r\n        for (const feedback of codec.rtcpFeedback || []) {\r\n            if (!feedback.parameter)\r\n                feedback.parameter = '';\r\n        }\r\n    }\r\n    return caps;\r\n}\r\nexports.getCapabilities = getCapabilities;\r\nfunction mangleRtpParameters(rtpParameters) {\r\n    const params = utils.clone(rtpParameters);\r\n    if (params.mid) {\r\n        params.muxId = params.mid;\r\n        delete params.mid;\r\n    }\r\n    for (const codec of params.codecs) {\r\n        if (codec.channels) {\r\n            codec.numChannels = codec.channels;\r\n            delete codec.channels;\r\n        }\r\n        if (codec.mimeType && !codec.name)\r\n            codec.name = codec.mimeType.split('/')[1];\r\n        delete codec.mimeType;\r\n    }\r\n    return params;\r\n}\r\nexports.mangleRtpParameters = mangleRtpParameters;\r\n\n\n//# sourceURL=webpack:///./src/handlers/ortc/edgeUtils.ts?");

/***/ }),

/***/ "./src/handlers/sdp/MediaSection.ts":
/*!******************************************!*\
  !*** ./src/handlers/sdp/MediaSection.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = __importStar(__webpack_require__(/*! ../../utils */ \"./src/utils.ts\"));\r\nclass MediaSection {\r\n    constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false }) {\r\n        this._mediaObject = {};\r\n        this._planB = planB;\r\n        if (iceParameters) {\r\n            this.setIceParameters(iceParameters);\r\n        }\r\n        if (iceCandidates) {\r\n            this._mediaObject.candidates = [];\r\n            for (const candidate of iceCandidates) {\r\n                const candidateObject = {};\r\n                candidateObject.component = 1;\r\n                candidateObject.foundation = candidate.foundation;\r\n                candidateObject.ip = candidate.ip;\r\n                candidateObject.port = candidate.port;\r\n                candidateObject.priority = candidate.priority;\r\n                candidateObject.transport = candidate.protocol;\r\n                candidateObject.type = candidate.type;\r\n                if (candidate.tcpType)\r\n                    candidateObject.tcptype = candidate.tcpType;\r\n                this._mediaObject.candidates.push(candidateObject);\r\n            }\r\n            this._mediaObject.endOfCandidates = 'end-of-candidates';\r\n            this._mediaObject.iceOptions = 'renomination';\r\n        }\r\n        if (dtlsParameters) {\r\n            this.setDtlsRole(dtlsParameters.role);\r\n        }\r\n    }\r\n    get mid() {\r\n        return String(this._mediaObject.mid);\r\n    }\r\n    get closed() {\r\n        return this._mediaObject.port === 0;\r\n    }\r\n    getObject() {\r\n        return this._mediaObject;\r\n    }\r\n    setIceParameters(iceParameters) {\r\n        this._mediaObject.iceUfrag = iceParameters.usernameFragment;\r\n        this._mediaObject.icePwd = iceParameters.password;\r\n    }\r\n    disable() {\r\n        this._mediaObject.direction = 'inactive';\r\n        delete this._mediaObject.ext;\r\n        delete this._mediaObject.ssrcs;\r\n        delete this._mediaObject.ssrcGroups;\r\n        delete this._mediaObject.simulcast;\r\n        delete this._mediaObject.simulcast_03;\r\n        delete this._mediaObject.rids;\r\n    }\r\n    close() {\r\n        this._mediaObject.direction = 'inactive';\r\n        this._mediaObject.port = 0;\r\n        delete this._mediaObject.ext;\r\n        delete this._mediaObject.ssrcs;\r\n        delete this._mediaObject.ssrcGroups;\r\n        delete this._mediaObject.simulcast;\r\n        delete this._mediaObject.simulcast_03;\r\n        delete this._mediaObject.rids;\r\n        delete this._mediaObject.extmapAllowMixed;\r\n    }\r\n}\r\nexports.MediaSection = MediaSection;\r\nclass AnswerMediaSection extends MediaSection {\r\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {\r\n        super({ iceParameters, iceCandidates, dtlsParameters, planB });\r\n        this._mediaObject.mid = String(offerMediaObject.mid);\r\n        this._mediaObject.type = offerMediaObject.type;\r\n        this._mediaObject.protocol = offerMediaObject.protocol;\r\n        if (!plainRtpParameters) {\r\n            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };\r\n            this._mediaObject.port = 7;\r\n        }\r\n        else {\r\n            this._mediaObject.connection =\r\n                {\r\n                    ip: plainRtpParameters.ip,\r\n                    version: plainRtpParameters.ipVersion\r\n                };\r\n            this._mediaObject.port = plainRtpParameters.port;\r\n        }\r\n        switch (offerMediaObject.type) {\r\n            case 'audio':\r\n            case 'video':\r\n                {\r\n                    this._mediaObject.direction = 'recvonly';\r\n                    this._mediaObject.rtp = [];\r\n                    this._mediaObject.rtcpFb = [];\r\n                    this._mediaObject.fmtp = [];\r\n                    for (const codec of answerRtpParameters.codecs) {\r\n                        const rtp = {\r\n                            payload: codec.payloadType,\r\n                            codec: getCodecName(codec),\r\n                            rate: codec.clockRate\r\n                        };\r\n                        if (codec.channels > 1)\r\n                            rtp.encoding = codec.channels;\r\n                        this._mediaObject.rtp.push(rtp);\r\n                        const codecParameters = utils.clone(codec.parameters || {});\r\n                        if (codecOptions) {\r\n                            const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusPtime, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;\r\n                            const offerCodec = offerRtpParameters.codecs\r\n                                .find((c) => (c.payloadType === codec.payloadType));\r\n                            switch (codec.mimeType.toLowerCase()) {\r\n                                case 'audio/opus':\r\n                                    {\r\n                                        if (opusStereo !== undefined) {\r\n                                            offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;\r\n                                            codecParameters.stereo = opusStereo ? 1 : 0;\r\n                                        }\r\n                                        if (opusFec !== undefined) {\r\n                                            offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;\r\n                                            codecParameters.useinbandfec = opusFec ? 1 : 0;\r\n                                        }\r\n                                        if (opusDtx !== undefined) {\r\n                                            offerCodec.parameters.usedtx = opusDtx ? 1 : 0;\r\n                                            codecParameters.usedtx = opusDtx ? 1 : 0;\r\n                                        }\r\n                                        if (opusMaxPlaybackRate !== undefined) {\r\n                                            codecParameters.maxplaybackrate = opusMaxPlaybackRate;\r\n                                        }\r\n                                        if (opusPtime !== undefined) {\r\n                                            offerCodec.parameters.ptime = opusPtime;\r\n                                            codecParameters.ptime = opusPtime;\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                case 'video/vp8':\r\n                                case 'video/vp9':\r\n                                case 'video/h264':\r\n                                case 'video/h265':\r\n                                    {\r\n                                        if (videoGoogleStartBitrate !== undefined)\r\n                                            codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;\r\n                                        if (videoGoogleMaxBitrate !== undefined)\r\n                                            codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;\r\n                                        if (videoGoogleMinBitrate !== undefined)\r\n                                            codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;\r\n                                        break;\r\n                                    }\r\n                            }\r\n                        }\r\n                        const fmtp = {\r\n                            payload: codec.payloadType,\r\n                            config: ''\r\n                        };\r\n                        for (const key of Object.keys(codecParameters)) {\r\n                            if (fmtp.config)\r\n                                fmtp.config += ';';\r\n                            fmtp.config += `${key}=${codecParameters[key]}`;\r\n                        }\r\n                        if (fmtp.config)\r\n                            this._mediaObject.fmtp.push(fmtp);\r\n                        for (const fb of codec.rtcpFeedback) {\r\n                            this._mediaObject.rtcpFb.push({\r\n                                payload: codec.payloadType,\r\n                                type: fb.type,\r\n                                subtype: fb.parameter\r\n                            });\r\n                        }\r\n                    }\r\n                    this._mediaObject.payloads = answerRtpParameters.codecs\r\n                        .map((codec) => codec.payloadType)\r\n                        .join(' ');\r\n                    this._mediaObject.ext = [];\r\n                    for (const ext of answerRtpParameters.headerExtensions) {\r\n                        const found = (offerMediaObject.ext || [])\r\n                            .some((localExt) => localExt.uri === ext.uri);\r\n                        if (!found)\r\n                            continue;\r\n                        this._mediaObject.ext.push({\r\n                            uri: ext.uri,\r\n                            value: ext.id\r\n                        });\r\n                    }\r\n                    if (extmapAllowMixed &&\r\n                        offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {\r\n                        this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';\r\n                    }\r\n                    if (offerMediaObject.simulcast) {\r\n                        this._mediaObject.simulcast =\r\n                            {\r\n                                dir1: 'recv',\r\n                                list1: offerMediaObject.simulcast.list1\r\n                            };\r\n                        this._mediaObject.rids = [];\r\n                        for (const rid of offerMediaObject.rids || []) {\r\n                            if (rid.direction !== 'send')\r\n                                continue;\r\n                            this._mediaObject.rids.push({\r\n                                id: rid.id,\r\n                                direction: 'recv'\r\n                            });\r\n                        }\r\n                    }\r\n                    else if (offerMediaObject.simulcast_03) {\r\n                        this._mediaObject.simulcast_03 =\r\n                            {\r\n                                value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')\r\n                            };\r\n                        this._mediaObject.rids = [];\r\n                        for (const rid of offerMediaObject.rids || []) {\r\n                            if (rid.direction !== 'send')\r\n                                continue;\r\n                            this._mediaObject.rids.push({\r\n                                id: rid.id,\r\n                                direction: 'recv'\r\n                            });\r\n                        }\r\n                    }\r\n                    this._mediaObject.rtcpMux = 'rtcp-mux';\r\n                    this._mediaObject.rtcpRsize = 'rtcp-rsize';\r\n                    if (this._planB && this._mediaObject.type === 'video')\r\n                        this._mediaObject.xGoogleFlag = 'conference';\r\n                    break;\r\n                }\r\n            case 'application':\r\n                {\r\n                    if (typeof offerMediaObject.sctpPort === 'number') {\r\n                        this._mediaObject.payloads = 'webrtc-datachannel';\r\n                        this._mediaObject.sctpPort = sctpParameters.port;\r\n                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\r\n                    }\r\n                    else if (offerMediaObject.sctpmap) {\r\n                        this._mediaObject.payloads = sctpParameters.port;\r\n                        this._mediaObject.sctpmap =\r\n                            {\r\n                                app: 'webrtc-datachannel',\r\n                                sctpmapNumber: sctpParameters.port,\r\n                                maxMessageSize: sctpParameters.maxMessageSize\r\n                            };\r\n                    }\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n    setDtlsRole(role) {\r\n        switch (role) {\r\n            case 'client':\r\n                this._mediaObject.setup = 'active';\r\n                break;\r\n            case 'server':\r\n                this._mediaObject.setup = 'passive';\r\n                break;\r\n            case 'auto':\r\n                this._mediaObject.setup = 'actpass';\r\n                break;\r\n        }\r\n    }\r\n}\r\nexports.AnswerMediaSection = AnswerMediaSection;\r\nclass OfferMediaSection extends MediaSection {\r\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false }) {\r\n        super({ iceParameters, iceCandidates, dtlsParameters, planB });\r\n        this._mediaObject.mid = String(mid);\r\n        this._mediaObject.type = kind;\r\n        if (!plainRtpParameters) {\r\n            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };\r\n            if (!sctpParameters)\r\n                this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';\r\n            else\r\n                this._mediaObject.protocol = 'UDP/DTLS/SCTP';\r\n            this._mediaObject.port = 7;\r\n        }\r\n        else {\r\n            this._mediaObject.connection =\r\n                {\r\n                    ip: plainRtpParameters.ip,\r\n                    version: plainRtpParameters.ipVersion\r\n                };\r\n            this._mediaObject.protocol = 'RTP/AVP';\r\n            this._mediaObject.port = plainRtpParameters.port;\r\n        }\r\n        switch (kind) {\r\n            case 'audio':\r\n            case 'video':\r\n                {\r\n                    this._mediaObject.direction = 'sendonly';\r\n                    this._mediaObject.rtp = [];\r\n                    this._mediaObject.rtcpFb = [];\r\n                    this._mediaObject.fmtp = [];\r\n                    if (!this._planB)\r\n                        this._mediaObject.msid = `${streamId || '-'} ${trackId}`;\r\n                    for (const codec of offerRtpParameters.codecs) {\r\n                        const rtp = {\r\n                            payload: codec.payloadType,\r\n                            codec: getCodecName(codec),\r\n                            rate: codec.clockRate\r\n                        };\r\n                        if (codec.channels > 1)\r\n                            rtp.encoding = codec.channels;\r\n                        this._mediaObject.rtp.push(rtp);\r\n                        const fmtp = {\r\n                            payload: codec.payloadType,\r\n                            config: ''\r\n                        };\r\n                        for (const key of Object.keys(codec.parameters)) {\r\n                            if (fmtp.config)\r\n                                fmtp.config += ';';\r\n                            fmtp.config += `${key}=${codec.parameters[key]}`;\r\n                        }\r\n                        if (fmtp.config)\r\n                            this._mediaObject.fmtp.push(fmtp);\r\n                        for (const fb of codec.rtcpFeedback) {\r\n                            this._mediaObject.rtcpFb.push({\r\n                                payload: codec.payloadType,\r\n                                type: fb.type,\r\n                                subtype: fb.parameter\r\n                            });\r\n                        }\r\n                    }\r\n                    this._mediaObject.payloads = offerRtpParameters.codecs\r\n                        .map((codec) => codec.payloadType)\r\n                        .join(' ');\r\n                    this._mediaObject.ext = [];\r\n                    for (const ext of offerRtpParameters.headerExtensions) {\r\n                        this._mediaObject.ext.push({\r\n                            uri: ext.uri,\r\n                            value: ext.id\r\n                        });\r\n                    }\r\n                    this._mediaObject.rtcpMux = 'rtcp-mux';\r\n                    this._mediaObject.rtcpRsize = 'rtcp-rsize';\r\n                    const encoding = offerRtpParameters.encodings[0];\r\n                    const ssrc = encoding.ssrc;\r\n                    const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\r\n                        ? encoding.rtx.ssrc\r\n                        : undefined;\r\n                    this._mediaObject.ssrcs = [];\r\n                    this._mediaObject.ssrcGroups = [];\r\n                    if (offerRtpParameters.rtcp.cname) {\r\n                        this._mediaObject.ssrcs.push({\r\n                            id: ssrc,\r\n                            attribute: 'cname',\r\n                            value: offerRtpParameters.rtcp.cname\r\n                        });\r\n                    }\r\n                    if (this._planB) {\r\n                        this._mediaObject.ssrcs.push({\r\n                            id: ssrc,\r\n                            attribute: 'msid',\r\n                            value: `${streamId || '-'} ${trackId}`\r\n                        });\r\n                    }\r\n                    if (rtxSsrc) {\r\n                        if (offerRtpParameters.rtcp.cname) {\r\n                            this._mediaObject.ssrcs.push({\r\n                                id: rtxSsrc,\r\n                                attribute: 'cname',\r\n                                value: offerRtpParameters.rtcp.cname\r\n                            });\r\n                        }\r\n                        if (this._planB) {\r\n                            this._mediaObject.ssrcs.push({\r\n                                id: rtxSsrc,\r\n                                attribute: 'msid',\r\n                                value: `${streamId || '-'} ${trackId}`\r\n                            });\r\n                        }\r\n                        this._mediaObject.ssrcGroups.push({\r\n                            semantics: 'FID',\r\n                            ssrcs: `${ssrc} ${rtxSsrc}`\r\n                        });\r\n                    }\r\n                    break;\r\n                }\r\n            case 'application':\r\n                {\r\n                    if (!oldDataChannelSpec) {\r\n                        this._mediaObject.payloads = 'webrtc-datachannel';\r\n                        this._mediaObject.sctpPort = sctpParameters.port;\r\n                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\r\n                    }\r\n                    else {\r\n                        this._mediaObject.payloads = sctpParameters.port;\r\n                        this._mediaObject.sctpmap =\r\n                            {\r\n                                app: 'webrtc-datachannel',\r\n                                sctpmapNumber: sctpParameters.port,\r\n                                maxMessageSize: sctpParameters.maxMessageSize\r\n                            };\r\n                    }\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n    setDtlsRole(role) {\r\n        this._mediaObject.setup = 'actpass';\r\n    }\r\n    planBReceive({ offerRtpParameters, streamId, trackId }) {\r\n        const encoding = offerRtpParameters.encodings[0];\r\n        const ssrc = encoding.ssrc;\r\n        const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\r\n            ? encoding.rtx.ssrc\r\n            : undefined;\r\n        if (offerRtpParameters.rtcp.cname) {\r\n            this._mediaObject.ssrcs.push({\r\n                id: ssrc,\r\n                attribute: 'cname',\r\n                value: offerRtpParameters.rtcp.cname\r\n            });\r\n        }\r\n        this._mediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'msid',\r\n            value: `${streamId || '-'} ${trackId}`\r\n        });\r\n        if (rtxSsrc) {\r\n            if (offerRtpParameters.rtcp.cname) {\r\n                this._mediaObject.ssrcs.push({\r\n                    id: rtxSsrc,\r\n                    attribute: 'cname',\r\n                    value: offerRtpParameters.rtcp.cname\r\n                });\r\n            }\r\n            this._mediaObject.ssrcs.push({\r\n                id: rtxSsrc,\r\n                attribute: 'msid',\r\n                value: `${streamId || '-'} ${trackId}`\r\n            });\r\n            this._mediaObject.ssrcGroups.push({\r\n                semantics: 'FID',\r\n                ssrcs: `${ssrc} ${rtxSsrc}`\r\n            });\r\n        }\r\n    }\r\n    planBStopReceiving({ offerRtpParameters }) {\r\n        const encoding = offerRtpParameters.encodings[0];\r\n        const ssrc = encoding.ssrc;\r\n        const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\r\n            ? encoding.rtx.ssrc\r\n            : undefined;\r\n        this._mediaObject.ssrcs = this._mediaObject.ssrcs\r\n            .filter((s) => s.id !== ssrc && s.id !== rtxSsrc);\r\n        if (rtxSsrc) {\r\n            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups\r\n                .filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);\r\n        }\r\n    }\r\n}\r\nexports.OfferMediaSection = OfferMediaSection;\r\nfunction getCodecName(codec) {\r\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\r\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\r\n    if (!mimeTypeMatch)\r\n        throw new TypeError('invalid codec.mimeType');\r\n    return mimeTypeMatch[2];\r\n}\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/MediaSection.ts?");

/***/ }),

/***/ "./src/handlers/sdp/RemoteSdp.ts":
/*!***************************************!*\
  !*** ./src/handlers/sdp/RemoteSdp.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../../Logger */ \"./src/Logger.ts\");\r\nconst MediaSection_1 = __webpack_require__(/*! ./MediaSection */ \"./src/handlers/sdp/MediaSection.ts\");\r\nconst logger = new Logger_1.Logger('RemoteSdp');\r\nclass RemoteSdp {\r\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false }) {\r\n        this._mediaSections = [];\r\n        this._midToIndex = new Map();\r\n        this._iceParameters = iceParameters;\r\n        this._iceCandidates = iceCandidates;\r\n        this._dtlsParameters = dtlsParameters;\r\n        this._sctpParameters = sctpParameters;\r\n        this._plainRtpParameters = plainRtpParameters;\r\n        this._planB = planB;\r\n        this._sdpObject =\r\n            {\r\n                version: 0,\r\n                origin: {\r\n                    address: '0.0.0.0',\r\n                    ipVer: 4,\r\n                    netType: 'IN',\r\n                    sessionId: 10000,\r\n                    sessionVersion: 0,\r\n                    username: 'mediasoup-client'\r\n                },\r\n                name: '-',\r\n                timing: { start: 0, stop: 0 },\r\n                media: []\r\n            };\r\n        if (iceParameters && iceParameters.iceLite) {\r\n            this._sdpObject.icelite = 'ice-lite';\r\n        }\r\n        if (dtlsParameters) {\r\n            this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };\r\n            const numFingerprints = this._dtlsParameters.fingerprints.length;\r\n            this._sdpObject.fingerprint =\r\n                {\r\n                    type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,\r\n                    hash: dtlsParameters.fingerprints[numFingerprints - 1].value\r\n                };\r\n            this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];\r\n        }\r\n        if (plainRtpParameters) {\r\n            this._sdpObject.origin.address = plainRtpParameters.ip;\r\n            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;\r\n        }\r\n    }\r\n    updateIceParameters(iceParameters) {\r\n        logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);\r\n        this._iceParameters = iceParameters;\r\n        this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;\r\n        for (const mediaSection of this._mediaSections) {\r\n            mediaSection.setIceParameters(iceParameters);\r\n        }\r\n    }\r\n    updateDtlsRole(role) {\r\n        logger.debug('updateDtlsRole() [role:%s]', role);\r\n        this._dtlsParameters.role = role;\r\n        for (const mediaSection of this._mediaSections) {\r\n            mediaSection.setDtlsRole(role);\r\n        }\r\n    }\r\n    getNextMediaSectionIdx() {\r\n        for (let idx = 0; idx < this._mediaSections.length; ++idx) {\r\n            const mediaSection = this._mediaSections[idx];\r\n            if (mediaSection.closed)\r\n                return { idx, reuseMid: mediaSection.mid };\r\n        }\r\n        return { idx: this._mediaSections.length };\r\n    }\r\n    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {\r\n        const mediaSection = new MediaSection_1.AnswerMediaSection({\r\n            iceParameters: this._iceParameters,\r\n            iceCandidates: this._iceCandidates,\r\n            dtlsParameters: this._dtlsParameters,\r\n            plainRtpParameters: this._plainRtpParameters,\r\n            planB: this._planB,\r\n            offerMediaObject,\r\n            offerRtpParameters,\r\n            answerRtpParameters,\r\n            codecOptions,\r\n            extmapAllowMixed\r\n        });\r\n        if (reuseMid) {\r\n            this._replaceMediaSection(mediaSection, reuseMid);\r\n        }\r\n        else if (!this._midToIndex.has(mediaSection.mid)) {\r\n            this._addMediaSection(mediaSection);\r\n        }\r\n        else {\r\n            this._replaceMediaSection(mediaSection);\r\n        }\r\n    }\r\n    receive({ mid, kind, offerRtpParameters, streamId, trackId }) {\r\n        const idx = this._midToIndex.get(mid);\r\n        let mediaSection;\r\n        if (idx !== undefined)\r\n            mediaSection = this._mediaSections[idx];\r\n        if (!mediaSection) {\r\n            mediaSection = new MediaSection_1.OfferMediaSection({\r\n                iceParameters: this._iceParameters,\r\n                iceCandidates: this._iceCandidates,\r\n                dtlsParameters: this._dtlsParameters,\r\n                plainRtpParameters: this._plainRtpParameters,\r\n                planB: this._planB,\r\n                mid,\r\n                kind,\r\n                offerRtpParameters,\r\n                streamId,\r\n                trackId\r\n            });\r\n            this._addMediaSection(mediaSection);\r\n        }\r\n        else {\r\n            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });\r\n            this._replaceMediaSection(mediaSection);\r\n        }\r\n    }\r\n    disableMediaSection(mid) {\r\n        const idx = this._midToIndex.get(mid);\r\n        if (idx === undefined) {\r\n            throw new Error(`no media section found with mid '${mid}'`);\r\n        }\r\n        const mediaSection = this._mediaSections[idx];\r\n        mediaSection.disable();\r\n    }\r\n    closeMediaSection(mid) {\r\n        const idx = this._midToIndex.get(mid);\r\n        if (idx === undefined) {\r\n            throw new Error(`no media section found with mid '${mid}'`);\r\n        }\r\n        const mediaSection = this._mediaSections[idx];\r\n        if (mid === this._firstMid) {\r\n            logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);\r\n            this.disableMediaSection(mid);\r\n            return;\r\n        }\r\n        mediaSection.close();\r\n        this._regenerateBundleMids();\r\n    }\r\n    planBStopReceiving({ mid, offerRtpParameters }) {\r\n        const idx = this._midToIndex.get(mid);\r\n        if (idx === undefined) {\r\n            throw new Error(`no media section found with mid '${mid}'`);\r\n        }\r\n        const mediaSection = this._mediaSections[idx];\r\n        mediaSection.planBStopReceiving({ offerRtpParameters });\r\n        this._replaceMediaSection(mediaSection);\r\n    }\r\n    sendSctpAssociation({ offerMediaObject }) {\r\n        const mediaSection = new MediaSection_1.AnswerMediaSection({\r\n            iceParameters: this._iceParameters,\r\n            iceCandidates: this._iceCandidates,\r\n            dtlsParameters: this._dtlsParameters,\r\n            sctpParameters: this._sctpParameters,\r\n            plainRtpParameters: this._plainRtpParameters,\r\n            offerMediaObject\r\n        });\r\n        this._addMediaSection(mediaSection);\r\n    }\r\n    receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {\r\n        const mediaSection = new MediaSection_1.OfferMediaSection({\r\n            iceParameters: this._iceParameters,\r\n            iceCandidates: this._iceCandidates,\r\n            dtlsParameters: this._dtlsParameters,\r\n            sctpParameters: this._sctpParameters,\r\n            plainRtpParameters: this._plainRtpParameters,\r\n            mid: 'datachannel',\r\n            kind: 'application',\r\n            oldDataChannelSpec\r\n        });\r\n        this._addMediaSection(mediaSection);\r\n    }\r\n    getSdp() {\r\n        this._sdpObject.origin.sessionVersion++;\r\n        return sdpTransform.write(this._sdpObject);\r\n    }\r\n    _addMediaSection(newMediaSection) {\r\n        if (!this._firstMid)\r\n            this._firstMid = newMediaSection.mid;\r\n        this._mediaSections.push(newMediaSection);\r\n        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);\r\n        this._sdpObject.media.push(newMediaSection.getObject());\r\n        this._regenerateBundleMids();\r\n    }\r\n    _replaceMediaSection(newMediaSection, reuseMid) {\r\n        if (typeof reuseMid === 'string') {\r\n            const idx = this._midToIndex.get(reuseMid);\r\n            if (idx === undefined) {\r\n                throw new Error(`no media section found for reuseMid '${reuseMid}'`);\r\n            }\r\n            const oldMediaSection = this._mediaSections[idx];\r\n            this._mediaSections[idx] = newMediaSection;\r\n            this._midToIndex.delete(oldMediaSection.mid);\r\n            this._midToIndex.set(newMediaSection.mid, idx);\r\n            this._sdpObject.media[idx] = newMediaSection.getObject();\r\n            this._regenerateBundleMids();\r\n        }\r\n        else {\r\n            const idx = this._midToIndex.get(newMediaSection.mid);\r\n            if (idx === undefined) {\r\n                throw new Error(`no media section found with mid '${newMediaSection.mid}'`);\r\n            }\r\n            this._mediaSections[idx] = newMediaSection;\r\n            this._sdpObject.media[idx] = newMediaSection.getObject();\r\n        }\r\n    }\r\n    _regenerateBundleMids() {\r\n        if (!this._dtlsParameters)\r\n            return;\r\n        this._sdpObject.groups[0].mids = this._mediaSections\r\n            .filter((mediaSection) => !mediaSection.closed)\r\n            .map((mediaSection) => mediaSection.mid)\r\n            .join(' ');\r\n    }\r\n}\r\nexports.RemoteSdp = RemoteSdp;\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/RemoteSdp.ts?");

/***/ }),

/***/ "./src/handlers/sdp/commonUtils.ts":
/*!*****************************************!*\
  !*** ./src/handlers/sdp/commonUtils.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nfunction extractRtpCapabilities({ sdpObject }) {\r\n    const codecsMap = new Map();\r\n    const headerExtensions = [];\r\n    let gotAudio = false;\r\n    let gotVideo = false;\r\n    for (const m of sdpObject.media) {\r\n        const kind = m.type;\r\n        switch (kind) {\r\n            case 'audio':\r\n                {\r\n                    if (gotAudio)\r\n                        continue;\r\n                    gotAudio = true;\r\n                    break;\r\n                }\r\n            case 'video':\r\n                {\r\n                    if (gotVideo)\r\n                        continue;\r\n                    gotVideo = true;\r\n                    break;\r\n                }\r\n            default:\r\n                {\r\n                    continue;\r\n                }\r\n        }\r\n        for (const rtp of m.rtp) {\r\n            const codec = {\r\n                kind: kind,\r\n                mimeType: `${kind}/${rtp.codec}`,\r\n                preferredPayloadType: rtp.payload,\r\n                clockRate: rtp.rate,\r\n                channels: rtp.encoding,\r\n                parameters: {},\r\n                rtcpFeedback: []\r\n            };\r\n            codecsMap.set(codec.preferredPayloadType, codec);\r\n        }\r\n        for (const fmtp of m.fmtp || []) {\r\n            const parameters = sdpTransform.parseParams(fmtp.config);\r\n            const codec = codecsMap.get(fmtp.payload);\r\n            if (!codec)\r\n                continue;\r\n            if (parameters && parameters['profile-level-id'])\r\n                parameters['profile-level-id'] = String(parameters['profile-level-id']);\r\n            codec.parameters = parameters;\r\n        }\r\n        for (const fb of m.rtcpFb || []) {\r\n            const codec = codecsMap.get(fb.payload);\r\n            if (!codec)\r\n                continue;\r\n            const feedback = {\r\n                type: fb.type,\r\n                parameter: fb.subtype\r\n            };\r\n            if (!feedback.parameter)\r\n                delete feedback.parameter;\r\n            codec.rtcpFeedback.push(feedback);\r\n        }\r\n        for (const ext of m.ext || []) {\r\n            if (ext['encrypt-uri'])\r\n                continue;\r\n            const headerExtension = {\r\n                kind: kind,\r\n                uri: ext.uri,\r\n                preferredId: ext.value\r\n            };\r\n            headerExtensions.push(headerExtension);\r\n        }\r\n    }\r\n    const rtpCapabilities = {\r\n        codecs: Array.from(codecsMap.values()),\r\n        headerExtensions: headerExtensions\r\n    };\r\n    return rtpCapabilities;\r\n}\r\nexports.extractRtpCapabilities = extractRtpCapabilities;\r\nfunction extractDtlsParameters({ sdpObject }) {\r\n    const mediaObject = (sdpObject.media || [])\r\n        .find((m) => (m.iceUfrag && m.port !== 0));\r\n    if (!mediaObject)\r\n        throw new Error('no active media section found');\r\n    const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\r\n    let role;\r\n    switch (mediaObject.setup) {\r\n        case 'active':\r\n            role = 'client';\r\n            break;\r\n        case 'passive':\r\n            role = 'server';\r\n            break;\r\n        case 'actpass':\r\n            role = 'auto';\r\n            break;\r\n    }\r\n    const dtlsParameters = {\r\n        role,\r\n        fingerprints: [\r\n            {\r\n                algorithm: fingerprint.type,\r\n                value: fingerprint.hash\r\n            }\r\n        ]\r\n    };\r\n    return dtlsParameters;\r\n}\r\nexports.extractDtlsParameters = extractDtlsParameters;\r\nfunction getCname({ offerMediaObject }) {\r\n    const ssrcCnameLine = (offerMediaObject.ssrcs || [])\r\n        .find((line) => line.attribute === 'cname');\r\n    if (!ssrcCnameLine)\r\n        return '';\r\n    return ssrcCnameLine.value;\r\n}\r\nexports.getCname = getCname;\r\nfunction applyCodecParameters({ offerRtpParameters, answerMediaObject }) {\r\n    for (const codec of offerRtpParameters.codecs) {\r\n        const mimeType = codec.mimeType.toLowerCase();\r\n        if (mimeType !== 'audio/opus')\r\n            continue;\r\n        const rtp = (answerMediaObject.rtp || [])\r\n            .find((r) => r.payload === codec.payloadType);\r\n        if (!rtp)\r\n            continue;\r\n        answerMediaObject.fmtp = answerMediaObject.fmtp || [];\r\n        let fmtp = answerMediaObject.fmtp\r\n            .find((f) => f.payload === codec.payloadType);\r\n        if (!fmtp) {\r\n            fmtp = { payload: codec.payloadType, config: '' };\r\n            answerMediaObject.fmtp.push(fmtp);\r\n        }\r\n        const parameters = sdpTransform.parseParams(fmtp.config);\r\n        switch (mimeType) {\r\n            case 'audio/opus':\r\n                {\r\n                    const spropStereo = codec.parameters['sprop-stereo'];\r\n                    if (spropStereo !== undefined)\r\n                        parameters.stereo = spropStereo ? 1 : 0;\r\n                    break;\r\n                }\r\n        }\r\n        fmtp.config = '';\r\n        for (const key of Object.keys(parameters)) {\r\n            if (fmtp.config)\r\n                fmtp.config += ';';\r\n            fmtp.config += `${key}=${parameters[key]}`;\r\n        }\r\n    }\r\n}\r\nexports.applyCodecParameters = applyCodecParameters;\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/commonUtils.ts?");

/***/ }),

/***/ "./src/handlers/sdp/planBUtils.ts":
/*!****************************************!*\
  !*** ./src/handlers/sdp/planBUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getRtpEncodings({ offerMediaObject, track }) {\r\n    let firstSsrc;\r\n    const ssrcs = new Set();\r\n    for (const line of offerMediaObject.ssrcs || []) {\r\n        if (line.attribute !== 'msid')\r\n            continue;\r\n        const trackId = line.value.split(' ')[1];\r\n        if (trackId === track.id) {\r\n            const ssrc = line.id;\r\n            ssrcs.add(ssrc);\r\n            if (!firstSsrc)\r\n                firstSsrc = ssrc;\r\n        }\r\n    }\r\n    if (ssrcs.size === 0)\r\n        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);\r\n    const ssrcToRtxSsrc = new Map();\r\n    for (const line of offerMediaObject.ssrcGroups || []) {\r\n        if (line.semantics !== 'FID')\r\n            continue;\r\n        let [ssrc, rtxSsrc] = line.ssrcs.split(/\\s+/);\r\n        ssrc = Number(ssrc);\r\n        rtxSsrc = Number(rtxSsrc);\r\n        if (ssrcs.has(ssrc)) {\r\n            ssrcs.delete(ssrc);\r\n            ssrcs.delete(rtxSsrc);\r\n            ssrcToRtxSsrc.set(ssrc, rtxSsrc);\r\n        }\r\n    }\r\n    for (const ssrc of ssrcs) {\r\n        ssrcToRtxSsrc.set(ssrc, null);\r\n    }\r\n    const encodings = [];\r\n    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {\r\n        const encoding = { ssrc };\r\n        if (rtxSsrc)\r\n            encoding.rtx = { ssrc: rtxSsrc };\r\n        encodings.push(encoding);\r\n    }\r\n    return encodings;\r\n}\r\nexports.getRtpEncodings = getRtpEncodings;\r\nfunction addLegacySimulcast({ offerMediaObject, track, numStreams }) {\r\n    if (numStreams <= 1)\r\n        throw new TypeError('numStreams must be greater than 1');\r\n    let firstSsrc;\r\n    let firstRtxSsrc;\r\n    let streamId;\r\n    const ssrcMsidLine = (offerMediaObject.ssrcs || [])\r\n        .find((line) => {\r\n        if (line.attribute !== 'msid')\r\n            return false;\r\n        const trackId = line.value.split(' ')[1];\r\n        if (trackId === track.id) {\r\n            firstSsrc = line.id;\r\n            streamId = line.value.split(' ')[0];\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    });\r\n    if (!ssrcMsidLine)\r\n        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);\r\n    (offerMediaObject.ssrcGroups || [])\r\n        .some((line) => {\r\n        if (line.semantics !== 'FID')\r\n            return false;\r\n        const ssrcs = line.ssrcs.split(/\\s+/);\r\n        if (Number(ssrcs[0]) === firstSsrc) {\r\n            firstRtxSsrc = Number(ssrcs[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    });\r\n    const ssrcCnameLine = offerMediaObject.ssrcs\r\n        .find((line) => (line.attribute === 'cname' && line.id === firstSsrc));\r\n    if (!ssrcCnameLine)\r\n        throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);\r\n    const cname = ssrcCnameLine.value;\r\n    const ssrcs = [];\r\n    const rtxSsrcs = [];\r\n    for (let i = 0; i < numStreams; ++i) {\r\n        ssrcs.push(firstSsrc + i);\r\n        if (firstRtxSsrc)\r\n            rtxSsrcs.push(firstRtxSsrc + i);\r\n    }\r\n    offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];\r\n    offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];\r\n    offerMediaObject.ssrcGroups.push({\r\n        semantics: 'SIM',\r\n        ssrcs: ssrcs.join(' ')\r\n    });\r\n    for (let i = 0; i < ssrcs.length; ++i) {\r\n        const ssrc = ssrcs[i];\r\n        offerMediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'cname',\r\n            value: cname\r\n        });\r\n        offerMediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'msid',\r\n            value: `${streamId} ${track.id}`\r\n        });\r\n    }\r\n    for (let i = 0; i < rtxSsrcs.length; ++i) {\r\n        const ssrc = ssrcs[i];\r\n        const rtxSsrc = rtxSsrcs[i];\r\n        offerMediaObject.ssrcs.push({\r\n            id: rtxSsrc,\r\n            attribute: 'cname',\r\n            value: cname\r\n        });\r\n        offerMediaObject.ssrcs.push({\r\n            id: rtxSsrc,\r\n            attribute: 'msid',\r\n            value: `${streamId} ${track.id}`\r\n        });\r\n        offerMediaObject.ssrcGroups.push({\r\n            semantics: 'FID',\r\n            ssrcs: `${ssrc} ${rtxSsrc}`\r\n        });\r\n    }\r\n}\r\nexports.addLegacySimulcast = addLegacySimulcast;\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/planBUtils.ts?");

/***/ }),

/***/ "./src/handlers/sdp/unifiedPlanUtils.ts":
/*!**********************************************!*\
  !*** ./src/handlers/sdp/unifiedPlanUtils.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getRtpEncodings({ offerMediaObject }) {\r\n    const ssrcs = new Set();\r\n    for (const line of offerMediaObject.ssrcs || []) {\r\n        const ssrc = line.id;\r\n        ssrcs.add(ssrc);\r\n    }\r\n    if (ssrcs.size === 0)\r\n        throw new Error('no a=ssrc lines found');\r\n    const ssrcToRtxSsrc = new Map();\r\n    for (const line of offerMediaObject.ssrcGroups || []) {\r\n        if (line.semantics !== 'FID')\r\n            continue;\r\n        let [ssrc, rtxSsrc] = line.ssrcs.split(/\\s+/);\r\n        ssrc = Number(ssrc);\r\n        rtxSsrc = Number(rtxSsrc);\r\n        if (ssrcs.has(ssrc)) {\r\n            ssrcs.delete(ssrc);\r\n            ssrcs.delete(rtxSsrc);\r\n            ssrcToRtxSsrc.set(ssrc, rtxSsrc);\r\n        }\r\n    }\r\n    for (const ssrc of ssrcs) {\r\n        ssrcToRtxSsrc.set(ssrc, null);\r\n    }\r\n    const encodings = [];\r\n    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {\r\n        const encoding = { ssrc };\r\n        if (rtxSsrc)\r\n            encoding.rtx = { ssrc: rtxSsrc };\r\n        encodings.push(encoding);\r\n    }\r\n    return encodings;\r\n}\r\nexports.getRtpEncodings = getRtpEncodings;\r\nfunction addLegacySimulcast({ offerMediaObject, numStreams }) {\r\n    if (numStreams <= 1)\r\n        throw new TypeError('numStreams must be greater than 1');\r\n    const ssrcMsidLine = (offerMediaObject.ssrcs || [])\r\n        .find((line) => line.attribute === 'msid');\r\n    if (!ssrcMsidLine)\r\n        throw new Error('a=ssrc line with msid information not found');\r\n    const [streamId, trackId] = ssrcMsidLine.value.split(' ')[0];\r\n    const firstSsrc = ssrcMsidLine.id;\r\n    let firstRtxSsrc;\r\n    (offerMediaObject.ssrcGroups || [])\r\n        .some((line) => {\r\n        if (line.semantics !== 'FID')\r\n            return false;\r\n        const ssrcs = line.ssrcs.split(/\\s+/);\r\n        if (Number(ssrcs[0]) === firstSsrc) {\r\n            firstRtxSsrc = Number(ssrcs[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    });\r\n    const ssrcCnameLine = offerMediaObject.ssrcs\r\n        .find((line) => line.attribute === 'cname');\r\n    if (!ssrcCnameLine)\r\n        throw new Error('a=ssrc line with cname information not found');\r\n    const cname = ssrcCnameLine.value;\r\n    const ssrcs = [];\r\n    const rtxSsrcs = [];\r\n    for (let i = 0; i < numStreams; ++i) {\r\n        ssrcs.push(firstSsrc + i);\r\n        if (firstRtxSsrc)\r\n            rtxSsrcs.push(firstRtxSsrc + i);\r\n    }\r\n    offerMediaObject.ssrcGroups = [];\r\n    offerMediaObject.ssrcs = [];\r\n    offerMediaObject.ssrcGroups.push({\r\n        semantics: 'SIM',\r\n        ssrcs: ssrcs.join(' ')\r\n    });\r\n    for (let i = 0; i < ssrcs.length; ++i) {\r\n        const ssrc = ssrcs[i];\r\n        offerMediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'cname',\r\n            value: cname\r\n        });\r\n        offerMediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'msid',\r\n            value: `${streamId} ${trackId}`\r\n        });\r\n    }\r\n    for (let i = 0; i < rtxSsrcs.length; ++i) {\r\n        const ssrc = ssrcs[i];\r\n        const rtxSsrc = rtxSsrcs[i];\r\n        offerMediaObject.ssrcs.push({\r\n            id: rtxSsrc,\r\n            attribute: 'cname',\r\n            value: cname\r\n        });\r\n        offerMediaObject.ssrcs.push({\r\n            id: rtxSsrc,\r\n            attribute: 'msid',\r\n            value: `${streamId} ${trackId}`\r\n        });\r\n        offerMediaObject.ssrcGroups.push({\r\n            semantics: 'FID',\r\n            ssrcs: `${ssrc} ${rtxSsrc}`\r\n        });\r\n    }\r\n}\r\nexports.addLegacySimulcast = addLegacySimulcast;\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/unifiedPlanUtils.ts?");

/***/ }),

/***/ "./src/mcs8Client.ts":
/*!***************************!*\
  !*** ./src/mcs8Client.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst index_1 = __importDefault(__webpack_require__(/*! ./websocketClient/index */ \"./src/websocketClient/index.js\"));\r\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\r\nconst blueimp_md5_1 = __importDefault(__webpack_require__(/*! blueimp-md5 */ \"./node_modules/blueimp-md5/js/md5.js\"));\r\nconst mediaClient_1 = __webpack_require__(/*! ./mediaClient */ \"./src/mediaClient.ts\");\r\nconst crypto_js_1 = __webpack_require__(/*! crypto-js */ \"./node_modules/crypto-js/index.js\");\r\nclass mcs8Client extends events_1.EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this._mediaClientList = new Map();\r\n    }\r\n    connect(setting) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._setting = setting;\r\n            const timestamp = Math.floor(Date.now() / 1000);\r\n            let encryType = \"v1\";\r\n            if (setting.encryType == 'v2') {\r\n                encryType = setting.encryType;\r\n            }\r\n            let md5Pwd = yield this.getPwdSignature(setting.pwd, encryType, timestamp);\r\n            let baseUrl = 'ws://';\r\n            if (this._setting.ssl == true) {\r\n                baseUrl = 'wss://';\r\n                this._setting.ssl = true;\r\n            }\r\n            if (baseUrl == 'ws://') {\r\n                if (window.location.protocol.indexOf(\"https\") != -1) {\r\n                    baseUrl = 'wss://';\r\n                    this._setting.ssl = true;\r\n                }\r\n            }\r\n            baseUrl += this._setting.host;\r\n            if (this._setting.httpProxy != null && this._setting.httpProxy != '') {\r\n                baseUrl += this._setting.httpProxy;\r\n            }\r\n            else {\r\n                baseUrl += \":\" + this._setting.port;\r\n            }\r\n            let _protooUrl = baseUrl + '?uid=' + this._setting.uid + '&pwd=' + md5Pwd + '&type=2&v=' + setting.encryType + '&t=' + timestamp;\r\n            if (setting.isLogin != null && setting.isLogin == 1) {\r\n                _protooUrl += '&l=1';\r\n            }\r\n            let options = { subprotocol: '' };\r\n            if (setting.subprotocol != null && setting.subprotocol != '') {\r\n                options.subprotocol = setting.subprotocol;\r\n            }\r\n            const protooTransport = new index_1.default.WebSocketTransport(_protooUrl, options);\r\n            this._protoo = new index_1.default.Peer(protooTransport);\r\n            this._protoo.on('open', () => {\r\n                const _req = { request: true, errCode: 200, method: \"responseConnectGateway\", data: { ip: this._setting.host, port: this._setting.port } };\r\n                this.emit('OnManage', _req);\r\n                console.log('geteway:opened');\r\n            });\r\n            this._protoo.on('failed', (resultError) => {\r\n                let error = 502;\r\n                if (resultError != null) {\r\n                    error = resultError;\r\n                }\r\n                const _req = { request: true, errCode: error, method: \"responseConnectGateway\", data: { ip: this._setting.host, port: this._setting.port } };\r\n                this.emit('OnManage', _req);\r\n                console.log('geteway:failed');\r\n            });\r\n            this._protoo.on('disconnected', (e) => {\r\n                const _req = { request: true, errCode: 401, method: \"responseConnectGateway\", data: { ip: this._setting.host, port: this._setting.port } };\r\n                this.emit('OnManage', _req);\r\n                console.log('geteway:disconnected');\r\n            });\r\n            this._protoo.on('close', (resultError) => {\r\n                let error = 500;\r\n                if (resultError != null) {\r\n                    error = resultError;\r\n                }\r\n                const _req = { request: true, errCode: error, method: \"responseConnectGateway\", data: { ip: this._setting.host, port: this._setting.port } };\r\n                this.emit('OnManage', _req);\r\n                if (this._closed)\r\n                    return;\r\n                console.log('geteway:close');\r\n            });\r\n            this._protoo.on('request', (request, accept, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                this.onServerResponse(request, accept, reject);\r\n            }));\r\n            this._protoo.on('notification', (request, accept, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                this.onServerResponse(request, accept, reject);\r\n            }));\r\n        });\r\n    }\r\n    getPwdSignature(pwd, version, timestamp) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let md5pwd = blueimp_md5_1.default(pwd);\r\n            if (version == 'v2') {\r\n                md5pwd = crypto_js_1.SHA256(md5pwd + '' + timestamp).toString();\r\n            }\r\n            return md5pwd;\r\n        });\r\n    }\r\n    onServerResponse(request, accept, reject) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            console.log('proto \"request\" event [method:%s, data:%o]', request.method, request.data);\r\n            if (request.request == true) {\r\n                accept();\r\n            }\r\n            switch (request.method) {\r\n                case 'ConnecteInfo':\r\n                    {\r\n                        this._loginInfo = request.data;\r\n                        const connParam = { groupId: 'mcs8_admin', talkGroupType: TalkGroupType.none, temGroupType: TalkGroupType.VideoMonitoring_consumer, isCreator: 0, appdata: null, localAudioPause: false };\r\n                        this.add2MediaGroup(connParam);\r\n                    }\r\n                    this.emit('OnManage', request);\r\n                    break;\r\n                default:\r\n                    const _req = { request: true, errCode: 200, method: request.method, \"data\": request.data };\r\n                    this.emit('OnManage', _req);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    add2MediaGroup({ groupId, talkGroupType, temGroupType, isCreator, appdata, istalk = false, did = '', devMeeting = false, localAudioPause = false }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null || groupId == '') {\r\n                return 400;\r\n            }\r\n            const _client = this._mediaClientList.get(groupId);\r\n            if (_client != null) {\r\n                yield _client.close();\r\n            }\r\n            let _mediaPort = this._loginInfo.mediaPort;\r\n            let mediaIp = this._loginInfo.mediaIp;\r\n            let httpProxy = null;\r\n            if (this._loginInfo.mediaHttpProxy != null && this._loginInfo.mediaHttpProxy != '') {\r\n                httpProxy = this._loginInfo.mediaHttpProxy;\r\n            }\r\n            if (this._setting.ssl == true) {\r\n                _mediaPort = this._loginInfo.mediaSslPort;\r\n                mediaIp = this._loginInfo.mediaDomain;\r\n            }\r\n            if (this._setting.privateNet != null && this._setting.privateNet == true) {\r\n                mediaIp = this._loginInfo.MediaPrivateIp;\r\n            }\r\n            let _enableTcp = false;\r\n            if (this._loginInfo.enableTcp == true) {\r\n                _enableTcp = true;\r\n            }\r\n            const serverInfo = {\r\n                mediaIp: mediaIp,\r\n                mediaPort: _mediaPort,\r\n                mediaHttpProxy: httpProxy,\r\n                token: this._loginInfo.token,\r\n                ssl: this._setting.ssl,\r\n                rid: groupId,\r\n                userType: istalk == true ? 4 : this._loginInfo.userType,\r\n                did: this._loginInfo.devid,\r\n                talkGroupType,\r\n                temGroupType,\r\n                isCreator,\r\n                setting: this._setting,\r\n                appdata,\r\n                istalk,\r\n                devMeeting,\r\n                enableTcp: _enableTcp\r\n            };\r\n            const mediaClient = new mediaClient_1.mcs8MediaClient();\r\n            mediaClient.on('OnManage', (request) => __awaiter(this, void 0, void 0, function* () {\r\n                this.emit('OnManage', request);\r\n                switch (request.method) {\r\n                    case 'joinRoom':\r\n                        {\r\n                        }\r\n                        break;\r\n                    case 'connectTransport':\r\n                        {\r\n                        }\r\n                    case 'produce':\r\n                        if (mediaClient._isSendJoinRoomAndProduct == false) {\r\n                            if (serverInfo.isCreator == 1) {\r\n                                let destDevList = [];\r\n                                for (const devMoel of serverInfo.appdata) {\r\n                                    destDevList.push(devMoel.devId);\r\n                                }\r\n                                destDevList = yield this.DevListUnique(destDevList);\r\n                                const joinRoomParam = {\r\n                                    roomId: serverInfo.rid,\r\n                                    TalkGroupType: serverInfo.talkGroupType,\r\n                                    creatorId: this._loginInfo.devid,\r\n                                    devList: destDevList\r\n                                };\r\n                                this.requestMsg2GatewayServer('JoinRoomAndProduct', joinRoomParam);\r\n                                mediaClient._isSendJoinRoomAndProduct = true;\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n                console.log(JSON.stringify(request));\r\n            }));\r\n            this._mediaClientList.set(serverInfo.rid, mediaClient);\r\n            mediaClient.connectMedia(serverInfo, false, localAudioPause);\r\n            return mediaClient;\r\n        });\r\n    }\r\n    DevListUnique(arr) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let newArr = [arr[0]];\r\n            for (let i = 1; i < arr.length; i++) {\r\n                let repeat = false;\r\n                for (let j = 0; j < newArr.length; j++) {\r\n                    if (arr[i] === newArr[j]) {\r\n                        repeat = true;\r\n                        break;\r\n                    }\r\n                    else {\r\n                    }\r\n                }\r\n                if (!repeat) {\r\n                    newArr.push(arr[i]);\r\n                }\r\n            }\r\n            return newArr;\r\n        });\r\n    }\r\n    joinMediaGroup(roomId, talkGroupType, devList) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const connParam = { groupId: roomId, talkGroupType: talkGroupType, temGroupType: TemGroupType.Group, isCreator: 0, appdata: devList };\r\n            yield this.add2MediaGroup(connParam);\r\n            if (devList != null) {\r\n                for (const devModel of devList) {\r\n                    if (devModel.devId != this._setting.uid) {\r\n                        var ShowObject = { groupId: roomId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n                        this.addShowObject(ShowObject);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    CreateTempMediaGroup(groupId, groupType, devList) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            if (groupType != 4 && groupType != 5 && groupType != 6) {\r\n                return 400;\r\n            }\r\n            const result = yield this.checkInputDevice(groupType);\r\n            if (result != 200) {\r\n                return result;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: groupType, temGroupType: TemGroupType.Group, isCreator: 1, appdata: devList, localAudioPause: false };\r\n            yield this.add2MediaGroup(connParam);\r\n            if (devList != null) {\r\n                for (const devModel of devList) {\r\n                    var ShowObject = { groupId: groupId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n                    this.addShowObject(ShowObject);\r\n                }\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    CreateP2pMediaGroup(groupId, groupType, devModel) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            if (groupType != 4 && groupType != 5 && groupType != 6) {\r\n                return 400;\r\n            }\r\n            const result = yield this.checkInputDevice(groupType);\r\n            if (result != 200) {\r\n                return result;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: groupType, temGroupType: TemGroupType.p2p, isCreator: 1, appdata: [devModel] };\r\n            yield this.add2MediaGroup(connParam);\r\n            var ShowObject = { groupId: groupId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n            this.addShowObject(ShowObject);\r\n            return 200;\r\n        });\r\n    }\r\n    CreateP2pMediaGroupEx(groupId, groupType, destDevId, htmlAudio, htmlVideo, _localAudioPause) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            if (groupType != 4 && groupType != 5 && groupType != 6) {\r\n                return 400;\r\n            }\r\n            const result = yield this.checkInputDevice(groupType);\r\n            if (result != 200) {\r\n                return result;\r\n            }\r\n            var devList = [];\r\n            if (htmlAudio != null) {\r\n                devList.push({ kind: 'audio', devId: destDevId, showObj: htmlAudio });\r\n            }\r\n            if (htmlVideo != null) {\r\n                devList.push({ kind: 'video', devId: destDevId, showObj: htmlVideo });\r\n            }\r\n            if (devList.length == 0) {\r\n                return 412;\r\n            }\r\n            let localAudioPause = false;\r\n            if (_localAudioPause != null && _localAudioPause == true) {\r\n                localAudioPause = true;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: groupType, temGroupType: TemGroupType.p2p, isCreator: 1, appdata: devList, localAudioPause };\r\n            yield this.add2MediaGroup(connParam);\r\n            for (const devModel of devList) {\r\n                var ShowObject = { groupId: groupId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n                this.addShowObject(ShowObject);\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    CreateDevMeeting(groupId, groupType, devList) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            const result = yield this.checkInputDevice(groupType);\r\n            if (result != 200) {\r\n                return result;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: groupType, temGroupType: TemGroupType.Group, isCreator: 1, appdata: devList, devMeeting: true };\r\n            yield this.add2MediaGroup(connParam);\r\n            if (devList != null) {\r\n                for (const devModel of devList) {\r\n                    var ShowObject = { groupId: groupId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n                    this.addShowObject(ShowObject);\r\n                }\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    checkInputDevice(groupType) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const InputVideoAudio = yield this.GetAudioAndVideo();\r\n            if (groupType == 5) {\r\n                if (InputVideoAudio.videoinput == false && InputVideoAudio.audioinput == false) {\r\n                    const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { devices: InputVideoAudio, content: \"Input device not found\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return 404;\r\n                }\r\n            }\r\n            else {\r\n                if (InputVideoAudio.audioinput == false) {\r\n                    const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { devices: InputVideoAudio, content: \"Input device not found\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return 404;\r\n                }\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    GetAudioAndVideo() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const resultModel = { videoinput: false, audioinput: false, audiooutput: false };\r\n            if (navigator.mediaDevices != null) {\r\n                const mediadevList = yield navigator.mediaDevices.enumerateDevices();\r\n                for (const omediadev of mediadevList) {\r\n                    if (omediadev.kind == 'audioinput') {\r\n                        resultModel.audioinput = true;\r\n                    }\r\n                    if (omediadev.kind == 'audiooutput') {\r\n                        resultModel.audiooutput = true;\r\n                    }\r\n                    if (omediadev.kind == 'videoinput') {\r\n                        resultModel.videoinput = true;\r\n                    }\r\n                }\r\n            }\r\n            return resultModel;\r\n        });\r\n    }\r\n    openDeviceTalk(devId, groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.setDeviceTalk(devId, groupId, false);\r\n        });\r\n    }\r\n    closeDeviceTalk(devId, groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.setDeviceTalk(devId, groupId, true);\r\n        });\r\n    }\r\n    setDeviceTalk(devId, groupId, isPause) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let resultModel = { errorCode: 500, content: '', talkId: '' };\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                resultModel.errorCode = 404;\r\n                resultModel.content = 'can not found ' + groupId;\r\n                return resultModel;\r\n            }\r\n            const requestParam = { devId, kind: 'audio', isPause, talkId: this._loginInfo.devid };\r\n            const result = yield mediaClient.requestMsg('setDevMediaConsumer', requestParam);\r\n            resultModel.errorCode = result.errorCode;\r\n            resultModel.talkId = resultModel.talkId;\r\n            return resultModel;\r\n        });\r\n    }\r\n    startTalk(devId, channelId, groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null || groupId == '') {\r\n                const roomModel = yield this.requestMsg2GatewayServer('getRoomIdByDevId', { devId });\r\n                if (roomModel == null) {\r\n                    return 400;\r\n                }\r\n                groupId = roomModel.roomId;\r\n            }\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: 3, temGroupType: 0, isCreator: 0, appdata: [devId, channelId], istalk: true, did: devId };\r\n            yield this.add2MediaGroup(connParam);\r\n            return 200;\r\n        });\r\n    }\r\n    stopTalk(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null || groupId == '') {\r\n                let resultError = 404;\r\n                for (const mediaClient of this._mediaClientList.values()) {\r\n                    if (mediaClient._loginInfo.istalk == true) {\r\n                        yield mediaClient.close();\r\n                        resultError = 200;\r\n                    }\r\n                }\r\n                return resultError;\r\n            }\r\n            else {\r\n                return yield this.closeGroup(groupId);\r\n            }\r\n        });\r\n    }\r\n    openVideo(_devId, _showObj, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                const connParam = { groupId: 'mcs8_admin', talkGroupType: TalkGroupType.none, temGroupType: TalkGroupType.VideoMonitoring_consumer, isCreator: 0, appdata: null };\r\n                mediaClient = yield this.add2MediaGroup(connParam);\r\n            }\r\n            if (mediaClient == null) {\r\n                return 500;\r\n            }\r\n            var chanId = channelId;\r\n            if (chanId == null) {\r\n                chanId = \"\";\r\n            }\r\n            const param = { kind: 'video', devId: _devId, streamType: 2, showObj: _showObj, channelId: chanId };\r\n            return yield mediaClient.openVideo(param);\r\n        });\r\n    }\r\n    closeVideo(_devId, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            var chanId = channelId;\r\n            if (chanId == null) {\r\n                chanId = \"\";\r\n            }\r\n            const param = { kind: 'video', devId: _devId, streamType: 2, channelId: chanId };\r\n            return yield mediaClient.stopVideo(param);\r\n        });\r\n    }\r\n    openAudio(_devId, _showObj, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const param = { kind: 'audio', devId: _devId, streamType: 0, channelId, showObj: _showObj };\r\n            return yield mediaClient.openVideo(param);\r\n        });\r\n    }\r\n    closeAudio(_devId, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const param = { kind: 'audio', devId: _devId, streamType: 0, channelId };\r\n            return yield mediaClient.stopVideo(param);\r\n        });\r\n    }\r\n    startSendVideo(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const sendMedioObj = { kind: 'video', streamType: 2, showObj: this._setting.localVideo, stream: null };\r\n            return mediaClient.sendMedia(sendMedioObj);\r\n        });\r\n    }\r\n    stopSendVideo(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            return mediaClient.closeSendMdia('video');\r\n        });\r\n    }\r\n    startSendAudio(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const sendMedioObj = { kind: 'audio', streamType: 0, showObj: this._setting.localVideo, stream: null };\r\n            return mediaClient.sendMedia(sendMedioObj);\r\n        });\r\n    }\r\n    stopSendAudio(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            return mediaClient.closeSendMdia('audio');\r\n        });\r\n    }\r\n    applyTalk(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = yield this.requestMsg2MediaServer(groupId, 'applyTalk', null);\r\n            if (result.status == 1) {\r\n                let mediaClient = yield this.getMediaClient(groupId);\r\n                if (mediaClient != null) {\r\n                    mediaClient.resume('audio');\r\n                }\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    pause(groupId, kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient != null) {\r\n                mediaClient.pause(kind);\r\n            }\r\n        });\r\n    }\r\n    resume(groupId, kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient != null) {\r\n                mediaClient.resume(kind);\r\n            }\r\n        });\r\n    }\r\n    freeTalker(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = this.requestMsg2MediaServer(groupId, 'freeTalker', null);\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient != null) {\r\n                mediaClient.pause('audio');\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    startPlayBack({ devId, channelId, startTime, endTime, sessionId, fileName, fileId, htmlVideo, htmlAudio }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            if (htmlVideo == null) {\r\n                return 411;\r\n            }\r\n            const videoResult = yield mediaClient.startPlayBack({ devId, channelId, startTime, endTime, sessionId, fileName, fileId, htmlVideo, htmlAudio });\r\n            return videoResult;\r\n        });\r\n    }\r\n    stopPlayBack(sessionId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const resutl = yield mediaClient.stopPlayBack(sessionId);\r\n            return resutl;\r\n        });\r\n    }\r\n    playBackCtrl(sessionId, speed) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const resutl = yield mediaClient.playBackCtrl(sessionId, speed);\r\n            return resutl;\r\n        });\r\n    }\r\n    playBackMove(sessionId, position) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const resutl = yield mediaClient.playBackMove(sessionId, position);\r\n            return resutl;\r\n        });\r\n    }\r\n    openPlayBackSound(sessionId, isOpen) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const resutl = yield mediaClient.openPlayBackSound(sessionId, isOpen);\r\n            return resutl;\r\n        });\r\n    }\r\n    addShowObject({ groupId, devId, kind, showObj }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            mediaClient.addShowObject({ groupId, devId, kind, showObj });\r\n            return 200;\r\n        });\r\n    }\r\n    requestMsg2GatewayServer(method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._protoo == null) {\r\n                return 500;\r\n            }\r\n            return yield this._protoo.request(method, data);\r\n        });\r\n    }\r\n    notifyMsg2GatewayServer(method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._protoo.request == null) {\r\n                return 500;\r\n            }\r\n            this._protoo.notify(method, data);\r\n            return 200;\r\n        });\r\n    }\r\n    requestMsg2MediaServer(groupId, method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            return mediaClient.requestMsg(method, data);\r\n        });\r\n    }\r\n    notifyMsg2MediaServer(groupId, method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            return mediaClient.notifyMsg(method, data);\r\n        });\r\n    }\r\n    getMediaClient(GroupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let meidaClient = this._mediaClientList.get(GroupId);\r\n            return meidaClient;\r\n        });\r\n    }\r\n    closeGroup(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const meidaClient = yield this.getMediaClient(groupId);\r\n                if (meidaClient == null) {\r\n                    return 404;\r\n                }\r\n                yield meidaClient.close();\r\n                if (meidaClient._loginInfo != null && meidaClient._loginInfo.isCreator == 1) {\r\n                    let destDevList = [];\r\n                    for (const devMoel of meidaClient._loginInfo.appdata) {\r\n                        destDevList.push(devMoel.devId);\r\n                    }\r\n                    destDevList = yield this.DevListUnique(destDevList);\r\n                    const meetingOutData = {\r\n                        roomId: meidaClient._loginInfo.rid,\r\n                        creatorId: meidaClient._loginInfo.devid,\r\n                        devList: destDevList\r\n                    };\r\n                    this.requestMsg2GatewayServer(\"meetingOut\", meetingOutData);\r\n                }\r\n                return 200;\r\n            }\r\n            catch (ex) {\r\n            }\r\n            return 500;\r\n        });\r\n    }\r\n    close() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            for (const key of this._mediaClientList.keys()) {\r\n                yield this.closeGroup(key);\r\n            }\r\n            if (this._protoo != null) {\r\n                yield this._protoo.close();\r\n            }\r\n        });\r\n    }\r\n    setLocalVideoOrAudioObject({ localVideo, localAudio, groupId }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (localVideo != null) {\r\n                this._setting.localVideo = localVideo;\r\n            }\r\n            if (localAudio != null) {\r\n                this._setting.localAudio = localAudio;\r\n            }\r\n            if (groupId != null) {\r\n                let meidaClient = yield this.getMediaClient(groupId);\r\n                if (meidaClient != null) {\r\n                    meidaClient.setLocalVideoOrAudioObject({ localVideo, localAudio });\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.mcs8Client = mcs8Client;\r\nconst TemGroupType = {\r\n    none: 0,\r\n    p2p: 1,\r\n    Group: 2\r\n};\r\nconst TalkGroupType = {\r\n    none: 0,\r\n    Company: 1,\r\n    DevGroup: 3,\r\n    AudioDispatch: 4,\r\n    VideoDispatch: 5,\r\n    AudioTalk: 6,\r\n    VideoMonitoring_procuct: 7,\r\n    AudioMonitoring_product: 8,\r\n    VideoMonitoring_consumer: 9,\r\n    AudioMonitoring_consumer: 10,\r\n};\r\n\n\n//# sourceURL=webpack:///./src/mcs8Client.ts?");

/***/ }),

/***/ "./src/mediaClient.ts":
/*!****************************!*\
  !*** ./src/mediaClient.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Device_1 = __webpack_require__(/*! ./Device */ \"./src/Device.ts\");\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst index_1 = __importDefault(__webpack_require__(/*! ./websocketClient/index */ \"./src/websocketClient/index.js\"));\r\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\r\nconst logger = new Logger_1.Logger('mcs8MediaClient');\r\nclass mcs8MediaClient extends events_1.EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this._device = new Device_1.Device();\r\n        this._isSendJoinRoomAndProduct = false;\r\n        this._consumerList = new Map();\r\n        this._showVideoList = new Map();\r\n        this._showAudioList = new Map();\r\n        this._sendMediaList = new Map();\r\n        this._playBackList = new Map();\r\n    }\r\n    connectMedia(_serverInfo, isSubTalk, localAudioPause) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._loginInfo = _serverInfo;\r\n            let baseUrl = 'ws://';\r\n            if (_serverInfo.ssl == true) {\r\n                baseUrl = 'wss://';\r\n            }\r\n            let _userType = _serverInfo.userType;\r\n            let talkGroupType = _serverInfo.talkGroupType;\r\n            if (_serverInfo.devMeeting == true) {\r\n                talkGroupType = 11;\r\n            }\r\n            let url = baseUrl + _serverInfo.mediaIp;\r\n            if (_serverInfo.mediaHttpProxy != null && _serverInfo.mediaHttpProxy != '') {\r\n                url += _serverInfo.mediaHttpProxy;\r\n            }\r\n            else {\r\n                url += \":\" + _serverInfo.mediaPort;\r\n            }\r\n            url += '/?token=' + _serverInfo.token + '&did=' + _serverInfo.did + '&rid=' + _serverInfo.rid + '&t=' + _userType + '&ct=' + _serverInfo.temGroupType + '&gt=' + talkGroupType + '&o=' + _serverInfo.isCreator;\r\n            let options = { subprotocol: '' };\r\n            if (_serverInfo.subprotocol != null && _serverInfo.subprotocol != '') {\r\n                options.subprotocol = _serverInfo.subprotocol;\r\n            }\r\n            const protooTransport = new index_1.default.WebSocketTransport(url, options);\r\n            this._protoo = new index_1.default.Peer(protooTransport);\r\n            this._protoo.on('open', () => __awaiter(this, void 0, void 0, function* () {\r\n                const routerRtpCapabilities = yield this._protoo.request('getRouterRtpCapabilities', { roomId: _serverInfo.rid });\r\n                yield this._device.load({ routerRtpCapabilities });\r\n                const _req = { request: true, errCode: 200, method: \"responseConnectMedia\", data: { ip: _serverInfo.mediaIp, port: _serverInfo.mediaPort } };\r\n                this.emit('OnManage', _req);\r\n                if (this._device == null) {\r\n                    const _reqJoin = { request: true, errCode: 400, method: \"loadRtpCapabilities\", data: { content: \"Inload server error\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return;\r\n                }\r\n                const localRtpCapabilitie = yield this._device.getNativeRtpCapabilities();\r\n                this.emit('OnManage', { request: true, errCode: 200, method: \"localRtpCapabilitie\", data: localRtpCapabilitie });\r\n                const { rtpCapabilities } = this._device;\r\n                this.emit('OnManage', { request: true, errCode: 200, method: \"rtpCapabilities\", data: rtpCapabilities });\r\n                if (isSubTalk != true) {\r\n                    yield this.createConsumer();\r\n                }\r\n                const joinRoomParam = { displayName: 'browser', device: { flag: this._device._handlerName, name: this._device._handlerName, version: \"78.0.3904.97\" }, rtpCapabilities };\r\n                const joinroomResult = yield this._protoo.request('join', joinRoomParam);\r\n                const _reqJoin = { request: true, errCode: 200, method: \"joinRoom\", data: joinroomResult };\r\n                this.emit('OnManage', _reqJoin);\r\n                if (this._loginInfo.rid != 'mcs8_admin') {\r\n                    let _LocalTransport = yield this.createProduct(_serverInfo.enableTcp);\r\n                    if (_LocalTransport != null) {\r\n                        const productParam = { kind: 'audio', streamType: 0, showObj: this._loginInfo.setting.localAudio };\r\n                        switch (_serverInfo.talkGroupType) {\r\n                            case 3:\r\n                            case 4:\r\n                                {\r\n                                    const result = yield this.sendMedia(productParam);\r\n                                    if (result == 200 && this._audioProduct != null) {\r\n                                        if (this._loginInfo.istalk == true) {\r\n                                            let _roomId = _serverInfo.rid;\r\n                                            let _devId = \"\";\r\n                                            if (_serverInfo.appdata.length > 0) {\r\n                                                _devId = _serverInfo.appdata[0];\r\n                                            }\r\n                                            let _channelId = \"\";\r\n                                            if (_serverInfo.appdata.length > 1) {\r\n                                                _channelId = _serverInfo.appdata[1];\r\n                                            }\r\n                                            const reqParam = { peerId: _devId, devId: _devId, channelId: _channelId, roomId: _roomId };\r\n                                            const { errorCode } = yield this.requestMsg('canSubTalk', reqParam);\r\n                                            if (errorCode == 200) {\r\n                                                this.requestMsg('setSubTalk', reqParam);\r\n                                                yield this._audioProduct.resume();\r\n                                            }\r\n                                            const _startTalk = { request: true, errCode: errorCode, method: \"startTalk\" };\r\n                                            this.emit('OnManage', _startTalk);\r\n                                        }\r\n                                        else {\r\n                                            this._audioProduct.pause();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case 5:\r\n                            case 11:\r\n                                {\r\n                                    let result = yield this.sendMedia(productParam);\r\n                                    if (result == 200 && this._audioProduct != null) {\r\n                                        if (localAudioPause == false) {\r\n                                            this._audioProduct.resume();\r\n                                        }\r\n                                        else {\r\n                                            this._audioProduct.pause();\r\n                                        }\r\n                                    }\r\n                                    productParam.kind = 'video';\r\n                                    productParam.streamType = 2;\r\n                                    productParam.showObj = this._loginInfo.setting.localVideo;\r\n                                    result = yield this.sendMedia(productParam);\r\n                                    if (result == 200 && this._videoProduct != null) {\r\n                                        this._videoProduct.setMaxSpatialLayer(3);\r\n                                        this._videoProduct.resume();\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case 6:\r\n                                {\r\n                                    let result = yield this.sendMedia(productParam);\r\n                                    if (result == 200 && this._audioProduct != null) {\r\n                                        this._audioProduct.resume();\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n                if (this.heartBeat != null) {\r\n                    clearInterval(this.heartBeat);\r\n                    this.heartBeat = null;\r\n                }\r\n                this.heartBeat = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n                    this._protoo.request(\"heartbeat\");\r\n                }), 10000);\r\n            }));\r\n            this._protoo.on('failed', () => __awaiter(this, void 0, void 0, function* () {\r\n                const _req = { request: true, errCode: 502, method: 'responseConnectMedia', data: { ip: _serverInfo.mediaIp, port: _serverInfo.mediaPort } };\r\n                this.emit('OnManage', _req);\r\n                clearInterval(this.heartBeat);\r\n                this.heartBeat = null;\r\n            }));\r\n            this._protoo.on('disconnected', () => __awaiter(this, void 0, void 0, function* () {\r\n                const _req = { request: true, errCode: 401, method: \"responseConnectMedia\", data: { ip: _serverInfo.mediaIp, port: _serverInfo.mediaPort } };\r\n                this.emit('OnManage', _req);\r\n                clearInterval(this.heartBeat);\r\n                this.heartBeat = null;\r\n            }));\r\n            this._protoo.on('close', () => __awaiter(this, void 0, void 0, function* () {\r\n                const _req = { request: true, errCode: 500, method: \"responseConnectMedia\", data: { ip: _serverInfo.mediaIp, port: _serverInfo.mediaPort } };\r\n                this.emit('OnManage', _req);\r\n                clearInterval(this.heartBeat);\r\n                this.heartBeat = null;\r\n            }));\r\n            this._protoo.on('request', (request, accept, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                this.onServerResponse(request, accept, reject);\r\n            }));\r\n            this._protoo.on('notification', (request, accept, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                this.onServerResponse(request, accept, reject);\r\n            }));\r\n        });\r\n    }\r\n    connect({ ip, port, token, ssl, roomId, devId, channelId, localVideo, localAudio, enableTcp = false }, isSubtalk, localAudioPause) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let _roomId = 'mcs8_admin';\r\n            let _userType = 6;\r\n            let _did = 'admin';\r\n            let _talkGroupType = 0;\r\n            if (isSubtalk == true) {\r\n                _userType = 4;\r\n                _roomId = roomId;\r\n                _did = yield this.getGuid();\r\n                _talkGroupType = 3;\r\n            }\r\n            const serverInfo = {\r\n                mediaIp: ip,\r\n                mediaPort: port,\r\n                token,\r\n                ssl,\r\n                rid: _roomId,\r\n                userType: _userType,\r\n                did: _did,\r\n                talkGroupType: _talkGroupType,\r\n                temGroupType: 0,\r\n                isCreator: 0,\r\n                setting: { localVideo: localVideo, localAudio: localAudio },\r\n                appdata: [devId, channelId],\r\n                istalk: isSubtalk == true ? true : false,\r\n                enableTcp\r\n            };\r\n            return this.connectMedia(serverInfo, serverInfo.istalk, localAudioPause);\r\n        });\r\n    }\r\n    getGuid() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let id = \"\";\r\n            for (let i = 0; i < 4; i++) {\r\n                id += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n            }\r\n            return id;\r\n        });\r\n    }\r\n    onServerResponse(request, accept, reject) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            console.log('proto \"request\" event [method:%s, data:%o]', request.method, request.data);\r\n            if (request.request == true) {\r\n                accept();\r\n            }\r\n            switch (request.method) {\r\n                case 'newPeer':\r\n                    {\r\n                    }\r\n                    break;\r\n                case 'newConsumer':\r\n                    {\r\n                        const { peerId, id, kind, producerId, rtpParameters, appData } = request.data;\r\n                        let _log = { request: true, method: \"TrackingLog\", data: request.data };\r\n                        this.emit('OnManage', _log);\r\n                        let channelId = \"-1\";\r\n                        let ShowRemoteObj = null;\r\n                        if (appData != null && appData.sessionId != null && appData.sessionId != \"\") {\r\n                            const playBackModel = this._playBackList.get(appData.sessionId);\r\n                            if (playBackModel != null) {\r\n                                if (kind == \"video\") {\r\n                                    ShowRemoteObj = playBackModel.htmlVideo;\r\n                                }\r\n                                if (kind == \"audio\") {\r\n                                    ShowRemoteObj = playBackModel.htmlAudio;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (appData != null) {\r\n                                if (appData.channelId != null && appData.channelId != \"\") {\r\n                                    channelId = appData.channelId;\r\n                                }\r\n                            }\r\n                            ShowRemoteObj = yield this.getShowObj(kind, peerId, channelId);\r\n                        }\r\n                        if (ShowRemoteObj == null && this._loginInfo.rid == 'mcs8_admin') {\r\n                            return;\r\n                        }\r\n                        const consumer = yield this._consumerTransport.consume({\r\n                            id,\r\n                            producerId,\r\n                            kind,\r\n                            rtpParameters,\r\n                            codecOptions: {},\r\n                            appData: { devId: peerId, channelId }\r\n                        });\r\n                        if (ShowRemoteObj != null) {\r\n                            const stream = new MediaStream();\r\n                            stream.addTrack(consumer.track);\r\n                            ShowRemoteObj.srcObject = stream;\r\n                            _log = { request: true, method: \"TrackingLog\", data: { content: \"add consumer.track to ShowRemoteObj\" } };\r\n                            this.emit('OnManage', _log);\r\n                        }\r\n                        consumer.on('close', () => __awaiter(this, void 0, void 0, function* () {\r\n                            this._consumerList.delete(id);\r\n                        }));\r\n                        this._consumerList.set(id, consumer);\r\n                    }\r\n                    break;\r\n                case 'peerClosed':\r\n                    {\r\n                        const { peerId } = request.data;\r\n                        const _consumerList = Array.from(this._consumerList.values()).filter(m => m.appData != null && m.appData.devId == peerId);\r\n                        if (_consumerList != null && _consumerList.length > 0) {\r\n                            for (const _consumer of _consumerList) {\r\n                                this._consumerList.delete(_consumer.id);\r\n                            }\r\n                        }\r\n                        const _showVideoList = Array.from(this._showVideoList.values()).filter(m => m.devId == peerId);\r\n                        if (_showVideoList != null && _showVideoList.length > 0) {\r\n                            for (const _showVideo of _showVideoList) {\r\n                                const key = yield this.getShowKey(_showVideo.devId, _showVideo.channelId, _showVideo.kind);\r\n                                this._showVideoList.delete(key);\r\n                            }\r\n                        }\r\n                        const _showAudioList = Array.from(this._showAudioList.values()).filter(m => m.devId == peerId);\r\n                        if (_showAudioList != null && _showAudioList.length > 0) {\r\n                            for (const _showAudio of _showAudioList) {\r\n                                const key = yield this.getShowKey(_showAudio.devId, _showAudio.channelId, _showAudio.kind);\r\n                                this._showAudioList.delete(key);\r\n                            }\r\n                        }\r\n                        const _playBackList = Array.from(this._playBackList.values()).filter(m => m.devId == peerId);\r\n                        if (_playBackList != null && _playBackList.length > 0) {\r\n                            for (const _playBack of _playBackList) {\r\n                                this._playBackList.delete(_playBack.sessionId);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'DeviceStatus':\r\n                    {\r\n                    }\r\n                    break;\r\n                case 'consumerAllProduct':\r\n                    {\r\n                        if (this._loginInfo.devMeeting == true) {\r\n                            const { devId, devType } = request.data;\r\n                            if (devType == 1) {\r\n                                yield this.requestMsg('updateDevAllMediaConsumer', { devId, kind: 'audio', isPause: true });\r\n                                yield this.requestMsg('updateDevAllMediaConsumer', { devId, kind: 'video', isPause: true });\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'mediaEnd':\r\n                    {\r\n                        const { sessionId } = request.data;\r\n                        if (sessionId != null) {\r\n                            const playBackModel = this._playBackList.get(sessionId);\r\n                            if (playBackModel != null) {\r\n                                this._playBackList.delete(playBackModel);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            const _req = { request: true, errCode: 200, method: request.method, data: request.data };\r\n            this.emit('OnManage', _req);\r\n        });\r\n    }\r\n    getStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._consumerTransport != null) {\r\n                return this._consumerTransport.getStats();\r\n            }\r\n        });\r\n    }\r\n    getShowObj(kind, peerId, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            var chanId = channelId;\r\n            if (chanId == null) {\r\n                chanId = \"-1\";\r\n            }\r\n            const key = yield this.getShowKey(peerId, channelId, kind);\r\n            let ShowRemoteObj = null;\r\n            if (kind == 'video') {\r\n                let oVideoObj = this._showVideoList.get(key);\r\n                if (oVideoObj != null) {\r\n                    ShowRemoteObj = oVideoObj.showObj;\r\n                }\r\n            }\r\n            if (kind == 'audio') {\r\n                let oAudioObj = this._showAudioList.get(key);\r\n                if (oAudioObj != null) {\r\n                    ShowRemoteObj = oAudioObj.showObj;\r\n                }\r\n                if (oAudioObj == null) {\r\n                    if (this._loginInfo.talkGroupType == 5) {\r\n                        return this.getShowObj('video', peerId, channelId);\r\n                    }\r\n                }\r\n            }\r\n            return ShowRemoteObj;\r\n        });\r\n    }\r\n    createConsumer() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let _forceTcp = false;\r\n            if (this._loginInfo.enableTcp == true) {\r\n                _forceTcp = true;\r\n            }\r\n            const TransportParam = { forceTcp: _forceTcp, producing: false, consuming: true };\r\n            const LocalTransport = yield this.createTransport(TransportParam, false);\r\n            LocalTransport.on('connect', ({ dtlsParameters }, callback, errback) => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    this._protoo.request(\"connectWebRtcTransport\", {\r\n                        transportId: LocalTransport.id,\r\n                        dtlsParameters\r\n                    });\r\n                    callback();\r\n                }\r\n                catch (error) {\r\n                    errback(error);\r\n                }\r\n            }));\r\n            LocalTransport.on('connectionstatechange', (state) => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    switch (state) {\r\n                        case 'connecting':\r\n                            break;\r\n                        case 'connected':\r\n                            {\r\n                                const _req = { request: true, errCode: 200, method: \"createConsumer\" };\r\n                                this.emit('OnManage', _req);\r\n                            }\r\n                            break;\r\n                        case 'failed':\r\n                            {\r\n                                const _req = { request: true, errCode: 500, method: \"createConsumer\" };\r\n                                this.emit('OnManage', _req);\r\n                            }\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n                catch (error) { }\r\n            }));\r\n            LocalTransport.on('getstats', function () {\r\n                console.log('getstats');\r\n            });\r\n            LocalTransport.on('close', function () {\r\n            });\r\n            this._consumerTransport = LocalTransport;\r\n        });\r\n    }\r\n    createProduct(enableTcp) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let _forceTcp = false;\r\n            if (enableTcp == true) {\r\n                _forceTcp = true;\r\n            }\r\n            const TransportParam = { forceTcp: _forceTcp, producing: true, consuming: false };\r\n            const LocalTransport = yield this.createTransport(TransportParam, true);\r\n            LocalTransport.on('connect', ({ dtlsParameters }, callback, errback) => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    yield this._protoo.request(\"connectWebRtcTransport\", {\r\n                        transportId: LocalTransport.id,\r\n                        dtlsParameters\r\n                    });\r\n                    callback();\r\n                    const _req = { request: true, errCode: 200, method: \"connectTransport\" };\r\n                    this.emit('OnManage', _req);\r\n                }\r\n                catch (error) {\r\n                    errback(error);\r\n                }\r\n            }));\r\n            LocalTransport.on('produce', ({ kind, rtpParameters, appData }, callback, errback) => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    const { id } = yield this._protoo.request('produce', {\r\n                        transportId: LocalTransport.id,\r\n                        kind,\r\n                        rtpParameters,\r\n                        appData\r\n                    });\r\n                    callback({ id });\r\n                    const _req = { request: true, errCode: 200, method: \"produce\", data: { productId: id, kind, groupId: this._loginInfo.rid } };\r\n                    this.emit('OnManage', _req);\r\n                }\r\n                catch (error) {\r\n                    errback(error);\r\n                }\r\n            }));\r\n            this._producerTransport = LocalTransport;\r\n            return LocalTransport;\r\n        });\r\n    }\r\n    createTransport(TransportParam, isSend) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const transport = yield this._protoo.request('createWebRtcTransport', TransportParam);\r\n            const { id, iceParameters, iceCandidates, dtlsParameters, sctpParameters } = transport;\r\n            let LocalTransport;\r\n            if (isSend) {\r\n                LocalTransport = yield this._device.createSendTransport({\r\n                    id,\r\n                    iceParameters,\r\n                    iceCandidates,\r\n                    dtlsParameters,\r\n                    sctpParameters\r\n                });\r\n            }\r\n            else {\r\n                LocalTransport = yield this._device.createRecvTransport({\r\n                    id,\r\n                    iceParameters,\r\n                    iceCandidates,\r\n                    dtlsParameters,\r\n                    sctpParameters\r\n                });\r\n            }\r\n            return LocalTransport;\r\n        });\r\n    }\r\n    openVideo({ kind, devId, streamType, showObj, channelId }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            var chanId = channelId;\r\n            if (chanId == null) {\r\n                chanId = \"-1\";\r\n            }\r\n            const key = yield this.getShowKey(devId, chanId, kind);\r\n            if (kind == \"video\") {\r\n                this._showVideoList.set(key, { kind, devId, streamType, showObj, channelId: chanId });\r\n                yield this._protoo.request('mediaMonitor', { kind, devId, streamType, channelId: chanId });\r\n            }\r\n            if (kind == \"audio\") {\r\n                this._showAudioList.set(key, { kind, devId, streamType, showObj, channelId });\r\n                yield this._protoo.request('mediaMonitor', { kind, devId, streamType });\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    stopVideo({ kind, devId, streamType, channelId }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const mediaObj = yield this.getShowObj(kind, devId, channelId);\r\n            let tracks = null;\r\n            var chanId = channelId;\r\n            if (chanId == null) {\r\n                chanId = \"-1\";\r\n            }\r\n            const key = yield this.getShowKey(devId, channelId, kind);\r\n            const result = yield this._protoo.request('closeMediaMonitor', { kind, devId, streamType, channelId: chanId });\r\n            if (kind == \"video\") {\r\n                this._showVideoList.delete(key);\r\n                if (mediaObj != null && mediaObj.srcObject != null) {\r\n                    tracks = mediaObj.srcObject.getVideoTracks();\r\n                }\r\n            }\r\n            if (kind == \"audio\") {\r\n                if (mediaObj != null && mediaObj.srcObject != null) {\r\n                    tracks = mediaObj.srcObject.getAudioTracks();\r\n                }\r\n                this._showAudioList.delete(key);\r\n            }\r\n            if (tracks != null && tracks.length > 0) {\r\n                for (const track of tracks) {\r\n                    mediaObj.srcObject.removeTrack(track);\r\n                    track.stop();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    startPlayBack({ kind, devId, channelId, startTime, endTime, sessionId, fileName, fileId, htmlVideo, htmlAudio }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (sessionId == null || sessionId == \"\") {\r\n                return 412;\r\n            }\r\n            const resultModel = yield this._protoo.request('playBack', { kind: \"video\", devId, channelId, streamType: -1, startTime, endTime, sessionId, fileName, fileId });\r\n            if (resultModel != null && resultModel.status == \"opening\") {\r\n                this._playBackList.set(sessionId, { kind, devId, channelId, startTime, endTime, sessionId, fileName, fileId, htmlVideo, htmlAudio });\r\n                return yield this._protoo.request('playBack', { kind: \"audio\", devId, channelId, streamType: -1, startTime, endTime, sessionId, fileName, fileId });\r\n            }\r\n            return 500;\r\n        });\r\n    }\r\n    playBackCtrl(sessionId, speed) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (sessionId == null || sessionId == \"\") {\r\n                return 412;\r\n            }\r\n            const oPlayBackModel = this._playBackList.get(sessionId);\r\n            if (oPlayBackModel == null) {\r\n                return 404;\r\n            }\r\n            const sendModel = {\r\n                sessionId: oPlayBackModel.sessionId,\r\n                speed,\r\n                kind: 'video',\r\n                devId: oPlayBackModel.devId,\r\n                channelId: oPlayBackModel.channelId,\r\n                streamType: -1\r\n            };\r\n            return yield this._protoo.request('playCtrl', sendModel);\r\n        });\r\n    }\r\n    playBackMove(sessionId, position) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (sessionId == null || sessionId == \"\") {\r\n                return 412;\r\n            }\r\n            const oPlayBackModel = this._playBackList.get(sessionId);\r\n            if (oPlayBackModel == null) {\r\n                return 404;\r\n            }\r\n            const sendModel = {\r\n                sessionId: oPlayBackModel.sessionId,\r\n                position: position.toString(),\r\n                kind: 'video',\r\n                devId: oPlayBackModel.devId,\r\n                channelId: oPlayBackModel.channelId,\r\n                streamType: -1\r\n            };\r\n            return yield this._protoo.request('playMove', sendModel);\r\n        });\r\n    }\r\n    openPlayBackSound(sessionId, isOpen) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (sessionId == null || sessionId == \"\") {\r\n                return 412;\r\n            }\r\n            const oPlayBackModel = this._playBackList.get(sessionId);\r\n            if (oPlayBackModel == null) {\r\n                return 404;\r\n            }\r\n            var method = \"pauseMediaConsumer\";\r\n            if (isOpen == true) {\r\n                method = \"resumeMediaConsumer\";\r\n            }\r\n            const sendModel = {\r\n                sessionId: oPlayBackModel.sessionId,\r\n                kind: 'audio',\r\n                devId: oPlayBackModel.devId,\r\n                channelId: oPlayBackModel.channelId,\r\n                streamType: -1\r\n            };\r\n            return yield this._protoo.request(method, sendModel);\r\n        });\r\n    }\r\n    stopPlayBack(sessionId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (sessionId == null || sessionId == \"\") {\r\n                return 412;\r\n            }\r\n            const oPlayBackModel = this._playBackList.get(sessionId);\r\n            if (oPlayBackModel == null) {\r\n                return 404;\r\n            }\r\n            const sendModel = {\r\n                sessionId: oPlayBackModel.sessionId,\r\n                kind: oPlayBackModel.kind,\r\n                devId: oPlayBackModel.devId,\r\n                channelId: oPlayBackModel.channelId,\r\n                streamType: -1\r\n            };\r\n            this._playBackList.delete(sessionId);\r\n            return yield this._protoo.request('stopPlayback', sendModel);\r\n        });\r\n    }\r\n    getModelByDevId(kind, devId, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const key = yield this.getShowKey(devId, channelId, kind);\r\n            if (kind == 'video') {\r\n                return this._showVideoList.get(key);\r\n            }\r\n            if (kind == 'audio') {\r\n                return this._showAudioList.get(key);\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    sendMedia({ kind, streamType, showObj }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (showObj == null) {\r\n                return 401;\r\n            }\r\n            const sendMedioObj = { kind, streamType, showObj, stream: null };\r\n            const mediaObj = this._sendMediaList.get(kind);\r\n            if (mediaObj != null) {\r\n                this.closeSendMdia(kind);\r\n            }\r\n            if (kind == 'audio') {\r\n                if (!this._device.canProduce('audio')) {\r\n                    return;\r\n                }\r\n                try {\r\n                    const stream = yield this.getMediaStream(kind);\r\n                    if (stream == null) {\r\n                        const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { kind: \"audio\", content: \"Input device not found\" } };\r\n                        this.emit('OnManage', _reqJoin);\r\n                        return 404;\r\n                    }\r\n                    const audioTrack = stream.getAudioTracks()[0];\r\n                    audioTrack.enabled = false;\r\n                    this._audioProduct = yield this._producerTransport.produce({\r\n                        track: audioTrack,\r\n                        codecOptions: {\r\n                            opusStereo: 1,\r\n                            opusDtx: 1\r\n                        }\r\n                    });\r\n                    this._audioProduct.on('transportclose', () => {\r\n                        this._audioProduct = null;\r\n                    });\r\n                    this._audioProduct.on('trackended', () => {\r\n                        this.closeSendMdia('audio');\r\n                    });\r\n                    sendMedioObj.stream = stream;\r\n                    this._sendMediaList.set(kind, sendMedioObj);\r\n                }\r\n                catch (ex) {\r\n                    const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { kind: \"audio\", content: \"Input device not found\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return;\r\n                }\r\n            }\r\n            if (kind == 'video') {\r\n                try {\r\n                    const stream = yield this.getMediaStream(kind);\r\n                    if (stream == null) {\r\n                        const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { kind: \"audio\", content: \"Input device not found\" } };\r\n                        this.emit('OnManage', _reqJoin);\r\n                        return 404;\r\n                    }\r\n                    const videoTrack = stream.getVideoTracks()[0];\r\n                    this._videoProduct = yield this._producerTransport.produce({ track: videoTrack });\r\n                    this._videoProduct.on('transportclose', () => {\r\n                        this._videoProduct = null;\r\n                    });\r\n                    this._videoProduct.on('trackended', () => {\r\n                        this.closeSendMdia('video');\r\n                    });\r\n                    sendMedioObj.stream = stream;\r\n                    this._sendMediaList.set(kind, sendMedioObj);\r\n                    sendMedioObj.showObj.srcObject = stream;\r\n                }\r\n                catch (ex) {\r\n                    const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { kind: \"video\", content: \"Input device not found\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return;\r\n                }\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    getMediaStream(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return new Promise((pResolve, pReject) => __awaiter(this, void 0, void 0, function* () {\r\n                if (kind == 'audio') {\r\n                    if (navigator.mediaDevices != null) {\r\n                        const stream = yield navigator.mediaDevices.getUserMedia({ audio: true });\r\n                        pResolve(stream);\r\n                    }\r\n                    else {\r\n                        navigator.getUserMedia({ audio: true }, function (stream) { pResolve(stream); }, function (err) { pReject(err); });\r\n                    }\r\n                }\r\n                if (kind == 'video') {\r\n                    if (navigator.mediaDevices != null) {\r\n                        const stream = yield navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });\r\n                        pResolve(stream);\r\n                    }\r\n                    else {\r\n                        navigator.getUserMedia({ video: { width: 320, height: 240 } }, function (stream) { pResolve(stream); }, function (err) { pReject(err); });\r\n                    }\r\n                }\r\n            }));\r\n        });\r\n    }\r\n    closeSendMdia(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let productId = null;\r\n            if (kind == 'audio') {\r\n                if (this._audioProduct != null) {\r\n                    productId = this._audioProduct.id;\r\n                    this._audioProduct.close();\r\n                }\r\n                this._audioProduct = null;\r\n            }\r\n            if (kind == 'video') {\r\n                if (this._videoProduct != null) {\r\n                    productId = this._videoProduct.id;\r\n                    this._videoProduct.close();\r\n                }\r\n                this._videoProduct = null;\r\n            }\r\n            if (productId != null) {\r\n                yield this._protoo.request('closeProducer', { producerId: productId });\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    pause(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (kind == 'video') {\r\n                if (this._videoProduct == null) {\r\n                    return 401;\r\n                }\r\n                this._videoProduct.pause();\r\n                return 200;\r\n            }\r\n            if (kind == 'audio') {\r\n                if (this._audioProduct == null) {\r\n                    return 401;\r\n                }\r\n                this._audioProduct.pause();\r\n                return 200;\r\n            }\r\n            return 404;\r\n        });\r\n    }\r\n    resume(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let proId = '';\r\n            if (kind == 'video') {\r\n                if (this._videoProduct == null) {\r\n                    return 401;\r\n                }\r\n                this._videoProduct.resume();\r\n                return 200;\r\n            }\r\n            if (kind == 'audio') {\r\n                if (this._audioProduct == null) {\r\n                    return 401;\r\n                }\r\n                this._audioProduct.resume();\r\n                return 200;\r\n            }\r\n            return 404;\r\n        });\r\n    }\r\n    addShowObject({ kind, devId, showObj, channelId }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (showObj.srcObject == null) {\r\n                showObj.srcObject = new MediaStream();\r\n            }\r\n            let key = devId + \"_-1\";\r\n            if (channelId != null && channelId != \"\") {\r\n                key = devId + \"_\" + channelId;\r\n            }\r\n            if (kind == \"video\") {\r\n                this._showVideoList.set(key, { kind, devId, streamType: 2, showObj });\r\n            }\r\n            if (kind == \"audio\") {\r\n                this._showAudioList.set(key, { kind, devId, streamType: 2, showObj });\r\n            }\r\n            const _consumer = yield this.getConsumer(devId, kind, channelId);\r\n            if (_consumer != null) {\r\n                yield this.removeTrack(showObj, kind);\r\n                showObj.srcObject.addTrack(_consumer.track);\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    getConsumer(devId, kind, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let resultConsumer;\r\n            for (const _consumer of this._consumerList.values()) {\r\n                if (_consumer.appData.devId == devId && _consumer.kind == kind && (_consumer.appData.channelId == null || _consumer.appData.channelId == channelId)) {\r\n                    resultConsumer = _consumer;\r\n                    break;\r\n                }\r\n            }\r\n            return resultConsumer;\r\n        });\r\n    }\r\n    removeTrack(showObj, kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (showObj == null) {\r\n                return 400;\r\n            }\r\n            if (showObj.stream == null) {\r\n                return 400;\r\n            }\r\n            const tracks = showObj.stream.getTracks();\r\n            if (tracks == null) {\r\n                return 400;\r\n            }\r\n            if (tracks.length <= 0) {\r\n                return 400;\r\n            }\r\n            for (const _track of tracks) {\r\n                if (_track.kind == kind) {\r\n                    showObj.stream.removeTrack(_track);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    requestMsg(method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._protoo.request == null) {\r\n                return 500;\r\n            }\r\n            return yield this._protoo.request(method, data);\r\n        });\r\n    }\r\n    notifyMsg(method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._protoo.request == null) {\r\n                return 500;\r\n            }\r\n            this._protoo.notify(method, data);\r\n            return 200;\r\n        });\r\n    }\r\n    close() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._consumerList != null) {\r\n                for (const consumer of this._consumerList.values()) {\r\n                    consumer.close();\r\n                }\r\n            }\r\n            this.closeSendMdia('video');\r\n            this.closeSendMdia('audio');\r\n            if (this._audioProduct != null) {\r\n                this._audioProduct.close();\r\n            }\r\n            if (this._videoProduct != null) {\r\n                this._videoProduct.close();\r\n            }\r\n            if (this._consumerTransport != null) {\r\n                this._consumerTransport.close();\r\n            }\r\n            if (this._producerTransport != null) {\r\n                this._producerTransport.close();\r\n            }\r\n            this._consumerList.clear();\r\n            this._showVideoList.clear();\r\n            this._showAudioList.clear();\r\n            this._sendMediaList.clear();\r\n            if (this._protoo != null) {\r\n                this._protoo.close();\r\n            }\r\n        });\r\n    }\r\n    setLocalVideoOrAudioObject({ localVideo, localAudio }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (localVideo != null) {\r\n                this._loginInfo.setting.localVideo = localVideo;\r\n            }\r\n            if (localAudio != null) {\r\n                this._loginInfo.setting.localAudio = localAudio;\r\n            }\r\n        });\r\n    }\r\n    getShowKey(devId, channelId, kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let key = devId + \"_-1\";\r\n            if (channelId != null && channelId != \"\") {\r\n                key = devId + \"_\" + channelId;\r\n            }\r\n            return key;\r\n        });\r\n    }\r\n}\r\nexports.mcs8MediaClient = mcs8MediaClient;\r\n\n\n//# sourceURL=webpack:///./src/mediaClient.ts?");

/***/ }),

/***/ "./src/ortc.ts":
/*!*********************!*\
  !*** ./src/ortc.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst h264 = __importStar(__webpack_require__(/*! h264-profile-level-id */ \"./node_modules/h264-profile-level-id/index.js\"));\r\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\r\nconst RTP_PROBATOR_MID = 'probator';\r\nconst RTP_PROBATOR_SSRC = 1234;\r\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\r\nfunction validateRtpCapabilities(caps) {\r\n    if (typeof caps !== 'object')\r\n        throw new TypeError('caps is not an object');\r\n    if (caps.codecs && !Array.isArray(caps.codecs))\r\n        throw new TypeError('caps.codecs is not an array');\r\n    else if (!caps.codecs)\r\n        caps.codecs = [];\r\n    for (const codec of caps.codecs) {\r\n        validateRtpCodecCapability(codec);\r\n    }\r\n    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions))\r\n        throw new TypeError('caps.headerExtensions is not an array');\r\n    else if (!caps.headerExtensions)\r\n        caps.headerExtensions = [];\r\n    for (const ext of caps.headerExtensions) {\r\n        validateRtpHeaderExtension(ext);\r\n    }\r\n}\r\nexports.validateRtpCapabilities = validateRtpCapabilities;\r\nfunction validateRtpCodecCapability(codec) {\r\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\r\n    if (typeof codec !== 'object')\r\n        throw new TypeError('codec is not an object');\r\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\r\n        throw new TypeError('missing codec.mimeType');\r\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\r\n    if (!mimeTypeMatch)\r\n        throw new TypeError('invalid codec.mimeType');\r\n    codec.kind = mimeTypeMatch[1].toLowerCase();\r\n    if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number')\r\n        throw new TypeError('invalid codec.preferredPayloadType');\r\n    if (typeof codec.clockRate !== 'number')\r\n        throw new TypeError('missing codec.clockRate');\r\n    if (codec.kind === 'audio') {\r\n        if (typeof codec.channels !== 'number')\r\n            codec.channels = 1;\r\n    }\r\n    else {\r\n        delete codec.channels;\r\n    }\r\n    if (!codec.parameters || typeof codec.parameters !== 'object')\r\n        codec.parameters = {};\r\n    for (const key of Object.keys(codec.parameters)) {\r\n        let value = codec.parameters[key];\r\n        if (value === undefined) {\r\n            codec.parameters[key] = '';\r\n            value = '';\r\n        }\r\n        if (typeof value !== 'string' && typeof value !== 'number') {\r\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\r\n        }\r\n        if (key === 'apt') {\r\n            if (typeof value !== 'number')\r\n                throw new TypeError('invalid codec apt parameter');\r\n        }\r\n    }\r\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\r\n        codec.rtcpFeedback = [];\r\n    for (const fb of codec.rtcpFeedback) {\r\n        validateRtcpFeedback(fb);\r\n    }\r\n}\r\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\r\nfunction validateRtcpFeedback(fb) {\r\n    if (typeof fb !== 'object')\r\n        throw new TypeError('fb is not an object');\r\n    if (!fb.type || typeof fb.type !== 'string')\r\n        throw new TypeError('missing fb.type');\r\n    if (!fb.parameter || typeof fb.parameter !== 'string')\r\n        fb.parameter = '';\r\n}\r\nexports.validateRtcpFeedback = validateRtcpFeedback;\r\nfunction validateRtpHeaderExtension(ext) {\r\n    if (typeof ext !== 'object')\r\n        throw new TypeError('ext is not an object');\r\n    if (!ext.kind || typeof ext.kind !== 'string')\r\n        ext.kind = '';\r\n    if (ext.kind !== '' && ext.kind !== 'audio' && ext.kind !== 'video')\r\n        throw new TypeError('invalid ext.kind');\r\n    if (!ext.uri || typeof ext.uri !== 'string')\r\n        throw new TypeError('missing ext.uri');\r\n    if (typeof ext.preferredId !== 'number')\r\n        throw new TypeError('missing ext.preferredId');\r\n    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean')\r\n        throw new TypeError('invalid ext.preferredEncrypt');\r\n    else if (!ext.preferredEncrypt)\r\n        ext.preferredEncrypt = false;\r\n    if (ext.direction && typeof ext.direction !== 'string')\r\n        throw new TypeError('invalid ext.direction');\r\n    else if (!ext.direction)\r\n        ext.direction = 'sendrecv';\r\n}\r\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\r\nfunction validateRtpParameters(params) {\r\n    if (typeof params !== 'object')\r\n        throw new TypeError('params is not an object');\r\n    if (params.mid && typeof params.mid !== 'string')\r\n        throw new TypeError('params.mid is not a string');\r\n    if (!Array.isArray(params.codecs))\r\n        throw new TypeError('missing params.codecs');\r\n    for (const codec of params.codecs) {\r\n        validateRtpCodecParameters(codec);\r\n    }\r\n    if (params.headerExtensions && !Array.isArray(params.headerExtensions))\r\n        throw new TypeError('params.headerExtensions is not an array');\r\n    else if (!params.headerExtensions)\r\n        params.headerExtensions = [];\r\n    for (const ext of params.headerExtensions) {\r\n        validateRtpHeaderExtensionParameters(ext);\r\n    }\r\n    if (params.encodings && !Array.isArray(params.encodings))\r\n        throw new TypeError('params.encodings is not an array');\r\n    else if (!params.encodings)\r\n        params.encodings = [];\r\n    for (const encoding of params.encodings) {\r\n        validateRtpEncodingParameters(encoding);\r\n    }\r\n    if (params.rtcp && typeof params.rtcp !== 'object')\r\n        throw new TypeError('params.rtcp is not an object');\r\n    else if (!params.rtcp)\r\n        params.rtcp = {};\r\n    validateRtcpParameters(params.rtcp);\r\n}\r\nexports.validateRtpParameters = validateRtpParameters;\r\nfunction validateRtpCodecParameters(codec) {\r\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\r\n    if (typeof codec !== 'object')\r\n        throw new TypeError('codec is not an object');\r\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\r\n        throw new TypeError('missing codec.mimeType');\r\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\r\n    if (!mimeTypeMatch)\r\n        throw new TypeError('invalid codec.mimeType');\r\n    if (typeof codec.payloadType !== 'number')\r\n        throw new TypeError('missing codec.payloadType');\r\n    if (typeof codec.clockRate !== 'number')\r\n        throw new TypeError('missing codec.clockRate');\r\n    const kind = mimeTypeMatch[1].toLowerCase();\r\n    if (kind === 'audio') {\r\n        if (typeof codec.channels !== 'number')\r\n            codec.channels = 1;\r\n    }\r\n    else {\r\n        delete codec.channels;\r\n    }\r\n    if (!codec.parameters || typeof codec.parameters !== 'object')\r\n        codec.parameters = {};\r\n    for (const key of Object.keys(codec.parameters)) {\r\n        let value = codec.parameters[key];\r\n        if (value === undefined) {\r\n            codec.parameters[key] = '';\r\n            value = '';\r\n        }\r\n        if (typeof value !== 'string' && typeof value !== 'number') {\r\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\r\n        }\r\n        if (key === 'apt') {\r\n            if (typeof value !== 'number')\r\n                throw new TypeError('invalid codec apt parameter');\r\n        }\r\n    }\r\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\r\n        codec.rtcpFeedback = [];\r\n    for (const fb of codec.rtcpFeedback) {\r\n        validateRtcpFeedback(fb);\r\n    }\r\n}\r\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\r\nfunction validateRtpHeaderExtensionParameters(ext) {\r\n    if (typeof ext !== 'object')\r\n        throw new TypeError('ext is not an object');\r\n    if (!ext.uri || typeof ext.uri !== 'string')\r\n        throw new TypeError('missing ext.uri');\r\n    if (typeof ext.id !== 'number')\r\n        throw new TypeError('missing ext.id');\r\n    if (ext.encrypt && typeof ext.encrypt !== 'boolean')\r\n        throw new TypeError('invalid ext.encrypt');\r\n    else if (!ext.encrypt)\r\n        ext.encrypt = false;\r\n    if (!ext.parameters || typeof ext.parameters !== 'object')\r\n        ext.parameters = {};\r\n    for (const key of Object.keys(ext.parameters)) {\r\n        let value = ext.parameters[key];\r\n        if (value === undefined) {\r\n            ext.parameters[key] = '';\r\n            value = '';\r\n        }\r\n        if (typeof value !== 'string' && typeof value !== 'number')\r\n            throw new TypeError('invalid header extension parameter');\r\n    }\r\n}\r\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\r\nfunction validateRtpEncodingParameters(encoding) {\r\n    if (typeof encoding !== 'object')\r\n        throw new TypeError('encoding is not an object');\r\n    if (encoding.ssrc && typeof encoding.ssrc !== 'number')\r\n        throw new TypeError('invalid encoding.ssrc');\r\n    if (encoding.rid && typeof encoding.rid !== 'string')\r\n        throw new TypeError('invalid encoding.rid');\r\n    if (encoding.rtx && typeof encoding.rtx !== 'object') {\r\n        throw new TypeError('invalid encoding.rtx');\r\n    }\r\n    else if (encoding.rtx) {\r\n        if (typeof encoding.rtx.ssrc !== 'number')\r\n            throw new TypeError('missing encoding.rtx.ssrc');\r\n    }\r\n    if (!encoding.dtx || typeof encoding.dtx !== 'boolean')\r\n        encoding.dtx = false;\r\n    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string')\r\n        throw new TypeError('invalid encoding.scalabilityMode');\r\n}\r\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\r\nfunction validateRtcpParameters(rtcp) {\r\n    if (typeof rtcp !== 'object')\r\n        throw new TypeError('rtcp is not an object');\r\n    if (rtcp.cname && typeof rtcp.cname !== 'string')\r\n        throw new TypeError('invalid rtcp.cname');\r\n    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean')\r\n        rtcp.reducedSize = true;\r\n}\r\nexports.validateRtcpParameters = validateRtcpParameters;\r\nfunction validateSctpCapabilities(caps) {\r\n    if (typeof caps !== 'object')\r\n        throw new TypeError('caps is not an object');\r\n    if (!caps.numStreams || typeof caps.numStreams !== 'object')\r\n        throw new TypeError('missing caps.numStreams');\r\n    validateNumSctpStreams(caps.numStreams);\r\n}\r\nexports.validateSctpCapabilities = validateSctpCapabilities;\r\nfunction validateNumSctpStreams(numStreams) {\r\n    if (typeof numStreams !== 'object')\r\n        throw new TypeError('numStreams is not an object');\r\n    if (typeof numStreams.OS !== 'number')\r\n        throw new TypeError('missing numStreams.OS');\r\n    if (typeof numStreams.MIS !== 'number')\r\n        throw new TypeError('missing numStreams.MIS');\r\n}\r\nexports.validateNumSctpStreams = validateNumSctpStreams;\r\nfunction validateSctpParameters(params) {\r\n    if (typeof params !== 'object')\r\n        throw new TypeError('params is not an object');\r\n    if (typeof params.port !== 'number')\r\n        throw new TypeError('missing params.port');\r\n    if (typeof params.OS !== 'number')\r\n        throw new TypeError('missing params.OS');\r\n    if (typeof params.MIS !== 'number')\r\n        throw new TypeError('missing params.MIS');\r\n    if (typeof params.maxMessageSize !== 'number')\r\n        throw new TypeError('missing params.maxMessageSize');\r\n}\r\nexports.validateSctpParameters = validateSctpParameters;\r\nfunction validateSctpStreamParameters(params) {\r\n    if (typeof params !== 'object')\r\n        throw new TypeError('params is not an object');\r\n    if (typeof params.streamId !== 'number')\r\n        throw new TypeError('missing params.streamId');\r\n    let orderedGiven = false;\r\n    if (typeof params.ordered === 'boolean')\r\n        orderedGiven = true;\r\n    else\r\n        params.ordered = true;\r\n    if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number')\r\n        throw new TypeError('invalid params.maxPacketLifeTime');\r\n    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number')\r\n        throw new TypeError('invalid params.maxRetransmits');\r\n    if (params.maxPacketLifeTime && params.maxRetransmits)\r\n        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\r\n    if (orderedGiven &&\r\n        params.ordered &&\r\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\r\n        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\r\n    }\r\n    else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\r\n        params.ordered = false;\r\n    }\r\n    if (params.priority && typeof params.priority !== 'string')\r\n        throw new TypeError('invalid params.priority');\r\n    if (params.label && typeof params.label !== 'string')\r\n        throw new TypeError('invalid params.label');\r\n    if (params.protocol && typeof params.protocol !== 'string')\r\n        throw new TypeError('invalid params.protocol');\r\n}\r\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\r\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\r\n    const extendedRtpCapabilities = {\r\n        codecs: [],\r\n        headerExtensions: []\r\n    };\r\n    for (const remoteCodec of remoteCaps.codecs || []) {\r\n        if (isRtxCodec(remoteCodec))\r\n            continue;\r\n        const matchingLocalCodec = (localCaps.codecs || [])\r\n            .find((localCodec) => (matchCodecs(localCodec, remoteCodec, { strict: true, modify: true })));\r\n        if (!matchingLocalCodec)\r\n            continue;\r\n        const extendedCodec = {\r\n            mimeType: matchingLocalCodec.mimeType,\r\n            kind: matchingLocalCodec.kind,\r\n            clockRate: matchingLocalCodec.clockRate,\r\n            channels: matchingLocalCodec.channels,\r\n            localPayloadType: matchingLocalCodec.preferredPayloadType,\r\n            localRtxPayloadType: undefined,\r\n            remotePayloadType: remoteCodec.preferredPayloadType,\r\n            remoteRtxPayloadType: undefined,\r\n            localParameters: matchingLocalCodec.parameters,\r\n            remoteParameters: remoteCodec.parameters,\r\n            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\r\n        };\r\n        extendedRtpCapabilities.codecs.push(extendedCodec);\r\n    }\r\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\r\n        const matchingLocalRtxCodec = localCaps.codecs\r\n            .find((localCodec) => (isRtxCodec(localCodec) &&\r\n            localCodec.parameters.apt === extendedCodec.localPayloadType));\r\n        const matchingRemoteRtxCodec = remoteCaps.codecs\r\n            .find((remoteCodec) => (isRtxCodec(remoteCodec) &&\r\n            remoteCodec.parameters.apt === extendedCodec.remotePayloadType));\r\n        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\r\n            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\r\n            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\r\n        }\r\n    }\r\n    for (const remoteExt of remoteCaps.headerExtensions) {\r\n        const matchingLocalExt = localCaps.headerExtensions\r\n            .find((localExt) => (matchHeaderExtensions(localExt, remoteExt)));\r\n        if (!matchingLocalExt)\r\n            continue;\r\n        const extendedExt = {\r\n            kind: remoteExt.kind,\r\n            uri: remoteExt.uri,\r\n            sendId: matchingLocalExt.preferredId,\r\n            recvId: remoteExt.preferredId,\r\n            encrypt: matchingLocalExt.preferredEncrypt,\r\n            direction: 'sendrecv'\r\n        };\r\n        switch (remoteExt.direction) {\r\n            case 'sendrecv':\r\n                extendedExt.direction = 'sendrecv';\r\n                break;\r\n            case 'recvonly':\r\n                extendedExt.direction = 'sendonly';\r\n                break;\r\n            case 'sendonly':\r\n                extendedExt.direction = 'recvonly';\r\n                break;\r\n            case 'inactive':\r\n                extendedExt.direction = 'inactive';\r\n                break;\r\n        }\r\n        extendedRtpCapabilities.headerExtensions.push(extendedExt);\r\n    }\r\n    return extendedRtpCapabilities;\r\n}\r\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\r\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\r\n    const rtpCapabilities = {\r\n        codecs: [],\r\n        headerExtensions: []\r\n    };\r\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\r\n        const codec = {\r\n            mimeType: extendedCodec.mimeType,\r\n            kind: extendedCodec.kind,\r\n            preferredPayloadType: extendedCodec.remotePayloadType,\r\n            clockRate: extendedCodec.clockRate,\r\n            channels: extendedCodec.channels,\r\n            parameters: extendedCodec.localParameters,\r\n            rtcpFeedback: extendedCodec.rtcpFeedback\r\n        };\r\n        rtpCapabilities.codecs.push(codec);\r\n        if (!extendedCodec.remoteRtxPayloadType)\r\n            continue;\r\n        const rtxCodec = {\r\n            mimeType: `${extendedCodec.kind}/rtx`,\r\n            kind: extendedCodec.kind,\r\n            preferredPayloadType: extendedCodec.remoteRtxPayloadType,\r\n            clockRate: extendedCodec.clockRate,\r\n            parameters: {\r\n                apt: extendedCodec.remotePayloadType\r\n            },\r\n            rtcpFeedback: []\r\n        };\r\n        rtpCapabilities.codecs.push(rtxCodec);\r\n    }\r\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\r\n        if (extendedExtension.direction !== 'sendrecv' &&\r\n            extendedExtension.direction !== 'recvonly') {\r\n            continue;\r\n        }\r\n        const ext = {\r\n            kind: extendedExtension.kind,\r\n            uri: extendedExtension.uri,\r\n            preferredId: extendedExtension.recvId,\r\n            preferredEncrypt: extendedExtension.encrypt,\r\n            direction: extendedExtension.direction\r\n        };\r\n        rtpCapabilities.headerExtensions.push(ext);\r\n    }\r\n    return rtpCapabilities;\r\n}\r\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\r\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\r\n    const rtpParameters = {\r\n        mid: undefined,\r\n        codecs: [],\r\n        headerExtensions: [],\r\n        encodings: [],\r\n        rtcp: {}\r\n    };\r\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\r\n        if (extendedCodec.kind !== kind)\r\n            continue;\r\n        const codec = {\r\n            mimeType: extendedCodec.mimeType,\r\n            payloadType: extendedCodec.localPayloadType,\r\n            clockRate: extendedCodec.clockRate,\r\n            channels: extendedCodec.channels,\r\n            parameters: extendedCodec.localParameters,\r\n            rtcpFeedback: extendedCodec.rtcpFeedback\r\n        };\r\n        rtpParameters.codecs.push(codec);\r\n        if (extendedCodec.localRtxPayloadType) {\r\n            const rtxCodec = {\r\n                mimeType: `${extendedCodec.kind}/rtx`,\r\n                payloadType: extendedCodec.localRtxPayloadType,\r\n                clockRate: extendedCodec.clockRate,\r\n                parameters: {\r\n                    apt: extendedCodec.localPayloadType\r\n                },\r\n                rtcpFeedback: []\r\n            };\r\n            rtpParameters.codecs.push(rtxCodec);\r\n        }\r\n    }\r\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\r\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\r\n            (extendedExtension.direction !== 'sendrecv' &&\r\n                extendedExtension.direction !== 'sendonly')) {\r\n            continue;\r\n        }\r\n        const ext = {\r\n            uri: extendedExtension.uri,\r\n            id: extendedExtension.sendId,\r\n            encrypt: extendedExtension.encrypt,\r\n            parameters: {}\r\n        };\r\n        rtpParameters.headerExtensions.push(ext);\r\n    }\r\n    return rtpParameters;\r\n}\r\nexports.getSendingRtpParameters = getSendingRtpParameters;\r\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\r\n    const rtpParameters = {\r\n        mid: undefined,\r\n        codecs: [],\r\n        headerExtensions: [],\r\n        encodings: [],\r\n        rtcp: {}\r\n    };\r\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\r\n        if (extendedCodec.kind !== kind)\r\n            continue;\r\n        const codec = {\r\n            mimeType: extendedCodec.mimeType,\r\n            payloadType: extendedCodec.localPayloadType,\r\n            clockRate: extendedCodec.clockRate,\r\n            channels: extendedCodec.channels,\r\n            parameters: extendedCodec.remoteParameters,\r\n            rtcpFeedback: extendedCodec.rtcpFeedback\r\n        };\r\n        rtpParameters.codecs.push(codec);\r\n        if (extendedCodec.localRtxPayloadType) {\r\n            const rtxCodec = {\r\n                mimeType: `${extendedCodec.kind}/rtx`,\r\n                payloadType: extendedCodec.localRtxPayloadType,\r\n                clockRate: extendedCodec.clockRate,\r\n                parameters: {\r\n                    apt: extendedCodec.localPayloadType\r\n                },\r\n                rtcpFeedback: []\r\n            };\r\n            rtpParameters.codecs.push(rtxCodec);\r\n        }\r\n    }\r\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\r\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\r\n            (extendedExtension.direction !== 'sendrecv' &&\r\n                extendedExtension.direction !== 'sendonly')) {\r\n            continue;\r\n        }\r\n        const ext = {\r\n            uri: extendedExtension.uri,\r\n            id: extendedExtension.sendId,\r\n            encrypt: extendedExtension.encrypt,\r\n            parameters: {}\r\n        };\r\n        rtpParameters.headerExtensions.push(ext);\r\n    }\r\n    if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01'))) {\r\n        for (const codec of rtpParameters.codecs) {\r\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\r\n                .filter((fb) => fb.type !== 'goog-remb');\r\n        }\r\n    }\r\n    else if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time'))) {\r\n        for (const codec of rtpParameters.codecs) {\r\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\r\n                .filter((fb) => fb.type !== 'transport-cc');\r\n        }\r\n    }\r\n    else {\r\n        for (const codec of rtpParameters.codecs) {\r\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\r\n                .filter((fb) => (fb.type !== 'transport-cc' &&\r\n                fb.type !== 'goog-remb'));\r\n        }\r\n    }\r\n    return rtpParameters;\r\n}\r\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\r\nfunction reduceCodecs(codecs, capCodec) {\r\n    const filteredCodecs = [];\r\n    if (!capCodec) {\r\n        filteredCodecs.push(codecs[0]);\r\n        if (isRtxCodec(codecs[1]))\r\n            filteredCodecs.push(codecs[1]);\r\n    }\r\n    else {\r\n        for (let idx = 0; idx < codecs.length; ++idx) {\r\n            if (matchCodecs(codecs[idx], capCodec)) {\r\n                filteredCodecs.push(codecs[idx]);\r\n                if (isRtxCodec(codecs[idx + 1]))\r\n                    filteredCodecs.push(codecs[idx + 1]);\r\n                break;\r\n            }\r\n        }\r\n        if (filteredCodecs.length === 0)\r\n            throw new TypeError('no matching codec found');\r\n    }\r\n    return filteredCodecs;\r\n}\r\nexports.reduceCodecs = reduceCodecs;\r\nfunction generateProbatorRtpParameters(videoRtpParameters) {\r\n    videoRtpParameters = utils_1.clone(videoRtpParameters);\r\n    validateRtpParameters(videoRtpParameters);\r\n    const rtpParameters = {\r\n        mid: RTP_PROBATOR_MID,\r\n        codecs: [],\r\n        headerExtensions: [],\r\n        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],\r\n        rtcp: { cname: 'probator' }\r\n    };\r\n    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\r\n    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\r\n    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\r\n    return rtpParameters;\r\n}\r\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\r\nfunction canSend(kind, extendedRtpCapabilities) {\r\n    return extendedRtpCapabilities.codecs.\r\n        some((codec) => codec.kind === kind);\r\n}\r\nexports.canSend = canSend;\r\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\r\n    validateRtpParameters(rtpParameters);\r\n    if (rtpParameters.codecs.length === 0)\r\n        return false;\r\n    const firstMediaCodec = rtpParameters.codecs[0];\r\n    return extendedRtpCapabilities.codecs\r\n        .some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);\r\n}\r\nexports.canReceive = canReceive;\r\nfunction isRtxCodec(codec) {\r\n    if (!codec)\r\n        return false;\r\n    return /.+\\/rtx$/i.test(codec.mimeType);\r\n}\r\nfunction matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {\r\n    const aMimeType = aCodec.mimeType.toLowerCase();\r\n    const bMimeType = bCodec.mimeType.toLowerCase();\r\n    if (aMimeType !== bMimeType)\r\n        return false;\r\n    if (aCodec.clockRate !== bCodec.clockRate)\r\n        return false;\r\n    if (aCodec.channels !== bCodec.channels)\r\n        return false;\r\n    switch (aMimeType) {\r\n        case 'video/h264':\r\n            {\r\n                const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\r\n                const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\r\n                if (aPacketizationMode !== bPacketizationMode)\r\n                    return false;\r\n                if (strict) {\r\n                    if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters))\r\n                        return false;\r\n                    let selectedProfileLevelId;\r\n                    try {\r\n                        selectedProfileLevelId =\r\n                            h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\r\n                    }\r\n                    catch (error) {\r\n                        return false;\r\n                    }\r\n                    if (modify) {\r\n                        if (selectedProfileLevelId)\r\n                            aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\r\n                        else\r\n                            delete aCodec.parameters['profile-level-id'];\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        case 'video/vp9':\r\n            {\r\n                if (strict) {\r\n                    const aProfileId = aCodec.parameters['profile-id'] || 0;\r\n                    const bProfileId = bCodec.parameters['profile-id'] || 0;\r\n                    if (aProfileId !== bProfileId)\r\n                        return false;\r\n                }\r\n                break;\r\n            }\r\n    }\r\n    return true;\r\n}\r\nfunction matchHeaderExtensions(aExt, bExt) {\r\n    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind)\r\n        return false;\r\n    if (aExt.uri !== bExt.uri)\r\n        return false;\r\n    return true;\r\n}\r\nfunction reduceRtcpFeedback(codecA, codecB) {\r\n    const reducedRtcpFeedback = [];\r\n    for (const aFb of codecA.rtcpFeedback || []) {\r\n        const matchingBFb = (codecB.rtcpFeedback || [])\r\n            .find((bFb) => (bFb.type === aFb.type &&\r\n            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter))));\r\n        if (matchingBFb)\r\n            reducedRtcpFeedback.push(matchingBFb);\r\n    }\r\n    return reducedRtcpFeedback;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/ortc.ts?");

/***/ }),

/***/ "./src/scalabilityModes.ts":
/*!*********************************!*\
  !*** ./src/scalabilityModes.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\\\d{0,1})T([1-9]\\\\d{0,1})');\r\nfunction parse(scalabilityMode) {\r\n    const match = ScalabilityModeRegex.exec(scalabilityMode || '');\r\n    if (match) {\r\n        return {\r\n            spatialLayers: Number(match[1]),\r\n            temporalLayers: Number(match[2])\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            spatialLayers: 1,\r\n            temporalLayers: 1\r\n        };\r\n    }\r\n}\r\nexports.parse = parse;\r\n\n\n//# sourceURL=webpack:///./src/scalabilityModes.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction clone(data) {\r\n    if (typeof data !== 'object')\r\n        return {};\r\n    return JSON.parse(JSON.stringify(data));\r\n}\r\nexports.clone = clone;\r\nfunction generateRandomNumber() {\r\n    return Math.round(Math.random() * 10000000);\r\n}\r\nexports.generateRandomNumber = generateRandomNumber;\r\n\n\n//# sourceURL=webpack:///./src/utils.ts?");

/***/ }),

/***/ "./src/websocketClient/EnhancedEventEmitter.js":
/*!*****************************************************!*\
  !*** ./src/websocketClient/EnhancedEventEmitter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EventEmitter } = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst Logger = __webpack_require__(/*! ./Logger */ \"./src/websocketClient/Logger.js\");\n\nclass EnhancedEventEmitter extends EventEmitter\n{\n\tconstructor(logger)\n\t{\n\t\tsuper();\n\t\tthis.setMaxListeners(Infinity);\n\n\t\tthis._logger = logger || new Logger('EnhancedEventEmitter');\n\t}\n\n\tsafeEmit(event, ...args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.emit(event, ...args);\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tthis._logger.error(\n\t\t\t\t'safeEmit() | event listener threw an error [event:%s]:%o',\n\t\t\t\tevent, error);\n\t\t}\n\t}\n\n\tasync safeEmitAsPromise(event, ...args)\n\t{\n\t\treturn new Promise((resolve, reject) =>\n\t\t{\n\t\t\tthis.safeEmit(event, ...args, resolve, reject);\n\t\t});\n\t}\n}\n\nmodule.exports = EnhancedEventEmitter;\n\n\n//# sourceURL=webpack:///./src/websocketClient/EnhancedEventEmitter.js?");

/***/ }),

/***/ "./src/websocketClient/Logger.js":
/*!***************************************!*\
  !*** ./src/websocketClient/Logger.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n\nconst APP_NAME = 'protoo-client';\n\nclass Logger\n{\n\tconstructor(prefix)\n\t{\n\t\tif (prefix)\n\t\t{\n\t\t\tthis._debug = debug(`${APP_NAME}:${prefix}`);\n\t\t\tthis._warn = debug(`${APP_NAME}:WARN:${prefix}`);\n\t\t\tthis._error = debug(`${APP_NAME}:ERROR:${prefix}`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._debug = debug(APP_NAME);\n\t\t\tthis._warn = debug(`${APP_NAME}:WARN`);\n\t\t\tthis._error = debug(`${APP_NAME}:ERROR`);\n\t\t}\n\n\t\t/* eslint-disable no-console */\n\t\tthis._debug.log = console.info.bind(console);\n\t\tthis._warn.log = console.warn.bind(console);\n\t\tthis._error.log = console.error.bind(console);\n\t\t/* eslint-enable no-console */\n\t}\n\n\tget debug()\n\t{\n\t\treturn this._debug;\n\t}\n\n\tget warn()\n\t{\n\t\treturn this._warn;\n\t}\n\n\tget error()\n\t{\n\t\treturn this._error;\n\t}\n}\n\nmodule.exports = Logger;\n\n\n//# sourceURL=webpack:///./src/websocketClient/Logger.js?");

/***/ }),

/***/ "./src/websocketClient/Message.js":
/*!****************************************!*\
  !*** ./src/websocketClient/Message.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Logger = __webpack_require__(/*! ./Logger */ \"./src/websocketClient/Logger.js\");\nconst { generateRandomNumber } = __webpack_require__(/*! ./utils */ \"./src/websocketClient/utils.js\");\n\nconst logger = new Logger('Message');\n\nclass Message\n{\n\tstatic parse(raw)\n\t{\n\t\tlet object;\n\t\tconst message = {};\n\n\t\ttry\n\t\t{\n\t\t\tobject = JSON.parse(raw);\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.error('parse() | invalid JSON: %s', error);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof object !== 'object' || Array.isArray(object))\n\t\t{\n\t\t\tlogger.error('parse() | not an object');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Request.\n\t\tif (object.request)\n\t\t{\n\t\t\tmessage.request = true;\n\n\t\t\tif (typeof object.method !== 'string')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid method field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof object.id !== 'number')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid id field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.id = object.id;\n\t\t\tmessage.method = object.method;\n\t\t\tmessage.data = object.data || {};\n\t\t}\n\t\t// Response.\n\t\telse if (object.response)\n\t\t{\n\t\t\tmessage.response = true;\n\n\t\t\tif (typeof object.id !== 'number')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid id field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.id = object.id;\n\n\t\t\t// Success.\n\t\t\tif (object.ok)\n\t\t\t{\n\t\t\t\tmessage.ok = true;\n\t\t\t\tmessage.data = object.data || {};\n\t\t\t}\n\t\t\t// Error.\n\t\t\telse\n\t\t\t{\n\t\t\t\tmessage.ok = false;\n\t\t\t\tmessage.errorCode = object.errorCode;\n\t\t\t\tmessage.errorReason = object.errorReason;\n\t\t\t}\n\t\t}\n\t\t// Notification.\n\t\telse if (object.notification)\n\t\t{\n\t\t\tmessage.notification = true;\n\n\t\t\tif (typeof object.method !== 'string')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid method field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.method = object.method;\n\t\t\tmessage.data = object.data || {};\n\t\t}\n\t\t// Invalid.\n\t\telse\n\t\t{\n\t\t\tlogger.error('parse() | missing request/response field');\n\n\t\t\treturn;\n\t\t}\n\n\t\treturn message;\n\t}\n\n\tstatic createRequest(method, data)\n\t{\n\t\tconst request =\n\t\t{\n\t\t\trequest : true,\n\t\t\tid      : generateRandomNumber(),\n\t\t\tmethod  : method,\n\t\t\tdata    : data || {}\n\t\t};\n\n\t\treturn request;\n\t}\n\n\tstatic createSuccessResponse(request, data)\n\t{\n\t\tconst response =\n\t\t{\n\t\t\tresponse : true,\n\t\t\tid       : request.id,\n\t\t\tok       : true,\n\t\t\tdata     : data || {}\n\t\t};\n\n\t\treturn response;\n\t}\n\n\tstatic createErrorResponse(request, errorCode, errorReason)\n\t{\n\t\tconst response =\n\t\t{\n\t\t\tresponse    : true,\n\t\t\tid          : request.id,\n\t\t\tok          : false,\n\t\t\terrorCode   : errorCode,\n\t\t\terrorReason : errorReason\n\t\t};\n\n\t\treturn response;\n\t}\n\n\tstatic createNotification(method, data)\n\t{\n\t\tconst notification =\n\t\t{\n\t\t\tnotification : true,\n\t\t\tmethod       : method,\n\t\t\tdata         : data || {}\n\t\t};\n\n\t\treturn notification;\n\t}\n}\n\nmodule.exports = Message;\n\n\n//# sourceURL=webpack:///./src/websocketClient/Message.js?");

/***/ }),

/***/ "./src/websocketClient/Peer.js":
/*!*************************************!*\
  !*** ./src/websocketClient/Peer.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Logger = __webpack_require__(/*! ./Logger */ \"./src/websocketClient/Logger.js\");\nconst EnhancedEventEmitter = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/websocketClient/EnhancedEventEmitter.js\");\nconst Message = __webpack_require__(/*! ./Message */ \"./src/websocketClient/Message.js\");\n\nconst logger = new Logger('Peer');\n\nclass Peer extends EnhancedEventEmitter\n{\n\t/**\n\t * @param {protoo.Transport} transport\n\t *\n\t * @emits open\n\t * @emits {currentAttempt: Number} failed\n\t * @emits disconnected\n\t * @emits close\n\t * @emits {request: protoo.Request, accept: Function, reject: Function} request\n\t * @emits {notification: protoo.Notification} notification\n\t */\n\tconstructor(transport)\n\t{\n\t\tsuper(logger);\n\n\t\tlogger.debug('constructor()');\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// Transport.\n\t\t// @type {protoo.Transport}\n\t\tthis._transport = transport;\n\n\t\t// Connected flag.\n\t\t// @type {Boolean}\n\t\tthis._connected = false;\n\n\t\t// Custom data object.\n\t\t// @type {Object}\n\t\tthis._data = {};\n\n\t\t// Map of pending sent request objects indexed by request id.\n\t\t// @type {Map<Number, Object>}\n\t\tthis._sents = new Map();\n\n\t\t// Handle transport.\n\t\tthis._handleTransport();\n\t}\n\n\t/**\n\t * Whether the Peer is closed.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\t/**\n\t * Whether the Peer is connected.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget connected()\n\t{\n\t\treturn this._connected;\n\t}\n\n\t/**\n\t * App custom data.\n\t *\n\t * @returns {Object}\n\t */\n\tget data()\n\t{\n\t\treturn this._data;\n\t}\n\n\t/**\n\t * Invalid setter.\n\t */\n\tset data(data) // eslint-disable-line no-unused-vars\n\t{\n\t\tthrow new Error('cannot override data object');\n\t}\n\n\t/**\n\t * Close this Peer and its Transport.\n\t */\n\tclose()\n\t{\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tlogger.debug('close()');\n\n\t\tthis._closed = true;\n\t\tthis._connected = false;\n\n\t\t// Close Transport.\n\t\tthis._transport.close();\n\n\t\t// Close every pending sent.\n\t\tfor (const sent of this._sents.values())\n\t\t{\n\t\t\tsent.close();\n\t\t}\n\n\t\t// Emit 'close' event.\n\t\tthis.safeEmit('close');\n\t}\n\n\t/**\n\t * Send a protoo request to the server-side Room.\n\t *\n\t * @param {String} method\n\t * @param {Object} [data]\n\t *\n\t * @async\n\t * @returns {Object} The response data Object if a success response is received.\n\t */\n\tasync request(method, data = undefined)\n\t{\n\t\tconst request = Message.createRequest(method, data);\n\n\t\tthis._logger.debug('request() [method:%s, id:%s]', method, request.id);\n\n\t\t// This may throw.\n\t\tawait this._transport.send(request);\n\n\t\treturn new Promise((pResolve, pReject) =>\n\t\t{\n\t\t\tconst timeout = 1500 * (15 + (0.1 * this._sents.size));\n\t\t\tconst sent =\n\t\t\t{\n\t\t\t\tid      : request.id,\n\t\t\t\tmethod  : request.method,\n\t\t\t\tresolve : (data2) =>\n\t\t\t\t{\n\t\t\t\t\tif (!this._sents.delete(request.id))\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tclearTimeout(sent.timer);\n\t\t\t\t\tpResolve(data2);\n\t\t\t\t},\n\t\t\t\treject : (error) =>\n\t\t\t\t{\n\t\t\t\t\tif (!this._sents.delete(request.id))\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tclearTimeout(sent.timer);\n\t\t\t\t\tpReject(error);\n\t\t\t\t},\n\t\t\t\ttimer : setTimeout(() =>\n\t\t\t\t{\n\t\t\t\t\tif (!this._sents.delete(request.id))\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tpReject(new Error('request timeout'));\n\t\t\t\t}, timeout),\n\t\t\t\tclose : () =>\n\t\t\t\t{\n\t\t\t\t\tclearTimeout(sent.timer);\n\t\t\t\t\tpReject(new Error('peer closed'));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Add sent stuff to the map.\n\t\t\tthis._sents.set(request.id, sent);\n\t\t});\n\t}\n\n\t/**\n\t * Send a protoo notification to the server-side Room.\n\t *\n\t * @param {String} method\n\t * @param {Object} [data]\n\t *\n\t * @async\n\t */\n\tasync notify(method, data = undefined)\n\t{\n\t\tconst notification = Message.createNotification(method, data);\n\n\t\tthis._logger.debug('notify() [method:%s]', method);\n\n\t\t// This may throw.\n\t\tawait this._transport.send(notification);\n\t}\n\n\t_handleTransport()\n\t{\n\t\tif (this._transport.closed)\n\t\t{\n\t\t\tthis._closed = true;\n\n\t\t\tsetTimeout(() =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tthis._connected = false;\n\n\t\t\t\tthis.safeEmit('close');\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis._transport.on('open', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('emit \"open\"');\n\n\t\t\tthis._connected = true;\n\n\t\t\tthis.safeEmit('open');\n\t\t});\n\n\t\tthis._transport.on('disconnected', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('emit \"disconnected\"');\n\n\t\t\tthis._connected = false;\n\n\t\t\tthis.safeEmit('disconnected');\n\t\t});\n\n\t\tthis._transport.on('failed', (currentAttempt) =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('emit \"failed\" [currentAttempt:%s]', currentAttempt);\n\n\t\t\tthis._connected = false;\n\n\t\t\tthis.safeEmit('failed', currentAttempt);\n\t\t});\n\n\t\tthis._transport.on('close', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tthis._closed = true;\n\n\t\t\tlogger.debug('emit \"close\"');\n\n\t\t\tthis._connected = false;\n\n\t\t\tthis.safeEmit('close');\n\t\t});\n\n\t\tthis._transport.on('message', (message) =>\n\t\t{\n\t\t\tif (message.request)\n\t\t\t\tthis._handleRequest(message);\n\t\t\telse if (message.response)\n\t\t\t\tthis._handleResponse(message);\n\t\t\telse if (message.notification)\n\t\t\t\tthis._handleNotification(message);\n\t\t});\n\t}\n\n\t_handleRequest(request)\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.emit('request',\n\t\t\t\t// Request.\n\t\t\t\trequest,\n\t\t\t\t// accept() function.\n\t\t\t\t(data) =>\n\t\t\t\t{\n\t\t\t\t\tconst response = Message.createSuccessResponse(request, data);\n\n\t\t\t\t\tthis._transport.send(response)\n\t\t\t\t\t\t.catch(() => {});\n\t\t\t\t},\n\t\t\t\t// reject() function.\n\t\t\t\t(errorCode, errorReason) =>\n\t\t\t\t{\n\t\t\t\t\tif (errorCode instanceof Error)\n\t\t\t\t\t{\n\t\t\t\t\t\terrorReason = errorCode.message;\n\t\t\t\t\t\terrorCode = 500;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeof errorCode === 'number' && errorReason instanceof Error)\n\t\t\t\t\t{\n\t\t\t\t\t\terrorReason = errorReason.message;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst response =\n\t\t\t\t\t\tMessage.createErrorResponse(request, errorCode, errorReason);\n\n\t\t\t\t\tthis._transport.send(response)\n\t\t\t\t\t\t.catch(() => {});\n\t\t\t\t});\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tconst response = Message.createErrorResponse(request, 500, String(error));\n\n\t\t\tthis._transport.send(response)\n\t\t\t\t.catch(() => {});\n\t\t}\n\t}\n\n\t_handleResponse(response)\n\t{\n\t\tconst sent = this._sents.get(response.id);\n\n\t\tif (!sent)\n\t\t{\n\t\t\tlogger.error(\n\t\t\t\t'received response does not match any sent request [id:%s]', response.id);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (response.ok)\n\t\t{\n\t\t\tsent.resolve(response.data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst error = new Error(response.errorReason);\n\n\t\t\terror.code = response.errorCode;\n\t\t\tsent.reject(error);\n\t\t}\n\t}\n\n\t_handleNotification(notification)\n\t{\n\t\tthis.safeEmit('notification', notification);\n\t}\n}\n\nmodule.exports = Peer;\n\n\n//# sourceURL=webpack:///./src/websocketClient/Peer.js?");

/***/ }),

/***/ "./src/websocketClient/WebSocketTransport.js":
/*!***************************************************!*\
  !*** ./src/websocketClient/WebSocketTransport.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const W3CWebSocket = __webpack_require__(/*! websocket */ \"./node_modules/websocket/lib/browser.js\").w3cwebsocket;\nconst retry = __webpack_require__(/*! retry */ \"./node_modules/retry/index.js\");\nconst Logger = __webpack_require__(/*! ./Logger */ \"./src/websocketClient/Logger.js\");\nconst EnhancedEventEmitter = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/websocketClient/EnhancedEventEmitter.js\");\nconst Message = __webpack_require__(/*! ./Message */ \"./src/websocketClient/Message.js\");\n\nlet WS_SUBPROTOCOL = 'protoo';\nconst DEFAULT_RETRY_OPTIONS =\n{\n\tretries    : 10,\n\tfactor     : 2,\n\tminTimeout : 1 * 1000,\n\tmaxTimeout : 8 * 1000\n};\n\nconst logger = new Logger('WebSocketTransport');\n\nclass WebSocketTransport extends EnhancedEventEmitter\n{\n\t/**\n\t * @param {String} url - WebSocket URL.\n\t * @param {Object} [options] - Options for WebSocket-Node.W3CWebSocket and retry.\n\t */\n\tconstructor(url, options)\n\t{\n\t\tsuper(logger);\n\n\t\tlogger.debug('constructor() [url:%s, options:%o]', url, options);\n\n\t\tif(options!=null&&options.subprotocol!=null&&options.subprotocol!=\"\")\n\t\t{\n\t\t\tWS_SUBPROTOCOL=options.subprotocol;\n\t\t}\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// WebSocket URL.\n\t\t// @type {String}\n\t\tthis._url = url;\n\n\t\t// Options.\n\t\t// @type {Object}\n\t\tthis._options = options || {};\n\n\t\t// WebSocket instance.\n\t\t// @type {WebSocket}\n\t\tthis._ws = null;\n\n\t\t// Run the WebSocket.\n\t\tthis._runWebSocket();\n\t}\n\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\tclose()\n\t{\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tlogger.debug('close()');\n\n\t\t// Don't wait for the WebSocket 'close' event, do it now.\n\t\tthis._closed = true;\n\t\tthis.safeEmit('close');\n\n\t\ttry\n\t\t{\n\t\t\tthis._ws.onopen = null;\n\t\t\tthis._ws.onclose = null;\n\t\t\tthis._ws.onerror = null;\n\t\t\tthis._ws.onmessage = null;\n\t\t\tthis._ws.close();\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.error('close() | error closing the WebSocket: %o', error);\n\t\t}\n\t}\n\n\tasync send(message)\n\t{\n\t\tif (this._closed)\n\t\t\tthrow new Error('transport closed');\n\n\t\ttry\n\t\t{\n\t\t\tthis._ws.send(JSON.stringify(message));\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.warn('send() failed:%o', error);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t_runWebSocket()\n\t{\n\t\tconst operation =\n\t\t\tretry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);\n\n\t\tlet wasConnected = false;\n\t\tlet connTime=new Date();\n\n\t\toperation.attempt((currentAttempt) =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t{\n\t\t\t\toperation.stop();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug('_runWebSocket() [currentAttempt:%s]', currentAttempt);\n\n\t\t\tthis._ws = new W3CWebSocket(\n\t\t\t\tthis._url,\n\t\t\t\tWS_SUBPROTOCOL,\n\t\t\t\tthis._options.origin,\n\t\t\t\tthis._options.headers,\n\t\t\t\tthis._options.requestOptions,\n\t\t\t\tthis._options.clientConfig);\n\n\t\t\tthis._ws.onopen = () =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\twasConnected = true;\n\n\t\t\t\t// Emit 'open' event.\n\t\t\t\tthis.safeEmit('open');\n\t\t\t};\n\n\t\t\tthis._ws.onclose = (event) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tlet ts=new Date().getTime()- connTime.getTime();\n\t\t\t\tlet errorCode=331;\n\t\t\t\tif(ts>1000*3)\n\t\t\t\t{\n\t\t\t\t\terrorCode=500;\n\t\t\t\t}\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'WebSocket \"close\" event [wasClean:%s, code:%s, reason:\"%s\"]',\n\t\t\t\t\tevent.wasClean, event.code, event.reason);\n\n\t\t\t\t// Don't retry if code is 4000 (closed by the server).\n\t\t\t\tif (event.code !== 4000)\n\t\t\t\t{\n\t\t\t\t\t// If it was not connected, try again.\n\t\t\t\t\tif (!wasConnected)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.safeEmit('failed', errorCode);\n\n\t\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tif (operation.retry(true))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// If it was connected, start from scratch.\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toperation.stop();\n\n\t\t\t\t\t\tthis.safeEmit('disconnected');\n\n\t\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tthis._runWebSocket();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._closed = true;\n\n\n\t\t\t\t// Emit 'close' event.\n\t\t\t\tthis.safeEmit('close',errorCode);\n\t\t\t};\n\n\t\t\tthis._ws.onerror = (error) =>\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n                \n\t\t\n\t\t\t\n\t\t\t\tlogger.error('WebSocket \"error\" event');\n\t\t\t};\n\n\t\t\tthis._ws.onmessage = (event) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tconst message = Message.parse(event.data);\n\n\t\t\t\tif (!message)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (this.listenerCount('message') === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'no listeners for WebSocket \"message\" event, ignoring received message');\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Emit 'message' event.\n\t\t\t\tthis.safeEmit('message', message);\n\t\t\t};\n\t\t});\n\t}\n}\n\nmodule.exports = WebSocketTransport;\n\n\n//# sourceURL=webpack:///./src/websocketClient/WebSocketTransport.js?");

/***/ }),

/***/ "./src/websocketClient/index.js":
/*!**************************************!*\
  !*** ./src/websocketClient/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Peer = __webpack_require__(/*! ./Peer */ \"./src/websocketClient/Peer.js\");\nconst WebSocketTransport = __webpack_require__(/*! ./WebSocketTransport */ \"./src/websocketClient/WebSocketTransport.js\");\n\n/**\n * Expose mediasoup-client version.\n *\n * @type {String}\n */\nexports.version = \"4.0.3\";\n\n/**\n * Expose Peer class.\n *\n * @type {Class}\n */\nexports.Peer = Peer;\n\n/**\n * Expose WebSocketTransport class.\n *\n * @type {Class}\n */\nexports.WebSocketTransport = WebSocketTransport;\n\n\n//# sourceURL=webpack:///./src/websocketClient/index.js?");

/***/ }),

/***/ "./src/websocketClient/utils.js":
/*!**************************************!*\
  !*** ./src/websocketClient/utils.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Generates a random positive integer.\n *\n * @returns {Number}\n */\nexports.generateRandomNumber = function()\n{\n\treturn Math.round(Math.random() * 10000000);\n};\n\n\n//# sourceURL=webpack:///./src/websocketClient/utils.js?");

/***/ }),

/***/ 0:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///crypto_(ignored)?");

/***/ })

/******/ });
});